[{"title":"不用spring如何实例化一个bean","date":"2019-05-13T16:00:00.000Z","path":"2019/05/14/spring/spring-base/不用spring如何实例化一个bean/","text":"问题源起&emsp;&emsp;为什么写这么一篇文章那？主要还是源自最近在写支付的starter的过程中遇到的一个问题，我们知道在支付的过程中需要去配置一些相关的参数，因为是starter我们一般是通过配置文件的方式进行配置，引用我们stater的工程会通过yml文件中配置的属性把这些值给我们。 &emsp;&emsp;那么我想在stater里面取到这些值该如何去做那？？我直接new一个配置类对象但是却取不到，因此我们就在思考spring到底是如何实例化bean的？？他对bean做了什么？？如果不用spring的注解我们又该如何去实例化我们的bean那？带着这些问题我开始了我的解惑之旅。。。 问题深究给自己新建一个问题12345678910111213141516@AllArgsConstructor@RestController@RequestMapping(\"/api/v1/app/\")public class AppController extends BaseController &#123; @Autowired AppBannerService appBannerService; @RequestMapping(value = \"index\", method = RequestMethod.POST) public Result index(HttpServletRequest request,@RequestBody @Valid AppBannerAreaCode appBannerAreaCode) &#123; Map&lt;String,Object&gt; appMessage=new HashMap&lt;&gt;(); String appId=CommonUtils.getAppIdFromHeader(request); List&lt;AppBanner&gt; banners=appBannerService.getBannersByAppIdAndCode(appId,appBannerAreaCode.getProvinceCode()); return new Result(banners); &#125;&#125; &emsp;&emsp;上面的controller是我用日常开发常用的，AppBannerService是我们定义的业务接口，接口有实现类，我们只需要简单的注解就可以直接调用接口的方法了。 spring如何实例化bean？？我们假如不用这个注解如何去调这个接口那？？&emsp;&emsp;接下来我们就围绕这两个问题进行展开。 问题分解spring实例化方式有那些？？&emsp;&emsp;软件开发到最后的最高境界就是制定标准，然后严格安装标准去开发和迭代。我个人认为spring也是 spring四种实例化方式 setter方法实例化 主类 1234567891011121314151617181920212223242526public interface IUserDao &#123; void addUser(); void delUser(); void updateUser(); &#125; public class UserDaoImpl implements IUserDao &#123; public void addUser() &#123; System.out.println(\"addUser方法被调用了\"); &#125; public void delUser() &#123; System.out.println(\"delUser方法被调用了\"); &#125; public void updateUser() &#123; System.out.println(\"updateUser方法被调用了\"); &#125; &#125; public class UserAction &#123; private IUserDao dao; //dao是一个依赖对象,要由springg进行管理,要生成 get set 方法 public void execute()&#123; dao.addUser(); dao.updateUser(); dao.delUser(); &#125; &#125; 配置文件 12345//配置文件&lt;bean name=\"userAction_name\" class=\"cat.action.UserAction\" &gt;&lt;property name=\"dao\" ref=\"userDao_name\" /&gt; //引用的是下面的名称&lt;/bean&gt; &lt;bean name=\"userDao_name\" class=\"cat.dao.UserDaoImpl\" /&gt; - 测试 1234 //测试ClassPathXmlApplicationContext ctx=new ClassPathXmlApplicationContext(\"beans.xml\");UserAction action=(UserAction)ctx.getBean(\"userAction_name\");action.execute(); - 构造函数 - 主类 123456789101112131415161718192021222324public class UserAction &#123; //public UserAction()&#123;&#125; 可以保保留一个无参的构造函数 //这是几个依赖对象,不用生成get set方法了 private UserInfo user; private String school; private IUserDao dao; //希望Spring 由构造函数注入依赖对象 public UserAction(IUserDao dao,UserInfo user,String school)&#123; this.dao=dao; this.school=school; this.user=user; &#125; public void execute()&#123; dao.addUser(); dao.updateUser(); dao.delUser(); System.out.println(user); System.out.println(school);&#125; - 配置文件 123456789101112131415161718192021222324//配置文件&lt;bean name=\"userInfo_name\" class=\"cat.beans.UserInfo\" &gt; &lt;property name=\"id\" value=\"1\" /&gt; &lt;property name=\"userName\" value=\"周周\" /&gt; &lt;property name=\"password\" value=\"123\" /&gt; &lt;property name=\"note\" value=\"这是备注\" /&gt;&lt;/bean&gt; &lt;bean name=\"userAction_name\" class=\"cat.action.UserAction\" &gt; &lt;constructor-arg ref=\"userDao_name\" /&gt; &lt;constructor-arg ref=\"userInfo_name\" /&gt; &lt;constructor-arg value=\"哈尔滨师范大学\" /&gt;&lt;/bean&gt; /*也可以指定 索引和 type 属性 , 索引和type 都可以不指定&lt;bean name=\"userAction_name\" class=\"cat.action.UserAction\" &gt;&lt;constructor-arg index=\"0\" ref=\"userDao_name\" type=\"cat.dao.IUserDao\" /&gt; 如果是接口,就不能指定是实现类的类型&lt;constructor-arg index=\"1\" ref=\"userInfo_name\" type=\"cat.beans.UserInfo\" /&gt;&lt;constructor-arg index=\"2\" value=\"哈尔滨师范大学\" /&gt;&lt;/bean&gt;*/ &lt;bean name=\"userDao_name\" class=\"cat.dao.UserDaoImpl\" /&gt; - 测试 1234//测试ClassPathXmlApplicationContext ctx=new ClassPathXmlApplicationContext(\"beans.xml\");UserAction action=(UserAction)ctx.getBean(\"userAction_name\");action.execute(); - 静态工厂方式 - 主类 123456789101112131415161718192021//工厂,用来生成dao的实现类public class UserDaoFactory &#123;public static IUserDao createUserDaoInstance()&#123; return new UserDaoOracleImpl(); &#125;&#125; public class UserAction &#123; private IUserDao dao;//使用工厂方式注值,也要生成set方法 public void execute()&#123; dao.addUser(); dao.updateUser(); dao.delUser();&#125; public void setDao(IUserDao dao) &#123; this.dao = dao;&#125; &#125; - 配置文件 123456//配置文件 &lt;bean name=\"userAction_name\" class=\"cat.action.UserAction\" &gt;&lt;property name=\"dao\" ref=\"userDao_name\" /&gt;&lt;/bean&gt; &lt;bean name=\"userDao_name\" class=\"cat.dao.UserDaoFactory\" factory-method=\"createUserDaoInstance\" /&gt; - 测试 1234//测试ClassPathXmlApplicationContext ctx=new ClassPathXmlApplicationContext(\"beans.xml\");UserAction action=(UserAction)ctx.getBean(\"userAction_name\");action.execute(); - 实例工厂 - 主类 1234567//工厂 =&gt;public class UserDaoFactory &#123;//这个方法不是静态的public IUserDao createUserDaoInstance()&#123; return new UserDaoOracleImpl(); &#125;&#125; - 配置文件 1234567//配置文件 &lt;bean name=\"userAction_name\" class=\"cat.action.UserAction\" &gt;&lt;property name=\"dao\" ref=\"userDao_name\" /&gt;&lt;/bean&gt; &lt;bean name=\"userDaoFactory_name\" class=\"cat.dao.UserDaoFactory\" /&gt;&lt;bean name=\"userDao_name\" factory-bean=\"userDaoFactory_name\" factory-method=\"createUserDaoInstance\" /&gt; - 测试 解决问题 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"spring","slug":"spring","permalink":"https://lywlefan.github.io/tags/spring/"},{"name":"spring-base","slug":"spring-base","permalink":"https://lywlefan.github.io/tags/spring-base/"}]},{"title":"如何写一个stater","date":"2019-05-12T16:00:00.000Z","path":"2019/05/13/spring/spring-boot/如何写一个stater/","text":"目标刻在岩石上，方法写在沙滩上. 命名规范&emsp;&emsp;不要使用spring-boot开头的，以避免将来spring-boot官方使用你的starter而重名。 正例：xxxx-spring-boot-starter 反例：spring-boot-starter-xxxx 定功能&emsp;&emsp;你所定义的starter需要有自己的独特功能，比如spring-boot-starter-web 提供的springmvc相关的自动装配，内嵌tomcat以及相关依赖，那们你自己定义的starter也是需要界定好自己的功能。举个列子，比如要写一个支付的stater： 支付 支付通知 支付查询 退款 退款查询 退款通知 项目依赖 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"spring-boot","slug":"spring-boot","permalink":"https://lywlefan.github.io/tags/spring-boot/"},{"name":"spring","slug":"spring","permalink":"https://lywlefan.github.io/tags/spring/"}]},{"title":"【码农日记01】一个很有意思的想法","date":"2018-05-29T16:00:00.000Z","path":"2018/05/30/【码农日记01】一个很有意思的想法/","text":"&emsp;&emsp;既然选择了就用心去玩味，不喜欢就放下，少一点抱怨和徘徊，人生短短几十年，认定就去做！不知道下一步该怎么走，就做好当下的事！——share猿 时间：2018-11-15天气：多云转小雨星期：星期四 ###序 &emsp;&emsp;我是一名奋斗在二线城市的菜鸟级程序员，大学学的制药工程，从大二开始就一直想自己未来要做什么？大学毕业要什么？想通了未来要做什么，未来要做一名企业家，为这个社会创造更大的价值，但不知道下一步该如何走。终于在大三的时候我想通了，我要进入互联网行业，怎么进入那？就在自己犹豫不决时，一个院系的小伙子给了我思路，学软件，搞编程，就这样入了这个坑，后来在我小姨家哥的帮助下选择了java这门高大上的语言，真的是一入java深似海呀！到大三下半学期开始自学，除了考二级的时候学过一点vb，再根本没有一点软件基础，现在想想真的佩服自己当时的勇气，每天抱着电脑看传智播客的视频，刚开始看的那种感觉真心难受，一遍看完根本不知道人家在说什么，强忍着泪花把这一套视频看完，看完感觉跟没看差不多。 &emsp;&emsp;后来，在一次和发小聊天中了解到，他也是做软件开发的，我咨询了他让他给我一点建议，他建议我想找一份实习的工作，然后边干边学习，慢慢的就提高了！我要到了他们公司人事的电话，沟通过后在智联招聘上投了简历，很幸运约到了面试，面试当天穿的西装革履，带着打印的彩色简历，现在想想真的很怀恋那时候对一件事的坚持和热情，有时候对人对事的态度真的很重要，一件事一个人你从内心用什么态度一般情况下就会预示着未来会取得什么样的结果，用真心去生活真的很重要，知道自己要什么？做什么？未来要成为什么样的人？心中要有尺度！面试过后我也入愿进入一家在家乡比较大的软件公司开始了我的软件生涯，一直到现在，在这儿过程中遇到了很多挫折，好多问题其实只要别人指导一下就可以解决，但是死磕到底虽然解决了问题但是效率不高，没有真正将时间用在刀刃上，为此那我想通过记录我这个菜鸟每天的软件历程以及在日常工作的所感所悟记录下来，希望能给这个行业带来一些价值，为这个社会带来一些价值，我认为一个人活着的意义在于创造。 ###想法 &emsp;&emsp;把自己在软件行业的每天所感所悟所学记录下来，一方面作为自己对一天生活的总结和下一天生活的计划，另一方面希冀能够为共同奋斗在一线行业的同行们提供一些行业知识的素材，可能我的诸多理解很浅显或者是错的，大家可以提出来指正，把我们共同的故事记录在这里为后来人带来些许帮助。 ###日记更新周期 &emsp;&emsp;工作日必更，节假日看更！ ###今日历程 &emsp;&emsp;今天的主要工作是大家在一起测试各自的接口，为什么大家要做在一起测，老大说大家做在一起测试一方面可以测试出接口存在的问题，同时大家可以在一起商量重构代码和整体的架构微调，大家不做在一个桌面上，有些问题是没办法暴露出来的，团队成员也感知不到各自之间的差距，大家做到一起才能真正的切实感触到，事实证明这次测试效果很好。 &emsp;&emsp;比较遗憾的是我今天没有准备充分，耽误了大家很多时间我感到很愧疚。究其原因主要在自己对每天的工作没有计划导致的，尤其像这种团体性活动更不能粗心大意，不然到头你耽误的是大家的时间，每人十分钟一个小时就过去了，这是赤裸裸的“谋财害命”，只有尊重大家的时间才能得到大家的尊重，我深刻的检讨自己此次在工作中的失误，那么在接口测试中需要做什么预备工作那？？？我简单的列举一下我的总结，大家如果觉得缺少什么可以在评论中做以补充，谢谢！ 笔记本准备（我本次就是因为安装了ubuntu桌面版的系统没有安装好相关软件耽误了大家的时间） 代码规范约文档 测试环境 测试数据 postman接口整理 接口文档整理 &emsp;&emsp;相信经过以上的准备，大家在一起测接口的过程中会事半功倍，效率更高。在测试的过程中要及时的记录问题，梳理成文档，方便团队成员之间进行查阅，因为好多问题都是共性的问题，一旦发现成员在下去就可以及时修改，这是一个良性循环，这样在后面问题也会越来越少，测试效率也越来越高。 本次测试过程中我总体感觉是没有秩序，究其原因我总结了以下几点： 流程不明确（大家一起先测接口还是先看代码，接口测试是先测接口是否正常还是先测参数问题等等我觉得这些都是可以流程化的东西） 准备资料不全（比如：postman接口谁开发的就可以谁录好，大家共同登录，因为postman本然就是可以多人同时在线的，或者导出来发给大家。） 在本次测试中也发现了很多问题，让我受益良多，下面我一一列举。 没有定义规范导致在开发过程中团队成员之间代码每个人都不一样。比如注释规范没有定义导致出现了多种不同的注释方式，路径命名规定没定义，有的人在路径前面加了api/v1（加这个的意义在于代码的升级），大家引用的常量不一样，通用字段的命名和类型长度不一样，处理异常的方式不一样，返回码不统一，校验方式不统一等等，我个人认为，这些事应当是架构师统一去约定和规范，好的架构师一方面要保证架构的稳定，同时还要约定要规范，包装好一些通用的东西，这样才能让下面的人更好的去开发。 枚举类型没有检验。在java的参数检验中我们常用封装好Spring-validate进行校验，这里只提供一些基本的检验，比如非空校验、长度检验。要检验枚举我们只能自己自定义注解去校验了，自定义注解我们可以在网上搜到，这里不做过多的阐述，大家可以自己去寻找，总结出自己的套路和方法，好多事情没有咱们想的那么难。 接口要保持单一性。在这次测试过程中遇到一个问题，我把新增和编辑写成了同一个接口，我们在常规作miss系统的过程中一般是这样去做的，但是在接口开发中为什么要分开那？听了老大的讲解后恍然大悟，分开确实有分开的道理，首先是方便前端人员的对接，另一方面新增和编辑里面的逻辑也不一样，分开可以处理各自的业务和逻辑。 给前端返回实体。在miss系统中我们一般是全部返回的，但是在接口开发中，前端需要什么就返回什么，我们可以新定义一个vo去返回给前端，这样一方面避免把自己的数据库结构爆露出去，防止敏感字段的泄漏，让对接的接口的前端人员也更加舒服，让自己代码可读性好，让别人看着自己代码或者文档舒心这是程序员的基本素养。在实体相关值复制到vo的过程中，我一开始用的BeanUtis去copy的，但是大家说这样效率有点低下可以用Json进行复制效率相对高一点。 ###感悟 &emsp;&emsp;牛逼的技术非一日之功，要沉下心慢慢去沉淀，多向身边的人去学习，学识不分大小，这个行业不分资历只凭学识，活到老学到老。 &emsp;&emsp;今天的日记就写到这里，第一天写有诸多的不足，希望大家及时提出，我不怕喷。 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"日记","slug":"日记","permalink":"https://lywlefan.github.io/tags/日记/"},{"name":"思考","slug":"思考","permalink":"https://lywlefan.github.io/tags/思考/"}]},{"title":"spring的核心jar","date":"2018-05-29T16:00:00.000Z","path":"2018/05/30/spring/spring的核心jar/","text":"&emsp;&emsp;实践一门技术的最好方式就是深入理解它的思想，然后造一个出来！ Spring AOP：Spring的面向切面编程，提供AOP（面向切面编程）的实现 Spring Aspects：Spring提供的对AspectJ框架的整合 Spring Beans：Spring IOC的基础实现，包含访问配置文件、创建和管理bean等。 Spring Context：在基础IOC功能上提供扩展服务，此外还提供许多企业级服务的支持，有邮件服务、任务调度、JNDI定位，EJB集成、远程访问、缓存以及多种视图层框架的支持。 Spring Context Support：Spring context的扩展支持，用于MVC方面。 Spring Core：Spring的核心工具包 Spring expression：Spring表达式语言 Spring Framework Bom： Spring Instrument：Spring对服务器的代理接口 Spring Instrument Tomcat：Spring对tomcat连接池的集成 Spring JDBC：对JDBC 的简单封装 Spring JMS：为简化jms api的使用而做的简单封装 Spring Messaging： Spring orm：整合第三方的orm实现，如hibernate，ibatis，jdo以及spring 的jpa实现 Spring oxm：Spring对于object/xml映射的支持，可以让JAVA与XML之间来回切换 Spring test：对JUNIT等测试框架的简单封装 Spring tx：为JDBC、Hibernate、JDO、JPA等提供的一致的声明式和编程式事务管理。 Spring web：包含Web应用开发时，用到Spring框架时所需的核心类，包括自动载入WebApplicationContext特性的类、Struts与JSF集成类、文件上传的支持类、Filter类和大量工具辅助类。 Spring webmvc：包含SpringMVC框架相关的所有类。包含国际化、标签、Theme、视图展现的FreeMarker、JasperReports、Tiles、Velocity、XSLT相关类。当然，如果你的应用使用了独立的MVC框架，则无需这个JAR文件里的任何类。 Spring webmvc portlet：Spring MVC的增强 【1】简书主页·share猿 【2】掘金主页·share猿 — 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"spring源码","slug":"spring源码","permalink":"https://lywlefan.github.io/tags/spring源码/"},{"name":"总汇","slug":"总汇","permalink":"https://lywlefan.github.io/tags/总汇/"}]},{"title":"我的文章收藏夹","date":"2011-12-31T16:00:00.000Z","path":"2012/01/01/如何快速寻找到一个问题的答案/","text":"目标刻在岩石上，方法写在沙滩上。 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"文章","slug":"文章","permalink":"https://lywlefan.github.io/tags/文章/"},{"name":"收藏","slug":"收藏","permalink":"https://lywlefan.github.io/tags/收藏/"}]},{"title":"我的文章收藏夹","date":"2011-12-31T16:00:00.000Z","path":"2012/01/01/文章收藏/","text":"【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"文章","slug":"文章","permalink":"https://lywlefan.github.io/tags/文章/"},{"name":"收藏","slug":"收藏","permalink":"https://lywlefan.github.io/tags/收藏/"}]},{"title":"我的网址收藏夹","date":"2011-12-31T16:00:00.000Z","path":"2012/01/01/网址收藏/","text":"目标刻在岩石上，方法写在沙滩上. 1.技术栈1.1.WEB开发1.1.1.前端1.1.2.后端1.2.高级技术1.2.1.深度学习 神经网络与深度学习·邱锡鹏 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"收藏","slug":"收藏","permalink":"https://lywlefan.github.io/tags/收藏/"},{"name":"网址","slug":"网址","permalink":"https://lywlefan.github.io/tags/网址/"}]}]