[{"title":"02.redis的线程IO和通讯协议","date":"2019-08-12T16:00:00.000Z","path":"2019/08/13/中间件/redis/02.redis的线程IO和通讯协议/","text":"redis的线程IO 线程IO Redis是个单线程程序!但是他有高并发特性,单个节点可以支持10w的QPS。除了redis是单线程,Nginx也是单线程的。单线程为什么如此之快?单线程有如何处理多并发的客户端连接?下面让我们带着这些问题一起深究redis的线程IO。 5种IO模型学习 阻塞IO模型 非阻塞IO模型 IO复用模型 信号驱动的IO模型 异步IO模型 阻塞IO模型进程发起IO系统调用后，进程被阻塞，转到内核空间处理，整个IO处理完毕后返回进程。操作成功则进程获取到数据。 类比老李去火车站买票，排队三天买到一张退票。 耗费：在车站吃喝拉撒睡 3天，其他事一件没干。 典型应用 阻塞socket java BIO 特点 进程阻塞挂起不消耗CPU资源，及时响应每个操作； 实现难度低、开发应用较容易； 适用并发量小的网络应用开发； 不适用并发量大的应用：因为一个请求IO会阻塞进程，所以，得为每请求分配一个处理进程（线程）以及时响应，系统开销大。 非阻塞IO模型进程发起IO系统调用后，如果内核缓冲区没有数据，需要到IO设备中读取，进程返回一个错误而不会被阻塞；进程发起IO系统调用后，如果内核缓冲区有数据，内核就会把数据返回进程。 类比 老李去火车站买票，隔12小时去火车站问有没有退票，三天后买到一张票。 耗费：往返车站6次，路上6小时，其他时间做了好多事。 典型应用 socket是非阻塞的方式（设置为NONBLOCK） 特点 进程轮询（重复）调用，消耗CPU的资源； 实现难度低、开发应用相对阻塞IO模式较难； 适用并发量较小、且不需要及时响应的网络应用开发； IO复用模型多个的进程的IO可以注册到一个复用器（select）上，然后用一个进程调用该select， select会监听所有注册进来的IO； 如果select没有监听的IO在内核缓冲区都没有可读数据，select调用进程会被阻塞；而当任一IO在内核缓冲区中有可数据时，select调用就会返回； 而后select调用进程可以自己或通知另外的进程（注册进程）来再次发起读取IO，读取内核中准备好的数据。 可以看到，多个进程注册IO后，只有另一个select调用进程被阻塞。 类比是找一个宿管大妈来帮你监视下楼的女生, 这个期间你可以些其他的事情. 例如可以顺便看看其他妹子,玩玩王者荣耀, 上个厕所等等. IO复用又包括 select, poll, epoll 模式. 那么它们的区别是什么? select 每一个女生下楼, select大妈都不知道这个是不是你的女神, 她需要一个一个询问, 并且select大妈能力还有限, 最多一次帮你监视1024个妹子 poll 不限制盯着女生的数量, 只要是经过宿舍楼门口的女生, 都会帮你去问是不是你女神 epoll 不限制盯着女生的数量, 并且也不需要一个一个去问. 那么如何做呢? epoll大妈会为每个进宿舍楼的女生脸上贴上一个大字条,上面写上女生自己的名字, 只要女生下楼了, epoll大妈就知道这个是不是你女神了, 然后大妈再通知你. 典型应用 select poll epoll三种方案 nginx都可以选择使用这三个方案 Java NIO; 特点 专一进程解决多个进程IO的阻塞问题，性能好；Reactor模式; 实现、开发应用难度较大； 适用高并发服务应用开发：一个进程（线程）响应多个请求 形成原因如果一个I/O流进来，我们就开启一个进程处理这个I/O流。那么假设现在有一百万个I/O流进来，那我们就需要开启一百万个进程一一对应处理这些I/O流（——这就是传统意义下的多进程并发处理）。思考一下，一百万个进程，你的CPU占有率会多高，这个实现方式及其的不合理。所以人们提出了I/O多路复用这个模型，一个线程，通过记录I/O流的状态来同时管理多个I/O，可以提高服务器的吞吐能力。 信号驱动的IO模型当进程发起一个IO操作，会向内核注册一个信号处理函数，然后进程返回不阻塞；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用IO读取数据。 特点 回调机制，实现、开发应用难度大； 异步IO模型当进程发起一个IO操作，进程返回（不阻塞），但也不能返回果结；内核把整个IO处理完后，会通知进程结果。如果IO操作成功则进程直接获取到数据。 特点 不阻塞，数据一步到位；Proactor模式； 需要操作系统的底层支持，LINUX 2.5 版本内核首现，2.6 版本产品的内核标准特性； 实现、开发应用难度大； 非常适合高性能高并发应用 典型 JAVA7 AIO 高性能服务器应用 通过学习5种IO模型,我们知道了Redis就是使用的IO复用模型里面的select。 指令队列Redis 会将每个客户端套接字都关联一个指令队列。客户端的指令通过队列来排队进行顺序处理，先到先服务。 也就是说指令的请求顺序是通过队列来进行约束的。 响应队列每个客户端关联一个响应队列。然后服务端通过响应队列将数据返回给客户端。 定时任务服务器处理要响应 IO 事件外，还要处理其它事情。比如定时任务就是非常重要的一件事。如果线程阻塞在 select 系统调用上，定时任务将无法得到准时调度。那 Redis 是如何解决这个问题的呢？ 如果面试官问到这个问题我肯定是处于懵逼状态。老钱书中写到,redis会把定时任务记录到一个叫最小堆的数据结构中,每个周期循环redis会立即处理堆最上面的数据。 redis的通讯协议 通讯协议 RESP协议简介Redis 的客户端和服务端之间采取了一种独立名为 RESP(REdis Serialization Protocol) 的协议，作者主要考虑了以下几个点： 容易实现 解析快 人类可读 注意：RESP 虽然是为 Redis 设计的，但是同样也可以用于其他 C/S 的软件。 数据类型及示例RESP 主要可以序列化以下几种类型：整数，单行回复(简单字符串)，数组，错误信息，多行字符串。Redis 客户端向服务端发送的是一组由执行的命令组成的字符串数组，服务端根据不同的命令回复不同类型的数据，但协议的每部分都是以 “\\r\\n” (CRLF) 结尾的。另外 RESP 是二进制安全的，不需要处理从一个进程到另一个进程的传输，因为它使用了前缀长度进行传输。 在 RESP 中, 一些数据的类型通过它的第一个字节进行判断： 单行回复：回复的第一个字节是 “+” 错误信息：回复的第一个字节是 “-” 整形数字：回复的第一个字节是 “:” 多行字符串：回复的第一个字节是 “\\$” 数组：回复的第一个字节是 “*” RESP 协议还是相对易于理解的，另外理解了协议也方便对 Redis 一些问题的定位及客户端的实现。 Redis 协议里有大量冗余的回车换行符，但是这不影响它成为互联网技术领域非常受欢迎的一个文本协议。有很多开源项目使用 RESP 作为它的通讯协议。在技术领域性能并不总是一切，还有简单性、易理解性和易实现性，这些都需要进行适当权衡。 参考文档 【1】简书主页·share猿 【2】掘金主页·share猿 【3】redis官网 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"redis","slug":"redis","permalink":"https://lywlefan.github.io/tags/redis/"},{"name":"redis基础","slug":"redis基础","permalink":"https://lywlefan.github.io/tags/redis基础/"}]},{"title":"内功修炼-算法02","date":"2019-08-12T16:00:00.000Z","path":"2019/08/13/算法/力扣/内功修炼-算法02/","text":"万丈高楼平地起的前提是地基好. 题目:无重复字符的最长子串题目描述给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 123456789101112131415输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。示例 2:输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。示例 3:输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 题目分析关键点 不含有重复字符的最大字符串长度 思路梳理我的解题思路 1.把字符串转换为字符数组 2.把字符串逐个放入set集合(set),同时记录放入集合的数量(j) 2.如果set集合长度和放入数量不符,记录该长度(l),清空set集合,把j设置为0,放入刚才放入的值,继续循环 3.如果继续出现上述清空,和上面记录的长度进行对比,小于清空继续,大于更新记录长度 总结:上述解题思路忽略了空格字符串的情况,存在问题. 正确的解题思路:滑动窗口 时间窗移动原理 1.定义一个map集合(map)，用于存储字符值和位置，key为字符，value为字符位置加1 2.定义一个变量ans,用于记录时间窗最大长度 3.定义时间窗起点start和时间窗结束点end 4.然后把end向右滑动,最大长度为（end-start+1），如果map集合中存在该元素,说明遇到了重复的元素 4.1.记录时间窗最大值ans 4.2.移动时间窗start到重复元素第一个之后的位置 5.继续滑动,直到j=字符串长度 题目解答我的解答123456789101112131415161718192021222324252627282930313233/** * 思路一: * * 1.把字符串转换为字符数组 * 2.把字符串逐个放入set集合(set),同时记录放入集合的数量(j) * 2.如果set集合长度和放入数量不符,记录该长度(l),清空set集合,把j设置为0,放入刚才放入的值,继续循环 * 3.如果继续出现上述清空,和上面记录的长度进行对比,小于清空继续,大于更新记录长度 * * 时间复杂度:T(N) 空间复杂度:O(1) * * 测试情况:不通过 * * 总结分析: * * 1.没有考虑到空格字符串的情况 */public int lengthOfLongestSubstring1(String s) &#123; char [] chars = s.toCharArray(); Set set = new HashSet(); int l=0; for (int i=0,j=0;i&lt;chars.length;i++)&#123; set.add(chars[i]); j++; if (set.size()&lt;j)&#123; l = Math.max(set.size(),l); set.clear(); j = 1; set.add(chars[i]); &#125; &#125; return l;&#125; 正确的解答1234567891011121314151617181920212223242526/** * 思路二: 滑动窗口 * * 1.定义一个map集合(map)，用于存储字符值和位置，key为字符，value为字符位置加1 * 2.定义一个变量ans,用于记录时间窗最大长度 * 3.定义时间窗起点start和时间窗结束点end * 4.然后把end向右滑动,最大长度为（end-start+1），如果map集合中存在该元素,说明遇到了重复的元素 * 4.1.记录时间窗最大值ans * 4.2.移动时间窗start到重复元素第一个之后的位置 * 5.继续滑动,直到j=字符串长度 * */public int lengthOfLongestSubstring2(String s) &#123; int n = s.length(), ans = 0; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (int end = 0, start = 0; end &lt; n; end++) &#123; char alpha = s.charAt(end); if (map.containsKey(alpha)) &#123; start = Math.max(map.get(alpha), start); &#125; ans = Math.max(ans, end - start + 1); map.put(s.charAt(end), end + 1); &#125; return ans;&#125; 题目总结在做这道题目的过程中,没有考虑到空格字符串的情况,这是基础不扎实导致的,null/“”/“ “,这三个还是有很大的区别的,如果大家也遇到和我一样的问题,可以当做是一个教训。 还有就是滑动窗口,这个理解比较麻烦,最好可以看我上面画的那种图,或者你可以自己画一个出来,滑动窗口是一个常用的办法,我们要深入理解。记得在有一次做限流的时候也用到了滑动窗口的概念。 问题讨论 假如让你用滑动窗口实现一个简单的限流,如何实现?(加入星球看答案哦!里面有更多精彩内容!) 参考文档 【1】简书主页·share猿 【2】掘金主页·share猿 【3】leetcode算法指南 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"力扣","slug":"力扣","permalink":"https://lywlefan.github.io/tags/力扣/"}]},{"title":"人生效率手册-时间管理","date":"2019-08-12T16:00:00.000Z","path":"2019/08/13/读书/归档/2019/8月/人生效率手册/人生效率手册-时间管理/","text":"思维导图 金句/语录1.如果一个人花费了越多的时间进行精细化的练习，那么他就越可能做到更好，并且在这个领域当中达到顶级水平。 2.如果要完美地掌握某项复杂的技能，就需要一遍又一遍艰苦的训练，而练习的时间必须达到一个最小的临界值，这个临界值就是10000小时。 3.千万不要认为人生目标只是一种光环或者口号，它必须要成为你的行动纲领，每一天去坚持去实践，让自己的努力看得见。 4.在人生中需要把重要的事情放在前面，并且一次只做好一件事情。 5.真正的时间管理，是从开始计划，到实施计划、总结复盘，再到评估，以及再次计划的过程。 6.你想掌握时间管理，一个非常重要的方法就是用项目管理的方法，来管理好自己的时间，记住四个要素，计划、实施、总结、评估，才能到再次计划。 7.一定要每天都能拿出2~3小时，用在积累自己的核心竞争力上，用来做最重要且不紧急的事情。 8.时间管理，越早想明白越好；但想明白还不够，越早做到越好；做到还不够，只有每天坚持才重要。 9.香港铁路有限公司中国顾问易瑥，在4家世界500强公司担任过高管，他熟练掌握0.1618法则，他喜欢将时间管理与0.1618法则相结合，一般上午11点之前处理最重要、最紧急的事情，下午的时间用来思考最重要的事情，最急的事情必须先处理，最重要的处理不好都不行，如果事情特别重要但不紧急的话可以往后放，但紧急不重要的事情就可以授权给他人做，这就是0.1618法则。我们需要将有限的时间投入那0.1618的事情上，以此来锻炼我们的核心竞争力。 10.最后骨灰级的激励，就是自己愿意去做一个榜样，并且找到你的粉丝们。如果你的行为处处被他人监督，自己想不实施、想犯懒都不行。 11.你要跟过去的自己PK，与过去的自己做一个对比，只要你进步了一点点，那么，你就赢了。 实践感悟时间管理 践行早起仪式 时间要有目标性 硬实力打造 0.1618法则 单点突破打造社区 总结看了这一小节，给我最大的感悟就是，在过去的时光里对自己的时间在进行暴殄天物呀！太浪费了，心疼呀!老铁！一天最起码浪费四五个小时，每天四五个小时，每年一千多小时，我的天，一千多小时，可以干多少大事！成功的人都把这四五个小时把握住了，而我没有把握住还妄想自己某一天能取得巨大成就，你简直开了一个天的玩笑。 其次，给我感触最深的就是要学会用时间的方法。时间管理是一种习惯，书中提到的早起仪式，是连贯的动作，都是好的事情，好的事情就会让你每天有一个好的开始，一日之计在于晨，把握好早餐的时光，起床，写下自己的三个目标，复盘昨日的不足和要改进的地方，全身心投入要硬本领修炼上，然吃早饭，带着快乐的心情去上班，美好的一天就这样开始了！好事也会在我们身上慢慢发生。 一起加油！社区的小伙伴们！加入我们的社区，和我们每天一起打卡学习！和我们一起修炼自己！不负此生！我们是最棒的！ 讨论：大家认为怎样管理自己的时间比较合理？欢迎留言 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://lywlefan.github.io/tags/读书笔记/"},{"name":"2019年读书","slug":"2019年读书","permalink":"https://lywlefan.github.io/tags/2019年读书/"},{"name":"8月读书","slug":"8月读书","permalink":"https://lywlefan.github.io/tags/8月读书/"}]},{"title":"21.合并两个有序的链表","date":"2019-08-05T16:00:00.000Z","path":"2019/08/06/算法/力扣/21.合并两个有序的链表/","text":"万丈高楼平地起的前提是地基好. 题目介绍将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例 1: 12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 题目解答思路梳理题目实现java12 参考文档 【1】简书主页·share猿 【2】掘金主页·share猿 【3】leetcode算法指南 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"力扣","slug":"力扣","permalink":"https://lywlefan.github.io/tags/力扣/"}]},{"title":"22.括号的生成","date":"2019-08-04T16:00:00.000Z","path":"2019/08/05/算法/力扣/22.括号的生成/","text":"万丈高楼平地起的前提是地基好. 题目介绍给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 例如，给出 n = 3，生成结果为： 12345678[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 思路梳理关键点 生成括号对数 生成括号不同对数 生成的括号必须要闭合 生成括号的类型要用大括号包住 如何实现哪??我的思路:分类法 (X) 第一种情况:括号中括号 第二种情况:括号中多个括号 第三种情况:分割括号,然后括号中括号(左右) 第四种情况:括号独立类型 官方思路:题目实现我的实现分析代码最优解实现分析代码 参考文档 【1】简书主页·share猿 【2】掘金主页·share猿 【3】leetcode算法指南 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"力扣","slug":"力扣","permalink":"https://lywlefan.github.io/tags/力扣/"}]},{"title":"20.有效的括号","date":"2019-08-01T16:00:00.000Z","path":"2019/08/02/算法/力扣/20.有效的括号/","text":"万丈高楼平地起的前提是地基好. 题目介绍给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 示例 1: 1234567891011输入: &quot;()&quot;输出: true示例 2:输入: &quot;()[]&#123;&#125;&quot;输出: true示例 3:输入: &quot;(]&quot;输出: false 题目解答思路梳理哪些情况括号不闭合 第一种:[(]) 第二种:[) 第三种:[]( 如何判断括号没有闭合 注意：只包括括号，这是条件要注意！ 1.获取每种类型左括号的第一次出现的位置 2.然后再找到每种类型右括号第一次出现的位置 3.如果存在以下情况则括号没有闭合 a.类型左括号位置小于另一种类型括号右括号的位置,则括号没有闭合 b.任意类型括号不存在左括号或者右括号,则括号没有闭合 最优解 1.把左括号压入栈中 2.如果遇到右括号,取出栈最上面的元素去对应的值,判断和循环的元素是否相等,相等继续循环,否则返回false 3.循环结束,栈里面的元素依次被取出,说明括号串没啥问题,是闭合的. 题目实现java123456789101112131415161718192021222324static Map&lt;Character, Character&gt; map = new HashMap();static &#123; map.put('(', ')'); map.put('&#123;', '&#125;'); map.put('[', ']');&#125;/** * 方法一 */public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack(); for (char in : s.toCharArray()) &#123; //左括号直接入栈 if (map.keySet().contains(in)) &#123; stack.push(in); continue; &#125; if (!stack.isEmpty() &amp;&amp; in == map.get(stack.pop())) continue; return false; &#125; return stack.isEmpty();&#125; 参考文档 【1】简书主页·share猿 【2】掘金主页·share猿 【3】leetcode算法指南 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"力扣","slug":"力扣","permalink":"https://lywlefan.github.io/tags/力扣/"}]},{"title":"算法导航","date":"2019-07-31T16:00:00.000Z","path":"2019/08/01/算法/算法导航/","text":"万丈高楼平地起的前提是地基好. 参考文档 【1】简书主页·share猿 【2】掘金主页·share猿 【3】leetcode算法指南 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"算法导航","slug":"算法导航","permalink":"https://lywlefan.github.io/tags/算法导航/"}]},{"title":"ab.exe压测工具的使用","date":"2019-07-30T16:00:00.000Z","path":"2019/07/31/工具/测试工具/ab.exe压测工具的使用/","text":"工欲善其事，必先利器！ ad.exe介绍ab.exe是一个性能检测工具，是apache server中的一个小组件，使用简单，方便 ad.exe下载下载地址 ad.exe使用步骤打开cmd进入ab.exe所在的路径（默认放在d盘根目录下）命令示例 1234567 #介绍ab的命令ab help#ab命令请求（一共请求10次,10个并发同时请求）ab -n 10 -c 10 http://www.cnblogs.com/#ab命令超时请求（一共请求50次,50个并发同时请求，超时时间设为100秒， 当出现timeout时，可以设置超时时间）ab -n 50 -c 50 -t 100 http://www.cnblogs.com/ ab命令使用场景 可以测试网关的限流 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"测试工具","slug":"测试工具","permalink":"https://lywlefan.github.io/tags/测试工具/"},{"name":"ad.exe","slug":"ad-exe","permalink":"https://lywlefan.github.io/tags/ad-exe/"}]},{"title":"01.初始redis","date":"2019-07-29T16:00:00.000Z","path":"2019/07/30/中间件/redis/01.初始redis/","text":"redis是什么?redis是一个内存型数据(in-memory data structure store)。Redis是用ANSI C编写的。 官网对redis关键词描述 开源内存数据库 可以进行缓存和消息代理 支持的数据类型有：字符串/hash/list/set/bitmaps/hyperloglogs 可以对集合进行排序 地理位置范围半径查询 支持流 内置复制功能 支持lua脚本 LRU缓存淘汰算法 磁盘级的持久化 redis集群 redis支持什么数据类型字符类型(strings)哈希类型(hashes)list集合类型(lists)set集合类型(sets) 不允许重复 无序 sorted set集合类型(sorted sets) 不允许重复 有序(通过设置分数进行排序) 位图(bitmaps) 按位进行标识 适合某个时间段状态只有两种的场景 比如:签到,每天签到,状态就是签了或者没签 占用内存小 hyperloglogs Redis 在 2.8.9 版本添加了 HyperLogLog 结构 Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。 在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。 因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。 HyperLogLog是一种算法，并非redis独有 目的是做基数统计，故不是集合，不会保存元数据，只记录数量而不是数值。 耗空间极小，支持输入非常体积的数据量 核心是基数估算算法，主要表现为计算时内存的使用和数据合并的处理。最终数值存在一定误差 redis中每个hyperloglog key占用了12K的内存用于标记基数（官方文档） pfadd命令并不会一次性分配12k内存，而是随着基数的增加而逐渐增加内存分配；而pfmerge操作则会将sourcekey合并后存储在12k大小的key中，这由hyperloglog合并操作的原理（两个hyperloglog合并时需要单独比较每个桶的值）可以很容易理解。 误差说明：基数估计的结果是一个带有 0.81% 标准错误（standard error）的近似值。是可接受的范围 Redis 对 HyperLogLog 的存储进行了优化，在计数比较小时，它的存储空间采用稀疏矩阵存储，空间占用很小，仅仅在计数慢慢变大，稀疏矩阵占用空间渐渐超过了阈值时才会一次性转变成稠密矩阵，才会占用 12k 的空间 数据结构描述特征 基数统计(不允许重复的数据) 占用12k空间 适用场景 统计注册 IP 数 统计每日访问 IP 数 统计页面实时 UV 数 统计在线用户数 统计用户每天搜索不同词条的个数 参考文档 【1】简书主页·share猿 【2】掘金主页·share猿 【3】redis官网 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"redis","slug":"redis","permalink":"https://lywlefan.github.io/tags/redis/"},{"name":"redis基础","slug":"redis基础","permalink":"https://lywlefan.github.io/tags/redis基础/"}]},{"title":"02.redis的应用--布隆过滤器","date":"2019-07-29T16:00:00.000Z","path":"2019/07/30/中间件/redis/02.redis的应用--布隆过滤器/","text":"布隆过滤器思维导图 布隆过滤器 布隆过滤器应用新闻推送去重垃圾邮件去重插件安装下载插件点击该地址选择合适的版本 1234567#下载wget https://github.com/RedisLabsModules/rebloom/archive/v1.1.1.tar.gz#解压tar zxvf v1.1.1.tar.gzcd rebloom-1.1.1# 编译make 配置插件在redis配置文件(redis.conf)中加入该模块即可 1loadmodule /usr/local/web/redis/RedisBloom-1.1.1/rebloom.so 或者启动的时候加载进去： 1redis-server /etc/redis/redis.conf --loadmodule /opt/redis/RedisBloom-2.0.1/src/rebloom.so INITIAL_SIZE 10000000 ERROR_RATE 0.0001 执行相关命令测试 以上就是我安装的步骤，但是安装完成后还是出现了问题，记录下来，后续慢慢解决。 参考文档 【1】简书主页·share猿 【2】掘金主页·share猿 【3】redis官网 【4】布隆过滤器插件下载地址 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"redis","slug":"redis","permalink":"https://lywlefan.github.io/tags/redis/"},{"name":"布隆过滤器","slug":"布隆过滤器","permalink":"https://lywlefan.github.io/tags/布隆过滤器/"}]},{"title":"《从受欢迎到被需要》读书笔记-01","date":"2019-07-29T16:00:00.000Z","path":"2019/07/30/读书/归档/2019/7月/从受欢迎到被需要-张萌/《从受欢迎到被需要》读书笔记-01/","text":"第一章：从受欢迎到被需要，高情商人的跃迁术思维导图 从受欢迎到被需要第一章 核心观点 价值交换，前提是要挖掘出自己的价值 让人舒服的表达，展示自己的能力、诚意、决心，同时要放低姿态，突出别人重要性，取得共赢的局面。 答应别人的价值要明确具体。 找对通道。 语句摘录 禅宗有句话，大意是“道不可道，然近道之道不可不道”，道理与此大致相同。高情商很难，难在那些不可言说的分寸拿捏。 高情商是可以“变现”的，是所有奋斗者不可或缺的重要助力。 高情商者会让别人感到很舒服，会受到别人欢迎。但并不是所有让别人感觉舒适的人都是高情商者，还可能是“取悦症”患者。让别人感觉舒适，并不等于一定会得到别人的帮助。如果别人乐意帮你，你很幸运，那是情分；反之，也无可厚非。 高情商者会让别人感觉很舒适，这点很重要。但是比这更重要的是用好自己的价值，促进高情商“变现”。 在人与人交往的过程中，不管建立什么样的关系，都不外乎两个因素：一是情感因素。二是价值因素。 我是谁，我能提供什么，我需要什么。 当面对一个陌生人的时候，能够快速运用三点定位法对他进行社交价值定位。 我觉得请人帮忙，最重要的是诚恳，要能放得下面子，放低自己的姿态。这样才能让别人看到你的诚意，他们才会帮助你。对了，还要突出别人帮助你的重要性，还有你对成功的渴望。我想我会这样跟别人说：‘您知道为了这件事，我付出了很多很多的努力。而且您的帮助对我来说也是非常重要的，您可能不知道您现在的选择将会决定我们这件事情的成败。如果您能够施以援手，这份恩情我是永远都不会忘记的。’ 我的感觉是，要想获得别人的帮助，首先得学会‘亮肌肉’。 我不用再跟他说：‘我遇到了一个困难，需要你的帮助。’我可以这么对他说：‘我这里有一个不错的机会，对我们双方都有好处，你要不要试一试？’ 只要是手心朝上向别人索取，不管怎么伪装你都优雅不起来。只有把单向的索取变成双向受益的共赢，这件事才能更加体面。 这个用来弥补对方因为帮你而付出的东西，我把它叫作“兑付型产品”。它可以是实物，可以是信息，也可以是服务。只要用来弥补对方因为帮你而做出的付出，就可以叫作“兑付型产品”。 我们来总结一下展示自己的兑付型产品的三个关键：第一，抢占先机，在事情没开始前，就把兑付型产品拿出来；第二，要具体，这个兑付型产品到底是什么一定要说清楚；第三，要可被量化，除了要说明兑付型产品是什么还要准确说出数量。 首先，你的价值取决于你所处的通道。如果你所处的是一个上升的通道，那你的价值也会跟着不断攀升；如果你所处的是一个下行的通道，那你的价值就会不断贬值。其次，你的价值取决于对方的需求。你的价值符合对方需求时，你就是一个有价值的人。如果对方没有这种需求，你的价值在对方看来也许一文不值。 不管是工作还是创业，都会提前弄明白自己将要进入的这个行业到底是处于上行期还是下行期。 弄明白这个关于价值的问题的关键所在：不光能帮你选择一个事半功倍的领域，还能解决怀才不遇的问题。 思考感悟 人与人之间的关系主要在“情感”和“价值”。 如何和一个陌生人建立深厚的友谊？ 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://lywlefan.github.io/tags/读书笔记/"},{"name":"2019年读书","slug":"2019年读书","permalink":"https://lywlefan.github.io/tags/2019年读书/"},{"name":"7月读书","slug":"7月读书","permalink":"https://lywlefan.github.io/tags/7月读书/"}]},{"title":"多小的个体都要有自己的品牌","date":"2019-07-29T16:00:00.000Z","path":"2019/07/30/读书/归档/2019/7月/从受欢迎到被需要-张萌/多小的个体都要有自己的品牌/","text":"从受欢迎到被需要从受欢迎到被需要思维导图 第一章：从受欢迎到被需要，高情商人的跃迁术思维导图 从受欢迎到被需要第一章 核心观点 价值交换，前提是要挖掘出自己的价值 让人舒服的表达，展示自己的能力、诚意、决心，同时要放低姿态，突出别人重要性，取得共赢的局面。 答应别人的价值要明确具体。 找对通道。 语句摘录 禅宗有句话，大意是“道不可道，然近道之道不可不道”，道理与此大致相同。高情商很难，难在那些不可言说的分寸拿捏。 高情商是可以“变现”的，是所有奋斗者不可或缺的重要助力。 高情商者会让别人感到很舒服，会受到别人欢迎。但并不是所有让别人感觉舒适的人都是高情商者，还可能是“取悦症”患者。让别人感觉舒适，并不等于一定会得到别人的帮助。如果别人乐意帮你，你很幸运，那是情分；反之，也无可厚非。 高情商者会让别人感觉很舒适，这点很重要。但是比这更重要的是用好自己的价值，促进高情商“变现”。 在人与人交往的过程中，不管建立什么样的关系，都不外乎两个因素：一是情感因素。二是价值因素。 我是谁，我能提供什么，我需要什么。 当面对一个陌生人的时候，能够快速运用三点定位法对他进行社交价值定位。 我觉得请人帮忙，最重要的是诚恳，要能放得下面子，放低自己的姿态。这样才能让别人看到你的诚意，他们才会帮助你。对了，还要突出别人帮助你的重要性，还有你对成功的渴望。我想我会这样跟别人说：‘您知道为了这件事，我付出了很多很多的努力。而且您的帮助对我来说也是非常重要的，您可能不知道您现在的选择将会决定我们这件事情的成败。如果您能够施以援手，这份恩情我是永远都不会忘记的。’ 我的感觉是，要想获得别人的帮助，首先得学会‘亮肌肉’。 我不用再跟他说：‘我遇到了一个困难，需要你的帮助。’我可以这么对他说：‘我这里有一个不错的机会，对我们双方都有好处，你要不要试一试？’ 只要是手心朝上向别人索取，不管怎么伪装你都优雅不起来。只有把单向的索取变成双向受益的共赢，这件事才能更加体面。 这个用来弥补对方因为帮你而付出的东西，我把它叫作“兑付型产品”。它可以是实物，可以是信息，也可以是服务。只要用来弥补对方因为帮你而做出的付出，就可以叫作“兑付型产品”。 我们来总结一下展示自己的兑付型产品的三个关键：第一，抢占先机，在事情没开始前，就把兑付型产品拿出来；第二，要具体，这个兑付型产品到底是什么一定要说清楚；第三，要可被量化，除了要说明兑付型产品是什么还要准确说出数量。 首先，你的价值取决于你所处的通道。如果你所处的是一个上升的通道，那你的价值也会跟着不断攀升；如果你所处的是一个下行的通道，那你的价值就会不断贬值。其次，你的价值取决于对方的需求。你的价值符合对方需求时，你就是一个有价值的人。如果对方没有这种需求，你的价值在对方看来也许一文不值。 不管是工作还是创业，都会提前弄明白自己将要进入的这个行业到底是处于上行期还是下行期。 弄明白这个关于价值的问题的关键所在：不光能帮你选择一个事半功倍的领域，还能解决怀才不遇的问题。 思考感悟 人与人之间的关系主要在“情感”和“价值”。 如何和一个陌生人建立深厚的友谊？ 第二章：品牌管理能力思维导图 从受欢迎到被需要第二章 核心观点 品牌有本领 给人成事的感觉 一个好的故事 好的形象，符合大众心中所想，甚至超越 一个好的签名，让别人记住你。 语句摘录 肯努力是一件好事，但是如果找不对方向，就会变成一场灾难。 个人品牌最重要的是状态，状态决定了你在他人资源列表当中的位置。从这点来说，再没有比奋斗者姿态更好的个人品牌了。 学会高情商的品牌思维后，一定要学会给你的社交做减法，减少在无效社交上花费的时间，把主要的时间用来做自我精进，把“奋斗者”作为你个人品牌的标签。 大家都相信他们能成事。做别人眼里那个能成事的人，这是我对修炼高情商的小伙伴的要求。 具有较高成就需要的人，在现实中的表现看起来才能更像是一个能够成大事的人。 这些人身上具有三种共同特质：1．心里永远有一个能逼出自己潜能的目标 2．明白只有自己能够成就自我 3．相对于付出，更看重结果 让结果说话。从经济学的角度来说就是，他们不会因为那些已经付出的沉没成本而痛苦纠结。从哲学角度来说，他们不会为打翻的牛奶而哭泣。 故事没有对错之分。只要能合乎逻辑，能够自圆其说，就是一个完整的故事。 到你的故事中充满积极、奋进的力量，这时你就是一个具有超高“成就需求”的人了，这才是一个奋斗者应该有的姿态。 “颜值”并不一定很重要，但是你的形体绝对很重要。 不要说经济紧张，不要说没有时间，这都是阻碍你奋斗的借口。 为形象管理所做的付出不是消费，不是享受，而是投资，是迈向成功的重要一环。有条件要做，没有条件就要创造条件去做。 人和衣服有两种关系：一种是衣服能提升人的气质，另一种是衣服的品质要靠人的气质来烘托。 哪怕条件再艰苦也要保证有一个能挂衣服的地方。 思考感悟第三章：怎么做才能让自己变的“值钱”思维导图 从受欢迎到被需要第三章 核心观点 利他思维产生链接 想成为什么人就跟什么人站到一起 成为想成为的那类人就变的值钱了 语句摘录 学会的最高标准是会教。 不管面对什么样的问题，不要着急动手，先想想这是个什么问题，是认知上的还是实操上的。如果是认知上的问题，这就需要你捅破那层窗户纸；如果是实操上的问题，那么你需要的就是一个工具。 什么是利他思维？ 就是在考虑问题的时候，站在他人利益的角度，以维护和满足他人的需求为出发点。这 我把完成这些事情所需要的时间和精力叫作无差别资源，也就是说这些事情由他去办或者由你去办，再或者由别人来办，产生的效果都是一样的。只要付出时间和精力就好，至于是谁来付出，产生的结果没有本质上的区别。 你越是担心什么就越会发生什么。 就是做事情像射击打靶一样，瞄准目标直接开枪。 破局的方法。 1．直接询问／用心观察 那些把事情办得很漂亮的人从来都不会直接开口询问，而是用心观察，从细节看出端倪，答案就在自己心中 2．只盯着目标本身／关心他所关心的一切 能够把目光从目标本身发散开来，覆盖到目标所覆盖的一切。 3．如果你能……／如果你需要的话…… 这话语当中满满的交换意味会让对方觉得受到了威胁，这就注定了接下来事情的走向不会向好的方向发展。 我最近刚好在做……有一些富裕的……这个对……来说挺有好处的，您看看身边认识的人当中有没有需要的。如果您需要的话……不然浪费了挺可惜的。 成功学之父吉米·罗恩说过一句话：“你就是和你最常来往的五个人的平均值。” 还有一句话叫“再穷也要站在富人堆里” “富人”是指那些资历雄厚、资源强大的牛人，他们是未来有可能为你提供助力的贵人。 人脉不是角色，人脉的本质是资源，是可以帮你解决问题的资源。 而资源的定义是什么？是人，是机会，是财富，是信息。用高情商积累人脉，是为了让人脉为你所用，让你能够从中获取资源，提升人生效率，实现人生目标。 就是指像项链上那根把珍珠穿在一起的绳子一样，用自己的圈层把资历和资源优于自己的人连接在一起，使自己拥有跟他们一样的身价。 绳律的核心并不是圈层也不是串联，而是我们在温图尔的故事中所看到的“利他”。 站在富人堆里的正确方式是主动为他们提供帮助。 尽量做到以下三个关键：首先，斜杠一下。其次，不断精进。最后，穿针引线。 利他思维做这件事，就像上文所述，把单纯请人帮忙这件事变成双赢或者多赢。 绳律，付出是一种心态，利他是一个角度，能助人是一种能力，三根支柱缺一不可。第三步：主场转换，把主动权交给对方；第四步：麻烦一下别人，让感情在相互帮助中升温 这种强关系，可以按照以下几步来建立：第一步：给对方足够的安全感；转化陌生人脉的第一步，就是要化解这种不信任感。第二步：热情，但是要有分寸 要想把握好分寸，就要善用微笑的表情、赞美的语言，保持自信、放松的对话状态，不要把对方当成陌生人，而要像平常和朋友聊天一样，慢慢地，对方就会接收到这一点，和你一样放松下来。 千万不要给别人添麻烦。不过，在修炼高情商的道路上，不仅不要害怕给别人添麻烦，而且在某种意义上，人情债绝对称得上是“关系神器”。 俗话说得好：只有相互欠着的两个人才会念念不忘。 亲近关系就在这个互相帮助、互相麻烦的过程中慢慢形成了。 你可以通过为自己和对方打上同样的标签，把对方迅速变成“自己人”。 人脉饥渴症其实并不是人脉真的不够，而是你感觉不够。 就是“10/20/150法则”和年度人脉关系管理系统。学会了这两个方法，你就不会轻易陷入“明明身边有大把的资源，却总因为资源太少而焦虑”的困境。 10人管理法则，这10个人是你的至亲至爱，他们是永远不会跟你翻脸的人。 20人管理法则，这20人跟你今年要实现的主要目标相关。 150人管理法则。我们每年都会认识很多人，但不是所有人都要成为你的朋友。150人是20人的候补。 六度人脉关系管理系统是根据年度目标建立的，它属于未来你要实现目标的间接性实现方式。 标记对象时你可以留意两个范畴。第一个范畴是对方个人的基本情况，如生日、喜好等，这里面有五个具体的标记点。1．你跟对方是什么关系。2．对方的生日，这里要记得做特殊标注。3．对方的父母和子女的情况，他的父母和子女分别是谁。4．喜好问题，即对方真正爱好什么。5．对对方来说非常重要的日子。 思考感悟 想成为什么人就去跟他们产生链接，哪怕自己的付出没有回报也要竭尽全力去产生链接。 能帮助别人获利，那么你们的关系也就开始建立了，有了人情就有了关系。 模板思维导图核心观点语句摘录思考感悟 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://lywlefan.github.io/tags/读书笔记/"},{"name":"2019年读书","slug":"2019年读书","permalink":"https://lywlefan.github.io/tags/2019年读书/"},{"name":"7月读书","slug":"7月读书","permalink":"https://lywlefan.github.io/tags/7月读书/"}]},{"title":"你值不值钱由你说了算","date":"2019-07-29T16:00:00.000Z","path":"2019/07/30/读书/归档/2019/7月/从受欢迎到被需要-张萌/你值不值钱由你说了算/","text":"从受欢迎到被需要从受欢迎到被需要思维导图 第一章：从受欢迎到被需要，高情商人的跃迁术思维导图 从受欢迎到被需要第一章 核心观点 价值交换，前提是要挖掘出自己的价值 让人舒服的表达，展示自己的能力、诚意、决心，同时要放低姿态，突出别人重要性，取得共赢的局面。 答应别人的价值要明确具体。 找对通道。 语句摘录 禅宗有句话，大意是“道不可道，然近道之道不可不道”，道理与此大致相同。高情商很难，难在那些不可言说的分寸拿捏。 高情商是可以“变现”的，是所有奋斗者不可或缺的重要助力。 高情商者会让别人感到很舒服，会受到别人欢迎。但并不是所有让别人感觉舒适的人都是高情商者，还可能是“取悦症”患者。让别人感觉舒适，并不等于一定会得到别人的帮助。如果别人乐意帮你，你很幸运，那是情分；反之，也无可厚非。 高情商者会让别人感觉很舒适，这点很重要。但是比这更重要的是用好自己的价值，促进高情商“变现”。 在人与人交往的过程中，不管建立什么样的关系，都不外乎两个因素：一是情感因素。二是价值因素。 我是谁，我能提供什么，我需要什么。 当面对一个陌生人的时候，能够快速运用三点定位法对他进行社交价值定位。 我觉得请人帮忙，最重要的是诚恳，要能放得下面子，放低自己的姿态。这样才能让别人看到你的诚意，他们才会帮助你。对了，还要突出别人帮助你的重要性，还有你对成功的渴望。我想我会这样跟别人说：‘您知道为了这件事，我付出了很多很多的努力。而且您的帮助对我来说也是非常重要的，您可能不知道您现在的选择将会决定我们这件事情的成败。如果您能够施以援手，这份恩情我是永远都不会忘记的。’ 我的感觉是，要想获得别人的帮助，首先得学会‘亮肌肉’。 我不用再跟他说：‘我遇到了一个困难，需要你的帮助。’我可以这么对他说：‘我这里有一个不错的机会，对我们双方都有好处，你要不要试一试？’ 只要是手心朝上向别人索取，不管怎么伪装你都优雅不起来。只有把单向的索取变成双向受益的共赢，这件事才能更加体面。 这个用来弥补对方因为帮你而付出的东西，我把它叫作“兑付型产品”。它可以是实物，可以是信息，也可以是服务。只要用来弥补对方因为帮你而做出的付出，就可以叫作“兑付型产品”。 我们来总结一下展示自己的兑付型产品的三个关键：第一，抢占先机，在事情没开始前，就把兑付型产品拿出来；第二，要具体，这个兑付型产品到底是什么一定要说清楚；第三，要可被量化，除了要说明兑付型产品是什么还要准确说出数量。 首先，你的价值取决于你所处的通道。如果你所处的是一个上升的通道，那你的价值也会跟着不断攀升；如果你所处的是一个下行的通道，那你的价值就会不断贬值。其次，你的价值取决于对方的需求。你的价值符合对方需求时，你就是一个有价值的人。如果对方没有这种需求，你的价值在对方看来也许一文不值。 不管是工作还是创业，都会提前弄明白自己将要进入的这个行业到底是处于上行期还是下行期。 弄明白这个关于价值的问题的关键所在：不光能帮你选择一个事半功倍的领域，还能解决怀才不遇的问题。 思考感悟 人与人之间的关系主要在“情感”和“价值”。 如何和一个陌生人建立深厚的友谊？ 第二章：品牌管理能力思维导图 从受欢迎到被需要第二章 核心观点 品牌有本领 给人成事的感觉 一个好的故事 好的形象，符合大众心中所想，甚至超越 一个好的签名，让别人记住你。 语句摘录 肯努力是一件好事，但是如果找不对方向，就会变成一场灾难。 个人品牌最重要的是状态，状态决定了你在他人资源列表当中的位置。从这点来说，再没有比奋斗者姿态更好的个人品牌了。 学会高情商的品牌思维后，一定要学会给你的社交做减法，减少在无效社交上花费的时间，把主要的时间用来做自我精进，把“奋斗者”作为你个人品牌的标签。 大家都相信他们能成事。做别人眼里那个能成事的人，这是我对修炼高情商的小伙伴的要求。 具有较高成就需要的人，在现实中的表现看起来才能更像是一个能够成大事的人。 这些人身上具有三种共同特质：1．心里永远有一个能逼出自己潜能的目标 2．明白只有自己能够成就自我 3．相对于付出，更看重结果 让结果说话。从经济学的角度来说就是，他们不会因为那些已经付出的沉没成本而痛苦纠结。从哲学角度来说，他们不会为打翻的牛奶而哭泣。 故事没有对错之分。只要能合乎逻辑，能够自圆其说，就是一个完整的故事。 到你的故事中充满积极、奋进的力量，这时你就是一个具有超高“成就需求”的人了，这才是一个奋斗者应该有的姿态。 “颜值”并不一定很重要，但是你的形体绝对很重要。 不要说经济紧张，不要说没有时间，这都是阻碍你奋斗的借口。 为形象管理所做的付出不是消费，不是享受，而是投资，是迈向成功的重要一环。有条件要做，没有条件就要创造条件去做。 人和衣服有两种关系：一种是衣服能提升人的气质，另一种是衣服的品质要靠人的气质来烘托。 哪怕条件再艰苦也要保证有一个能挂衣服的地方。 思考感悟第三章：怎么做才能让自己变的“值钱”思维导图 从受欢迎到被需要第三章 核心观点 利他思维产生链接 想成为什么人就跟什么人站到一起 成为想成为的那类人就变的值钱了 语句摘录 学会的最高标准是会教。 不管面对什么样的问题，不要着急动手，先想想这是个什么问题，是认知上的还是实操上的。如果是认知上的问题，这就需要你捅破那层窗户纸；如果是实操上的问题，那么你需要的就是一个工具。 什么是利他思维？ 就是在考虑问题的时候，站在他人利益的角度，以维护和满足他人的需求为出发点。这 我把完成这些事情所需要的时间和精力叫作无差别资源，也就是说这些事情由他去办或者由你去办，再或者由别人来办，产生的效果都是一样的。只要付出时间和精力就好，至于是谁来付出，产生的结果没有本质上的区别。 你越是担心什么就越会发生什么。 就是做事情像射击打靶一样，瞄准目标直接开枪。 破局的方法。 1．直接询问／用心观察 那些把事情办得很漂亮的人从来都不会直接开口询问，而是用心观察，从细节看出端倪，答案就在自己心中 2．只盯着目标本身／关心他所关心的一切 能够把目光从目标本身发散开来，覆盖到目标所覆盖的一切。 3．如果你能……／如果你需要的话…… 这话语当中满满的交换意味会让对方觉得受到了威胁，这就注定了接下来事情的走向不会向好的方向发展。 我最近刚好在做……有一些富裕的……这个对……来说挺有好处的，您看看身边认识的人当中有没有需要的。如果您需要的话……不然浪费了挺可惜的。 成功学之父吉米·罗恩说过一句话：“你就是和你最常来往的五个人的平均值。” 还有一句话叫“再穷也要站在富人堆里” “富人”是指那些资历雄厚、资源强大的牛人，他们是未来有可能为你提供助力的贵人。 人脉不是角色，人脉的本质是资源，是可以帮你解决问题的资源。 而资源的定义是什么？是人，是机会，是财富，是信息。用高情商积累人脉，是为了让人脉为你所用，让你能够从中获取资源，提升人生效率，实现人生目标。 就是指像项链上那根把珍珠穿在一起的绳子一样，用自己的圈层把资历和资源优于自己的人连接在一起，使自己拥有跟他们一样的身价。 绳律的核心并不是圈层也不是串联，而是我们在温图尔的故事中所看到的“利他”。 站在富人堆里的正确方式是主动为他们提供帮助。 尽量做到以下三个关键：首先，斜杠一下。其次，不断精进。最后，穿针引线。 利他思维做这件事，就像上文所述，把单纯请人帮忙这件事变成双赢或者多赢。 绳律，付出是一种心态，利他是一个角度，能助人是一种能力，三根支柱缺一不可。第三步：主场转换，把主动权交给对方；第四步：麻烦一下别人，让感情在相互帮助中升温 这种强关系，可以按照以下几步来建立：第一步：给对方足够的安全感；转化陌生人脉的第一步，就是要化解这种不信任感。第二步：热情，但是要有分寸 要想把握好分寸，就要善用微笑的表情、赞美的语言，保持自信、放松的对话状态，不要把对方当成陌生人，而要像平常和朋友聊天一样，慢慢地，对方就会接收到这一点，和你一样放松下来。 千万不要给别人添麻烦。不过，在修炼高情商的道路上，不仅不要害怕给别人添麻烦，而且在某种意义上，人情债绝对称得上是“关系神器”。 俗话说得好：只有相互欠着的两个人才会念念不忘。 亲近关系就在这个互相帮助、互相麻烦的过程中慢慢形成了。 你可以通过为自己和对方打上同样的标签，把对方迅速变成“自己人”。 人脉饥渴症其实并不是人脉真的不够，而是你感觉不够。 就是“10/20/150法则”和年度人脉关系管理系统。学会了这两个方法，你就不会轻易陷入“明明身边有大把的资源，却总因为资源太少而焦虑”的困境。 10人管理法则，这10个人是你的至亲至爱，他们是永远不会跟你翻脸的人。 20人管理法则，这20人跟你今年要实现的主要目标相关。 150人管理法则。我们每年都会认识很多人，但不是所有人都要成为你的朋友。150人是20人的候补。 六度人脉关系管理系统是根据年度目标建立的，它属于未来你要实现目标的间接性实现方式。 标记对象时你可以留意两个范畴。第一个范畴是对方个人的基本情况，如生日、喜好等，这里面有五个具体的标记点。1．你跟对方是什么关系。2．对方的生日，这里要记得做特殊标注。3．对方的父母和子女的情况，他的父母和子女分别是谁。4．喜好问题，即对方真正爱好什么。5．对对方来说非常重要的日子。 思考感悟 想成为什么人就去跟他们产生链接，哪怕自己的付出没有回报也要竭尽全力去产生链接。 能帮助别人获利，那么你们的关系也就开始建立了，有了人情就有了关系。 模板思维导图核心观点语句摘录思考感悟 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://lywlefan.github.io/tags/读书笔记/"},{"name":"2019年读书","slug":"2019年读书","permalink":"https://lywlefan.github.io/tags/2019年读书/"},{"name":"7月读书","slug":"7月读书","permalink":"https://lywlefan.github.io/tags/7月读书/"}]},{"title":"从受欢迎到被需要-萌姐","date":"2019-07-25T16:00:00.000Z","path":"2019/07/26/读书/归档/2019/7月/从受欢迎到被需要-萌姐/","text":"从受欢迎到被需要从受欢迎到被需要思维导图 第一章：从受欢迎到被需要，高情商人的跃迁术思维导图 从受欢迎到被需要第一章 核心观点 价值交换，前提是要挖掘出自己的价值 让人舒服的表达，展示自己的能力、诚意、决心，同时要放低姿态，突出别人重要性，取得共赢的局面。 答应别人的价值要明确具体。 找对通道。 语句摘录 禅宗有句话，大意是“道不可道，然近道之道不可不道”，道理与此大致相同。高情商很难，难在那些不可言说的分寸拿捏。 高情商是可以“变现”的，是所有奋斗者不可或缺的重要助力。 高情商者会让别人感到很舒服，会受到别人欢迎。但并不是所有让别人感觉舒适的人都是高情商者，还可能是“取悦症”患者。让别人感觉舒适，并不等于一定会得到别人的帮助。如果别人乐意帮你，你很幸运，那是情分；反之，也无可厚非。 高情商者会让别人感觉很舒适，这点很重要。但是比这更重要的是用好自己的价值，促进高情商“变现”。 在人与人交往的过程中，不管建立什么样的关系，都不外乎两个因素：一是情感因素。二是价值因素。 我是谁，我能提供什么，我需要什么。 当面对一个陌生人的时候，能够快速运用三点定位法对他进行社交价值定位。 我觉得请人帮忙，最重要的是诚恳，要能放得下面子，放低自己的姿态。这样才能让别人看到你的诚意，他们才会帮助你。对了，还要突出别人帮助你的重要性，还有你对成功的渴望。我想我会这样跟别人说：‘您知道为了这件事，我付出了很多很多的努力。而且您的帮助对我来说也是非常重要的，您可能不知道您现在的选择将会决定我们这件事情的成败。如果您能够施以援手，这份恩情我是永远都不会忘记的。’ 我的感觉是，要想获得别人的帮助，首先得学会‘亮肌肉’。 我不用再跟他说：‘我遇到了一个困难，需要你的帮助。’我可以这么对他说：‘我这里有一个不错的机会，对我们双方都有好处，你要不要试一试？’ 只要是手心朝上向别人索取，不管怎么伪装你都优雅不起来。只有把单向的索取变成双向受益的共赢，这件事才能更加体面。 这个用来弥补对方因为帮你而付出的东西，我把它叫作“兑付型产品”。它可以是实物，可以是信息，也可以是服务。只要用来弥补对方因为帮你而做出的付出，就可以叫作“兑付型产品”。 我们来总结一下展示自己的兑付型产品的三个关键：第一，抢占先机，在事情没开始前，就把兑付型产品拿出来；第二，要具体，这个兑付型产品到底是什么一定要说清楚；第三，要可被量化，除了要说明兑付型产品是什么还要准确说出数量。 首先，你的价值取决于你所处的通道。如果你所处的是一个上升的通道，那你的价值也会跟着不断攀升；如果你所处的是一个下行的通道，那你的价值就会不断贬值。其次，你的价值取决于对方的需求。你的价值符合对方需求时，你就是一个有价值的人。如果对方没有这种需求，你的价值在对方看来也许一文不值。 不管是工作还是创业，都会提前弄明白自己将要进入的这个行业到底是处于上行期还是下行期。 弄明白这个关于价值的问题的关键所在：不光能帮你选择一个事半功倍的领域，还能解决怀才不遇的问题。 思考感悟 人与人之间的关系主要在“情感”和“价值”。 如何和一个陌生人建立深厚的友谊？ 第二章：品牌管理能力思维导图 从受欢迎到被需要第二章 核心观点 品牌有本领 给人成事的感觉 一个好的故事 好的形象，符合大众心中所想，甚至超越 一个好的签名，让别人记住你。 语句摘录 肯努力是一件好事，但是如果找不对方向，就会变成一场灾难。 个人品牌最重要的是状态，状态决定了你在他人资源列表当中的位置。从这点来说，再没有比奋斗者姿态更好的个人品牌了。 学会高情商的品牌思维后，一定要学会给你的社交做减法，减少在无效社交上花费的时间，把主要的时间用来做自我精进，把“奋斗者”作为你个人品牌的标签。 大家都相信他们能成事。做别人眼里那个能成事的人，这是我对修炼高情商的小伙伴的要求。 具有较高成就需要的人，在现实中的表现看起来才能更像是一个能够成大事的人。 这些人身上具有三种共同特质：1．心里永远有一个能逼出自己潜能的目标 2．明白只有自己能够成就自我 3．相对于付出，更看重结果 让结果说话。从经济学的角度来说就是，他们不会因为那些已经付出的沉没成本而痛苦纠结。从哲学角度来说，他们不会为打翻的牛奶而哭泣。 故事没有对错之分。只要能合乎逻辑，能够自圆其说，就是一个完整的故事。 到你的故事中充满积极、奋进的力量，这时你就是一个具有超高“成就需求”的人了，这才是一个奋斗者应该有的姿态。 “颜值”并不一定很重要，但是你的形体绝对很重要。 不要说经济紧张，不要说没有时间，这都是阻碍你奋斗的借口。 为形象管理所做的付出不是消费，不是享受，而是投资，是迈向成功的重要一环。有条件要做，没有条件就要创造条件去做。 人和衣服有两种关系：一种是衣服能提升人的气质，另一种是衣服的品质要靠人的气质来烘托。 哪怕条件再艰苦也要保证有一个能挂衣服的地方。 思考感悟第三章：怎么做才能让自己变的“值钱”思维导图 从受欢迎到被需要第三章 核心观点 利他思维产生链接 想成为什么人就跟什么人站到一起 成为想成为的那类人就变的值钱了 语句摘录 学会的最高标准是会教。 不管面对什么样的问题，不要着急动手，先想想这是个什么问题，是认知上的还是实操上的。如果是认知上的问题，这就需要你捅破那层窗户纸；如果是实操上的问题，那么你需要的就是一个工具。 什么是利他思维？ 就是在考虑问题的时候，站在他人利益的角度，以维护和满足他人的需求为出发点。这 我把完成这些事情所需要的时间和精力叫作无差别资源，也就是说这些事情由他去办或者由你去办，再或者由别人来办，产生的效果都是一样的。只要付出时间和精力就好，至于是谁来付出，产生的结果没有本质上的区别。 你越是担心什么就越会发生什么。 就是做事情像射击打靶一样，瞄准目标直接开枪。 破局的方法。 1．直接询问／用心观察 那些把事情办得很漂亮的人从来都不会直接开口询问，而是用心观察，从细节看出端倪，答案就在自己心中 2．只盯着目标本身／关心他所关心的一切 能够把目光从目标本身发散开来，覆盖到目标所覆盖的一切。 3．如果你能……／如果你需要的话…… 这话语当中满满的交换意味会让对方觉得受到了威胁，这就注定了接下来事情的走向不会向好的方向发展。 我最近刚好在做……有一些富裕的……这个对……来说挺有好处的，您看看身边认识的人当中有没有需要的。如果您需要的话……不然浪费了挺可惜的。 成功学之父吉米·罗恩说过一句话：“你就是和你最常来往的五个人的平均值。” 还有一句话叫“再穷也要站在富人堆里” “富人”是指那些资历雄厚、资源强大的牛人，他们是未来有可能为你提供助力的贵人。 人脉不是角色，人脉的本质是资源，是可以帮你解决问题的资源。 而资源的定义是什么？是人，是机会，是财富，是信息。用高情商积累人脉，是为了让人脉为你所用，让你能够从中获取资源，提升人生效率，实现人生目标。 就是指像项链上那根把珍珠穿在一起的绳子一样，用自己的圈层把资历和资源优于自己的人连接在一起，使自己拥有跟他们一样的身价。 绳律的核心并不是圈层也不是串联，而是我们在温图尔的故事中所看到的“利他”。 站在富人堆里的正确方式是主动为他们提供帮助。 尽量做到以下三个关键：首先，斜杠一下。其次，不断精进。最后，穿针引线。 利他思维做这件事，就像上文所述，把单纯请人帮忙这件事变成双赢或者多赢。 绳律，付出是一种心态，利他是一个角度，能助人是一种能力，三根支柱缺一不可。第三步：主场转换，把主动权交给对方；第四步：麻烦一下别人，让感情在相互帮助中升温 这种强关系，可以按照以下几步来建立：第一步：给对方足够的安全感；转化陌生人脉的第一步，就是要化解这种不信任感。第二步：热情，但是要有分寸 要想把握好分寸，就要善用微笑的表情、赞美的语言，保持自信、放松的对话状态，不要把对方当成陌生人，而要像平常和朋友聊天一样，慢慢地，对方就会接收到这一点，和你一样放松下来。 千万不要给别人添麻烦。不过，在修炼高情商的道路上，不仅不要害怕给别人添麻烦，而且在某种意义上，人情债绝对称得上是“关系神器”。 俗话说得好：只有相互欠着的两个人才会念念不忘。 亲近关系就在这个互相帮助、互相麻烦的过程中慢慢形成了。 你可以通过为自己和对方打上同样的标签，把对方迅速变成“自己人”。 人脉饥渴症其实并不是人脉真的不够，而是你感觉不够。 就是“10/20/150法则”和年度人脉关系管理系统。学会了这两个方法，你就不会轻易陷入“明明身边有大把的资源，却总因为资源太少而焦虑”的困境。 10人管理法则，这10个人是你的至亲至爱，他们是永远不会跟你翻脸的人。 20人管理法则，这20人跟你今年要实现的主要目标相关。 150人管理法则。我们每年都会认识很多人，但不是所有人都要成为你的朋友。150人是20人的候补。 六度人脉关系管理系统是根据年度目标建立的，它属于未来你要实现目标的间接性实现方式。 标记对象时你可以留意两个范畴。第一个范畴是对方个人的基本情况，如生日、喜好等，这里面有五个具体的标记点。1．你跟对方是什么关系。2．对方的生日，这里要记得做特殊标注。3．对方的父母和子女的情况，他的父母和子女分别是谁。4．喜好问题，即对方真正爱好什么。5．对对方来说非常重要的日子。 思考感悟 想成为什么人就去跟他们产生链接，哪怕自己的付出没有回报也要竭尽全力去产生链接。 能帮助别人获利，那么你们的关系也就开始建立了，有了人情就有了关系。 模板思维导图核心观点语句摘录思考感悟 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://lywlefan.github.io/tags/读书笔记/"},{"name":"2019年读书","slug":"2019年读书","permalink":"https://lywlefan.github.io/tags/2019年读书/"},{"name":"7月读书","slug":"7月读书","permalink":"https://lywlefan.github.io/tags/7月读书/"}]},{"title":"MPP(大规模并行处理)简介","date":"2019-07-18T16:00:00.000Z","path":"2019/07/19/数据库/MBPP数据库/MPP(大规模并行处理)简介/","text":"&emsp;&emsp;实践一门技术的最好方式就是深入理解它的思想，然后造一个出来！ 1、 什么是MPP？MPP (Massively Parallel Processing)，即大规模并行处理，在数据库非共享集群中，每个节点都有独立的磁盘存储系统和内存系统，业务数据根据数据库模型和应用特点划分到各个节点上，每台数据节点通过专用网络或者商业通用网络互相连接，彼此协同计算，作为整体提供数据库服务。非共享数据库集群有完全的可伸缩性、高可用、高性能、优秀的性价比、资源共享等优势。 简单来说，MPP是将任务并行的分散到多个服务器和节点上，在每个节点上计算完成后，将各自部分的结果汇总在一起得到最终的结果(与Hadoop相似)。 2、MPP(大规模并行处理)架构 (MPP架构) 3、 MPP架构特征● 任务并行执行; ● 数据分布式存储(本地化); ● 分布式计算; ● 私有资源; ● 横向扩展; ● Shared Nothing架构。 4、 MPP服务器架构它由多个SMP服务器通过一定的节点互联网络进行连接，协同工作，完成相同的任务，从用户的角度来看是一个服务器系统。其基本特征是由多个SMP服务器(每个SMP服务器称节点)通过节点互联网络连接而成，每个节点只访问自己的本地资源(内存、存储等)，是一种完全无共享(Share Nothing)结构，因而扩展能力最好，理论上其扩展无限制。 5、MPPDBMPPDB是一款 Shared Nothing 架构的分布式并行结构化数据库集群，具备高性能、高可用、高扩展特性，可以为超大规模数据管理提供高性价比的通用计算平台，并广泛地用于支撑各类数据仓库系统、BI 系统和决策支持系统 6、MPPDB架构MPP 采用完全并行的MPP + Shared Nothing 的分布式扁平架构，这种架构中的每一个节点（node）都是独立的、自给的、节点之间对等，而且整个系统中不存在单点瓶颈，具有非常强的扩展性。 7、 MPPDB特征MPP 具备以下技术特征： 1) 低硬件成本：完全使用 x86 架构的 PC Server，不需要昂贵的 Unix 服务器和磁盘阵列； 2) 集群架构与部署：完全并行的 MPP + Shared Nothing 的分布式架构，采用 Non-Master 部署，节点对等的扁平结构； 3) 海量数据分布压缩存储：可处理 PB 级别以上的结构化数据，采用 hash分布、random 存储策略进行数据存储；同时采用先进的压缩算法，减少存储数据所需的空间，可以将所用空间减少 1~20 倍，并相应地提高 I/O 性能； 4) 数据加载高效性：基于策略的数据加载模式，集群整体加载速度可达2TB/h； 5) 高扩展、高可靠：支持集群节点的扩容和缩容，支持全量、增量的备份/恢复; 6) 高可用、易维护：数据通过副本提供冗余保护，自动故障探测和管理，自动同步元数据和业务数据。提供图形化工具，以简化管理员对数据库的管理工作； 7) 高并发：读写不互斥，支持数据的边加载边查询，单个节点并发能力大于 300 用户； 8) 行列混合存储：提供行列混合存储方案，从而提高了列存数据库特殊查询场景的查询响应耗时； 9) 标准化：支持SQL92 标准，支持 C API、ODBC、JDBC、ADO.NET 等接口规范。 8、 常见MPPDB● GREENPLUM(EMC) ● Asterdata(Teradata) ● Nettezza(IBM) ● Vertica(HP) ● GBase 8a MPP cluster(南大通用) 9、 MPPDB、Hadoop与传统数据库技术对比与适用场景MPPDB与Hadoop都是将运算分布到节点中独立运算后进行结果合并(分布式计算)，但由于依据的理论和采用的技术路线不同而有各自的优缺点和适用范围。两种技术以及传统数据库技术的对比如下： 综合而言，Hadoop和MPP两种技术的特定和适用场景为： ● Hadoop在处理非结构化和半结构化数据上具备优势，尤其适合海量数据批处理等应用要求。 ● MPP适合替代现有关系数据机构下的大数据处理，具有较高的效率。 MPP适合多维度数据自助分析、数据集市等；Hadoop适合海量数据存储查询、批量数据ETL、非机构化数据分析(日志分析、文本分析)等。 由上述对比可预见未来大数据存储与处理趋势：MPPDB+Hadoop混搭使用，用MPP处理PB级别的、高质量的结构化数据，同时为应用提供丰富的SQL和事物支持能力；用Hadoop实现半结构化、非结构化数据处理。这样可以同时满足结构化、半结构化和非结构化数据的高效处理需求。 【1】简书主页·share猿 【2】掘金主页·share猿 — 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"数据库","slug":"数据库","permalink":"https://lywlefan.github.io/tags/数据库/"},{"name":"MBPP","slug":"MBPP","permalink":"https://lywlefan.github.io/tags/MBPP/"}]},{"title":"理财书籍收集","date":"2019-07-17T16:00:00.000Z","path":"2019/07/18/读书/书单/理财书籍收集/理财书籍收集/","text":"多读书，多看报，少吃零食，少睡觉！ 理财书籍汇集未读 《谁动了我的奶酪》 《小狗钱钱》 《富爸爸，穷爸爸》，《财务自由之路》和《投资指南》 《一分钟百万富翁》 《怎样启迪你头脑中的金融意识》 《财源滚滚》 《钻石就在你家后院》 《我的百万富翁兄弟》 已读 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"读书","slug":"读书","permalink":"https://lywlefan.github.io/tags/读书/"},{"name":"收集","slug":"收集","permalink":"https://lywlefan.github.io/tags/收集/"}]},{"title":"财务词汇","date":"2019-07-10T16:00:00.000Z","path":"2019/07/11/词汇/财务/财务词汇/","text":"先有词汇量,然后再能好好说话,好好做事。 重要 不重要 理解 未理解 2019年7月份词汇重要理解词汇 资产 G:如何获得资产？a.加杠杆购买资产，产生源源不断的现金流b.花时间创造资产 负债 现值 是在给定的利率水平下，未来的资金折现到现在时刻的价值。 现金流 经营性现金流 投资性现金流 融资性现金流 资产负债表 损益表 所有者权益变动表 财务报表附注 审查报表 预算盈余 净现值法（NPV） 净现值 未来资金流现值与未来资金流出现值差额。 折现率 折现率是指将未来有限期预期收益折算成现值的比率。 内部收益率（IRR） 不重要理解词汇 直线法折旧 双倍余额递减法折旧（年折旧率=2÷预计的折旧年限×100％） 重要不理解词汇不重要不理解词汇 借款人 信贷人员 银行流水 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"词汇","slug":"词汇","permalink":"https://lywlefan.github.io/tags/词汇/"},{"name":"财务","slug":"财务","permalink":"https://lywlefan.github.io/tags/财务/"}]},{"title":"研发英文词汇收集","date":"2019-07-10T16:00:00.000Z","path":"2019/07/11/词汇/软件/研发英文词汇收集/","text":"先有词汇量,然后再能好好说话,好好做事。 java相关词汇框架存储关系型非关系型newSqlredis相关词汇 内存数据库:in-memory data structure store 消息代理:message broker 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"词汇","slug":"词汇","permalink":"https://lywlefan.github.io/tags/词汇/"},{"name":"专业英文词汇","slug":"专业英文词汇","permalink":"https://lywlefan.github.io/tags/专业英文词汇/"}]},{"title":"软件中未知词汇收集","date":"2019-07-10T16:00:00.000Z","path":"2019/07/11/词汇/软件/软件中未知词汇收集/","text":"先有词汇量,然后再能好好说话,好好做事。 2019年词汇7月词汇二方库 一方库：本工程中的各模块的相互依赖 二方库：公司内部的依赖库，一般指公司内部的其他项目发布的jar包 三方库：公司之外的开源库， 比如apache、ibm、google等发布的依赖 mock数据在前后端分离开发过程中，后端为前端请求制造的模拟数据。常见制造模拟数据的方法有如下几种： easymock Mock.js server-mock SOA面向服务架构（Service-Oriented Architecture，SOA）又称“面向服务的体系结构”，是Gartner于2O世纪9O年代中期提出的面向服务架构的概念。 打tag说白了就是给你的项目打个标签，立个里程碑，这样就可以去方便的回溯每个版本的代码了。如何打tag，命令如下： 123456# 打tag -a 后面是tag名称 -m 后面是注释（这里我们可以写我们这个版本做了什么？）git tag -a v3.2.1 -m &apos;线上版本&apos;# 将标签提交到远程仓库git push origin v3.2.1 qps每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。 吞吐量 吞吐量是指系统在单位时间内处理请求的数量。 并发用户数 并发用户数是指系统可以同时承载的正常使用系统功能的用户的数量。 IO线程VisualVMVisualVM是JDK自带的一款全能型性能监控和故障分析工具,包括对CPU使用、JVM堆内存消耗、线程、类加载的实时监控,内存dump文件分析,垃圾回收运行情况的可视化分析等,对故障排查和性能调优很有帮助。 包装类包装类（Wrapper Class）： Java是一个面向对象的编程语言，但是Java中的八种基本数据类型却是不面向对象的，为了使用方便和解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八种基本数据类型对应的类统称为包装类(Wrapper Class)，包装类均位于java.lang包。 栈栈就像枪的梭子一样,先进后出. 8月词汇TDDTDD是测试驱动开发（Test-Driven Development）的英文简称，是敏捷开发中的一项核心实践和技术，也是一种设计方法论。 时间复杂度一个算法中的所有语句执行次数之和称为语句频度或时间频度,记为T(n)。 空间复杂度如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1) 哑结点说白了就是无用的节点,一般处在链表的头部.是一个被人为创建的节点，虽然其内容为NULL，但是它在堆中有占有一定的空间。哑节点的使用可以避免边界问题的处理，达到简化代码与减少代码出错可能性的目的。 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"第一次听说的词汇","slug":"第一次听说的词汇","permalink":"https://lywlefan.github.io/tags/第一次听说的词汇/"}]},{"title":"如果你不愿自己去学习和提升，生活会慢慢教会你！","date":"2019-07-10T16:00:00.000Z","path":"2019/07/11/思考/2019/7/如果你不愿自己去学习和提升，生活会慢慢教会你！/","text":"在实践中思考感悟,在思考感悟后实践,一切伟大源于不断的思考和实践。 开篇语在这个偌大的世界里，我们的家教和我们的环境决定了我们的认知和格局,家庭出身我们没得选,更多的应该是感恩和爱,上天赐予我们亲爱的父母亲,他们默默无私不求回报,每每想起总让人热泪盈眶,这是世界上最伟大的爱,没有之一。 但是,成年后的我们的思维格局由我们自己决定,你愿不愿意正视自己,正视以前那个傻傻的自己,洗礼自己的一些思想,革新骨子里的各种观念。我相信,你会选择去改变,因为你有梦想。 上周听了一位财商老师的课,在课上有位50多岁的大叔问了怎么每年赚100万的问题。 老师说为什么要转一百万? 大叔说,我还有梦想,我现在每天摆地摊,我起早贪黑,我不怕苦不怕累。 老师沉默了许久,然后说我建议你不要有梦想,人生是短暂的,大半辈子已经过去了,你开开心心陪家人过完余生也是一种莫大的幸福,梦想这件事很痛,我怕你承受不起。 听到这里,我内心就像是被猛击了一下,趁着年轻放手去做自己喜欢的事,去追逐自己的梦想,做历练自己,有些事年轻的时候不学会,老了,没有力气了,生活会慢慢教你,会让你痛不欲生,因为这就是你年轻时的选择! 是不是每次都说自己没钱,是不是想尽办法去赚钱到头却发现花的总比赚的多一次无意的刷快手,听了零首付买房,花了298,抱着学习的态度去听了这堂财商课。虽然演讲的老师讲的有点浮夸,但他说的道理,说的思想却极大的震撼了我的内心,让我明白一个人穷不是没钱而是思想上的贫穷,见识上的贫穷,观念上的贫穷,知识上的贫穷。 时代的发展会把机会摆在每个人的面前,谁能抓住这些机会?谁能牢牢的握住它?谁能把这个机会发挥出巨大的价值?这跟什么有关系? 究其原因,我个人认为把握机会的前提是能看到机会,能理解这种机会,没有这种意识和格局,别人说你都听不懂,可能还会说人家是骗子,若干年过去后却发现自己是傻逼。 每一次革新中,都有巨大的机会存在,人口红利必然会导致房屋需求增加,城镇化发展会不断加速,谁能看到,在合适的时机把握机会,时代会把你推向浪潮之巅,抓不住又是为什么??? 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"思考","slug":"思考","permalink":"https://lywlefan.github.io/tags/思考/"},{"name":"2019年","slug":"2019年","permalink":"https://lywlefan.github.io/tags/2019年/"},{"name":"7月","slug":"7月","permalink":"https://lywlefan.github.io/tags/7月/"},{"name":"生活","slug":"生活","permalink":"https://lywlefan.github.io/tags/生活/"}]},{"title":"02.Java内存模型：看Java如何解决可见性和有序性问题","date":"2019-07-02T16:00:00.000Z","path":"2019/07/03/高并发/书籍/java并发编程实战-王宝令/02.Java内存模型：看Java如何解决可见性和有序性问题 /","text":"阅读笔记 java内存模型 volatile Happens-Before规则 什么是java内存模型？java内存模型说的直白一点就是java程序使用内存的规范，让java语言在各种系统和平台中能保持数据的一致性。 Happens-Before规则（6项规则）前一个操作对后一个操作是可见的。假如有一个公有变量，a方法先引用然后b方法再引用，那么我们称a方法的操作对b方法可见。 程序顺序性规则假如有一个公有变量，a方法先引用然后b方法再引用，那么我们称a方法的操作对b方法可见。 volatile变量规则volatile变量的写操作对volatile变量读操作可见。说白了读之前，我要知道是谁写的，不然我不读。 传递性如果A对B可见，B对C可见，那么A对C可见。 管程中锁的规则管程是一种通用的同步原语，在java中指的是synchronized,synchronized是java里对管程的实现。 对变量进行加锁，执行完再继续。 线程smart()规则它是指主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作。 G:说白了就是主线程要优于子线程。 线程join()规则关键词解析volatile这个关键词可以禁用cpu缓存。禁用了cpu缓存，那么我们的变量只能从内存中进行读写。 Happens-Before规则Happens-Before规则说白了就是定义java内存模型的一种约束或者规则。 推荐书单 -《Java并发编程实战》作者阵容可谓大师云集，也包括Doug Lea -《Java并发编程的艺术》讲解并发包内部实现原理，能读明白，内功大增 -《图解Java多线程设计模式》并发编程设计模式方面的经典书籍 -《操作系统：精髓与设计原理》经典操作系统教材 http://ifeve.com 国内专业并发编程网站 http://www.cs.umd.edu/~pugh/java/memoryModel/ 很多并发编程的早期资料都在这里 参考文档 【1】简书主页·share猿 【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"并发","slug":"并发","permalink":"https://lywlefan.github.io/tags/并发/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://lywlefan.github.io/tags/读书笔记/"},{"name":"java并发编程实战-王宝令","slug":"java并发编程实战-王宝令","permalink":"https://lywlefan.github.io/tags/java并发编程实战-王宝令/"}]},{"title":"学习攻略.如何才能学好并发编程？","date":"2019-07-01T16:00:00.000Z","path":"2019/07/02/高并发/书籍/java并发编程实战-王宝令/学习攻略.如何才能学好并发编程？/","text":"阅读笔记并发是一门独立学科也是一门综合科学，从两个方面突破并发编程： 跳出来，看全景 钻进去，看本质 跳出来，看全景学习最忌讳的就是“盲人摸象”，只看到局部，没有全局。从单一知识点跳出来，高屋建瓴看并发编程，首要之事就是建立一张全景图。 并发核心问题分工像做项目的分工一样，不同的工作分给不同的人，实现工作效率最大化。 在学习抽象的东西的时候要多与现实生活中的场景进行类比。 Java SDK 并发包里的 Executor、Fork/Join、Future本质上都是一种分工的方式。 并发编程领域还总结了一些设计模式，基本上都是和分工方法相关的，例如生产者 - 消费者、Message、Worker Thread 模式等。 同步同步就相当于项目中的沟通协调，什么时间干什么工作。 放到软件程序中就是一个线程执行完，通知下一个线程执行而已。例如，用 Future 可以发起一个异步调用，当主线程通过 get() 方法取结果时，主线程就会等待，当异步执行的结果返回时，get() 方法就自动返回了，这就解决了我们主从线程的协作。 Java SDK 里提供的 CountDownLatch、CyclicBarrierr、Phaser、Exchanger 也都是用来解决线程协作问题的。 还有很多场景，是需要你自己来处理线程之间的协作。 在java并发编程领域，解决协作问题的核心就是管程，上面提到的所有线程协作技术底层都是利用管程解决的。管程是一种解决并发问题的通用模型，除了能解决线程协助问题，还能解决下面我们将要介绍的互斥问题。可以这么说，管程是解决并发问题的万能钥匙。 关键是理解管程模型，学好它就可以解决所有问题。 其次是了解java JDK并发包提供的几个线程协作的工具类场景，用好它们可以妥妥地提高你的工作效率。 互斥分工/同步主要强调性能，但是并发程序里还有一部分是关于正确性，用专业术语叫“线程安全”。 可见性问题 有序性问题 原子性问题 为了解决以上三个问题，java语言引入了内存模型，内存模型提供了一系列的规则，利用这些规则，我们可以避免以上问题。 所谓互斥，指的是同一时刻，只允许一个线程访问共享变量。 实现互斥的核心技术是锁，java语言里synchronized、SDK里各种Lock都能解决互斥问题。 虽说锁解决了安全性问题，但同时也带来了性能问题，那如何保证安全性的同时又尽量提高性能那？分场景优化： Java SDK 里提供的 ReadWriteLock、StampedLock 就可以优化读多写少场景下锁的性能。 还可以使用无锁的数据结构，例如 Java SDK 里提供的原子类都是基于无锁技术实现的。 除此之外，还有一些其他的方案，原理是不共享变量或者变量只允许许读。这方面，Java 提供了Thread Local 和 final 关键字，还有一种 Copy-on-write 的模式。 使用锁除了要注意性能问题外，还需要注意死锁问题。 这部分内容比较复杂，往往还是跨领域的，例如要理解可见性，就需要了解一些 CPU 和缓存的知识； 很多无锁算法的实现往往也需要理解 CPU 缓存。 这部分内容的学习，需要博览群书，在大脑里建立起 CPU、内存、I/O 执行的模拟器。 全景图 钻进去，看本质深入理解，找到本质。 多分析这些概念和结论是怎么来的？？ 它们是用来解决什么问题的？ 知其然知其所以然。 工程上解决问题，一定要有理论做基础。 总结 推荐书单 -《Java并发编程实战》作者阵容可谓大师云集，也包括Doug Lea -《Java并发编程的艺术》讲解并发包内部实现原理，能读明白，内功大增 -《图解Java多线程设计模式》并发编程设计模式方面的经典书籍 -《操作系统：精髓与设计原理》经典操作系统教材 http://ifeve.com 国内专业并发编程网站 http://www.cs.umd.edu/~pugh/java/memoryModel/ 很多并发编程的早期资料都在这里 参考文档 【1】简书主页·share猿 【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"并发","slug":"并发","permalink":"https://lywlefan.github.io/tags/并发/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://lywlefan.github.io/tags/读书笔记/"},{"name":"java并发编程实战-王宝令","slug":"java并发编程实战-王宝令","permalink":"https://lywlefan.github.io/tags/java并发编程实战-王宝令/"}]},{"title":"01.可见性、原子性和有序性问题：并发编程Bug的源头","date":"2019-07-01T16:00:00.000Z","path":"2019/07/02/高并发/书籍/java并发编程实战-王宝令/01.可见性、原子性和有序性问题：并发编程Bug的源头 /","text":"阅读笔记 可见性 原子性 有序性 并发幕后的故事这些年，我们的 CPU、内存、I/O 设备都在不断迭代，不断朝着更快的方向努力。但是，在这个快速发展的过程中，有一个核心矛盾一直存在，就是这三者的速度差异。 CPU和内存速度差异可以形象描述:CPU是天上一天，内存是地上一年。内存和I/O设备速度差异就更大了，内存是天山一天，I/O设备是地上十年。 大部分程序是需要访问内存，有些还要访问I/O,所以单方面提高CPU性能是无效的。 为了合理利用CPU高性能，平衡三者的速度差异，计算机体系/操作系统/编译程序都做了很大的贡献，主要体现在以下几点： CPU增加了缓存，以均衡速度差异 操作系统增加了进程/线程，以分时复用CPU，进而均衡CPU与I/O设备的速度差异； 编译程序优化指令执行次序，使得缓存能够更加合理的利用。 源头之一：缓存导致的可见性问题单核时代单核时代，所有线程在一颗CPU上执行，CPU缓存与内存的数据一致性容易解决。 一个线程对CPU的操作，其他线程都是可见的。 如下图所示，线程A和线程B都是操作同一个CPU里面的缓存，线程A操作CPU变量V之后，线程B再访问就一定可以得到最新值： 一个线程对共享变量的修改，另外一个线程立刻看到，我们称为可见性。 多核时代多核时代，每颗 CPU 都有自己的缓存，这时 CPU 缓存与内存的数据一致性就没那么容易解决了。 当多个线程在不同的 CPU 上执行时，这些线程操作的是不同的CPU。 线程 A 操作的是 CPU-1 上的缓存，而线程B操作的是 CPU-2 上的缓存，很明显，这个时候线程 A 对变量 V 的操作对于线程B 而言就不具备可见性了。这个就属于硬件程序员给软件程序员挖的“坑”。 多核 CPU 的缓存与内存关系图 下面我们再用一段代码来验证一下多核场景下的可见性问题。下面的代码，每执行一次 add10K() 方法，都会循环 10000 次 count+=1 操作。在 calc() 方法中我们创建了两个线程，每个线程调用一次 add10K() 方法，我们来想一想执行 calc() 方法得到的结果应该是多少呢？ 1234567891011121314151617181920212223242526public class Test &#123; private long count = 0; private void add10K() &#123; int idx = 0; while(idx++ &lt; 10000) &#123; count += 1; &#125; &#125; public static long calc() &#123; final Test test = new Test(); // 创建两个线程，执行 add() 操作 Thread th1 = new Thread(()-&gt;&#123; test.add10K(); &#125;); Thread th2 = new Thread(()-&gt;&#123; test.add10K(); &#125;); // 启动两个线程 th1.start(); th2.start(); // 等待两个线程执行结束 th1.join(); th2.join(); return count; &#125;&#125; 直觉可能告诉你应该是20000，但实际结果确实10000到20000之间的随机数。为什么那？因为两个线程在两cpu的核之间不断切换才导致的。 G:所谓可见性问题，说白了可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值同时可以操作这个值。 源头之二：线程切换带来的原子性问题 关键词： 线程切换 时间片 多进程 unix操作系统支持多进程分时复用而名噪天下 内存映射 一个进程创建的所有线程共享同一个内存空间 提到的“任务切换”都是指“线程切换” 高级语句里一条语句需要多条CPU指令来完成 比如：count + =1，需要以下几个指令来完成 指令一：把count从内存加载到cpu寄存器中 指令二：在寄存器执行+1操作 指令三：最后，将结果写入内存（缓存机制导致可能写入的是CPU缓存而不是内存） 重点语句 我们把一个或多个操作在CPU执行的过程中不被中断的特性称为原子性。 源头之三：编译优化带来的有序性问题 关键词 - 关键语句 有序性：代码按先后顺序执行 案例分析 利用双重检查创建单例对象 123456789101112public class Singleton &#123; static Singleton instance; static Singleton getInstance()&#123; if (instance == null) &#123; synchronized(Singleton.class) &#123; if (instance == null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 上面的代码，假设有两个线程同时判断instance为null—&gt;此时A和B任意一个线程加锁成功（假设是A）,另外一个线程处于等待状态（假设是B）—&gt;线程A创建实例释放锁，然后唤醒B —&gt; B继续加锁，结果实力不为空，B不创建实例 以上逻辑看似无懈可击，但实际并不完美，问题出在哪里？？ 出在new操作上 我们以为的new操作： 1.分配一块内存M 2.在内存M上初始化Singleton对象 3.然后M的地址赋值给instance对象 实际优化后如下： 1.分配一块内存M 2.将M的地址赋值给instanc变量 3.最后在M上初始化Singleton对象 优化后会导致什么问题那？假设A先执行getInstance()方法，当执行完指令2后恰好发生了线程切换，切换到线程B上；如果此时线程B也执行getInstance方法，那么线程B在执行第一个判断时会发现instance！=null，所以直接返回instance，而此时的instance是没有初始化过的，如果这个时候访问instance的成员变量就可能触发空指针异常。 总结 要想写好并发，就要知道并发问题出在哪里 只要我们能够深刻理解可见性/原子性/有序性在并发场景下的原理，很多并发bug都可以理解，可以诊断。 缓存导致可见性问题 线程切换带来的原子性问题 编译优化带来的有序性问题 在采用一项技术的时候一定要清楚它带来的问题是啥，以及如何规避 思考 1.常听人说，在 32 位的机器上对 long 型变量进行加减操操作存在并发隐患，到底是不是这样呢？ long类型64位，所以在32位的机器上，对long类型的数据操作通常需要多条指令组合出来，无法保证原子性，所以并发的时候会出问题 疑问：什么是32位机器？指的是啥？ cpu运算的数据都是由内存提供的，内存与cpu的通信速度靠的是外部频率（所谓外频指的是cpu与外部组件进行数据传输/运算是的速度，倍频则是cpu内部用来加速工作性能的一个倍数，两者相乘才是cpu的频率），每次工作可以传输的数据量大小是由总线决定的。一般主板芯片组分为北桥与南桥，北桥的总线称为系统总线，因为是内存传输的主要信道，所以速度较快；南桥就是所谓的输入输出（I/O）总线，主要用于联系硬盘、usb、网卡等接口设备。 北桥所支持的频率我们称之为前端总线速度（Front Side Bus,FSB），而每次传输的位数则是总线宽度。所以总线频宽 = FSB x 总线宽度，也就是每秒钟可传送的最大数据量，目前常见的总线宽度有32为和64位。 例如前端总线的最高速度可达1600MHZ。我们看到内存和北桥的频宽为12.8GB/S，也就是1600MHZ x 64Bit =1600MHZ x 8Bytes = 12800MHZ = 12.8GB/S。 与总线宽度相似，cpu每次能处理的数据量称为字组大小，字组大小依据cpu的设计而有32位与64位。我们现在所称的计算机是32位或64位主要依据cpu解析的字组大小而来的！早期的32位cpu中，因为cpu每次能够解析的数据量有限，因此由内存传来的数据量就有所限制了。这也导致32位的cpu最多只能支持最大到4GB的内存。 推荐书单 -《Java并发编程实战》作者阵容可谓大师云集，也包括Doug Lea -《Java并发编程的艺术》讲解并发包内部实现原理，能读明白，内功大增 -《图解Java多线程设计模式》并发编程设计模式方面的经典书籍 -《操作系统：精髓与设计原理》经典操作系统教材 http://ifeve.com 国内专业并发编程网站 http://www.cs.umd.edu/~pugh/java/memoryModel/ 很多并发编程的早期资料都在这里 参考文档 【1】简书主页·share猿 【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"并发","slug":"并发","permalink":"https://lywlefan.github.io/tags/并发/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://lywlefan.github.io/tags/读书笔记/"},{"name":"java并发编程实战-王宝令","slug":"java并发编程实战-王宝令","permalink":"https://lywlefan.github.io/tags/java并发编程实战-王宝令/"}]},{"title":"12.客户端都有哪些不常见但是很高级的功能？","date":"2019-07-01T16:00:00.000Z","path":"2019/07/02/中间件/kafka/读书笔记/kafka核心技术与实战-胡夕/12.客户端都有哪些不常见但是很高级的功能？/","text":"阅读笔记kafka 拦截器拦截器的原理和spring的拦截器的原理类似，可以做消息处理前后多个点的动态植入不同的处理逻辑。比如消息发送前或者在消息消费后。 kafka拦截器分为生产者拦截器和消费者拦截器。 生产拦截器允许你在发送消息前以及消息提交后植入你的拦截器逻辑； 消费拦截器支持在消费消息前以及提交位移后编写特定逻辑。 两种拦截器都支持链的方式，kafka会按序执行拦截器逻辑。 ###如何编写拦截器？ 生产者拦截器继承接口ProducerInterceptor onSend：消息调用前被调用 onAcknowledgement：消息提交成功或发送失败后被调用。这个方法要早于callback。这个方法和onSend不是在同一个线程里面调用，因此在两个方法调用过程中调用了某个共享变量，一定要保证线程安全。这个方法处在Producer发送的主路径中，所以我们不要放一些太重逻辑进去，负责你会发现Producer的TPS直线下降。 消费者拦截器实现ConsumerInterceptor接口 onConsume：在消息返回给Consumer 程序之前调用。也就是在消息开始处理前拦截一道。 onCommit：Consumer 在提交位移之后调用该方法。通常你可以在该方法做一些记账类的动作，比如：日志打印。 注意的问题 指定拦截器要指定它们全限定名，说的直白一点就是要把包名加上 典型使用场景 客户端监控 kafka默认提供的监控指标都是针对单个客户端或Broker的，你很难从具体消息维度去追踪群间消息的流转路径。同时如何监控一条消息从生产到最后消费的端到端延时也是很多kafka用户需要解决的问题。 从技术上讲，我们可以在客户端增加这样的逻辑，但是监控一般是不跟业务代码耦合的，因为耦合会影响业务代码性能。 基于以上的考虑，我们可以把监控的逻辑加到拦截器里面，这样做的好处可以实现可插拔，不耦合。 端到端性能检测 同上。 消息审计 所谓消息审计就是可以随时查看消息的去向，什么时间发布的？被什么业务消费了？我们就可以借用kafka的拦截器实现这个场景。 案例分享 处理端到端的延时 统计Producer到Consumer消费时间总时长，我们消费拦截器就可以按如下来写 1234567891011121314151617181920212223242526public class AvgLatencyProducerInterceptor implements ProducerInterceptor&lt;String, String&gt; &#123; private Jedis jedis; // 省略 Jedis 初始化 @Override public ProducerRecord&lt;String, String&gt; onSend(ProducerRecord&lt;String, String&gt; record) &#123; jedis.incr(\"totalSentMessage\"); return record; &#125; @Override public void onAcknowledgement(RecordMetadata metadata, Exception exception) &#123; &#125; @Override public void close() &#123; &#125; @Override public void configure(Map&lt;java.lang.String, ?&gt; configs) &#123; &#125; 下面是消费端代码：123456789101112131415161718192021222324252627282930313233public class AvgLatencyConsumerInterceptor implements ConsumerInterceptor&lt;String, String&gt; &#123; private Jedis jedis; // 省略 Jedis 初始化 @Override public ConsumerRecords&lt;String, String&gt; onConsume(ConsumerRecords&lt;String, String&gt; records) &#123; long lantency = 0L; for (ConsumerRecord&lt;String, String&gt; record : records) &#123; lantency += (System.currentTimeMillis() - record.timestamp()); &#125; jedis.incrBy(\"totalLatency\", lantency); long totalLatency = Long.parseLong(jedis.get(\"totalLatency\")); long totalSentMsgs = Long.parseLong(jedis.get(\"totalSentMessage\")); jedis.set(\"avgLatency\", String.valueOf(totalLatency / totalSentMsgs)); return records; &#125; @Override public void onCommit(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets) &#123; &#125; @Override public void close() &#123; &#125; @Override public void configure(Map&lt;String, ?&gt; configs) &#123;&#125; 这里我们可以用redis记录消息消费的时间,到redis中我们就可以很好的进行统计了,可以很好的统计到从producer到consumer的时间了。 小结 参考文档 【1】简书主页·share猿 【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://lywlefan.github.io/tags/读书笔记/"},{"name":"kafka","slug":"kafka","permalink":"https://lywlefan.github.io/tags/kafka/"},{"name":"kafka核心技术与实战-胡夕","slug":"kafka核心技术与实战-胡夕","permalink":"https://lywlefan.github.io/tags/kafka核心技术与实战-胡夕/"}]},{"title":"11.无消息丢失配置怎么实现？","date":"2019-06-30T16:00:00.000Z","path":"2019/07/01/中间件/kafka/读书笔记/kafka核心技术与实战-胡夕/11.无消息丢失配置怎么实现？/","text":"阅读笔记 kafka中什么算消息丢失 什么情况下能保证kafka消息不丢失 一句话概括,Kafka只对”已提交”的消息做有限度的持久化保证。 什么是已提交的消息?当kafka的若干个Broker成功的接收到一条消息并写入到日志文件之后,它们就会告诉生产者程序这条消息已成功提交。此时,这条消息在kafka看来就正式变为”已提交”消息了。 为什么是若干个Broker?这取决于”已提交”的定义,你可以选择只有一个broker成功保存该消息就算已提交,也可以令所有broker都保存才算已提交. 有限度的持久化保证至少有一个Broker存活,只要这个条件成立,kafka就不会丢消息,但是一个都不会存活的情况是有可能出现的. 消息丢失的案例复盘”kafka消息丢失”案例。 生产者程序丢失数据kafka producer是异步发送消息的,所以说当我们调用完producer.send(msg)这个api后,他通过会立即返回,但是并不代表我们消息发送成功. 以上发送消息的方式是不靠谱的,建议不要这样去搞,因为这种方式以下原因可能造成消息发送失败: 网络抖动 消息本身不合格,Broker不接受 解决以上问题其实有比较好的办法,就是我们Producer永远使用带有回调通知的发送API,也就是说不要使用producer.send(msg),而要使用producer.send(msg,callback),callback会告诉你消息是否处理成功,然后你再根据具体情况进行相应的处理。 如果因为某些瞬间错误,可以让producer继续重试,总之发送消息失败的责任是producer而不是在broker,当然broker宕机断网除外。 消费者程序丢失数据在kafka消费消息的时候有个”位移”的概念,我们可以把消费消息当做我们读书,而”位移”就相当于”书签”。 什么情况下消费者程序会存在丢数据的情况哪??? 我们把上面的类比分成两个部分:1.读书 2.移动书签位置 加入我们先移动书签,再读书就有可能造成消费者丢数据的情况,比如:我们计划读书到100页,然后我们把书签放到100页,当我们读到96页的时候突然有急事出去了,下次继续读的时候就从100页开始了,中间的页我们就没读到。 针对以上情况,我们应该是先读书然后移动书签的位置。 但是先读书再移动书签会不会造成消息重复消费的情况。 还一种多线程消费的情况,以前我们是一个人读书,现在把一本书10章分给10个人一起读,然后大家读完宣布这本书读完。 以上这种情况有可能这种异常情况,有部分线程没有读完就更新了位移,这就导致部分消息没有消费,但是响应的确实已经消费了的情况。 解决以上问题的办法就是:多线程处理消费消息,Consumer程序不要开启自动提交位移,而是要应用程序手动提交位移。 最佳实践 使用掉回调的生产消息的方法 设置 acks = all。acks 是 Producer的一个参数，代表了你对“已提交”消息的定义。如果设置成 all，则表明所有副本 Broker都要接收到消息，该消息才算是“已提交”。这是最高等级的“已提交”定义。 设置 retries 为一个较大的值。这里的 retries 同样是 Producer 的参数，对应前面提到的 Producer 自动重试。当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了 retries &gt; 0 的 Producer 能够自动重试消息发送，避免消息丢失。 设置 unclean.leader.election.enable = false。这是 Broker 端的参数，它控制的是哪些 Broker有资格竞选分区的 Leader。如果一个 Broker 落后原先的 Leader 太多，那么它一旦成为新的 Leader，必然会造成消息的丢失。故一般都要将该参数设置成 false，即不允许这种情况的发生。 设置 replication.factor &gt;= 3。这也是 Broker 端的参数。其实这里想表述的是，最好将消息多保存几份，毕竟目前防止消息丢失的主要机制就是冗余。 设置 min.insync.replicas &gt; 1。这依然是 Broker 端参数，控制的是消息至少要被写入到多少个副本才算是“已提交”。设置成大于 1 可以提升消息持久性。在实际环境中千万不要使用默认值 1。 确保 replication.factor&gt; min.insync.replicas。如果两者相等，那么只要有一个副本挂机，整个分区就无法正常工作了。我们不仅要改善消息的持久性，防止数据丢失，还要在不降低可用性的基础上完成。推荐设置成 replication.factor = min.insync.replicas + 1。 确保消息消费完成再提交。Consumer 端有个参数 enable.auto.commit，最好把它设置成 false ，并采用手动提交位移的方式。 就像前面说的，这对于单 Consumer 多线程处理的场景而言是至关重要的。 开发讨论特别隐秘丢消息的场景: 当增加主题分区后，在某段“不凑巧”的时间间隔后，Producer 先于 Consumer 感知到新增加的分区，而 Consumer 设置的是“从最新位移处”开始读取消息，因此在 Consumer 感知到新分区前，Producer 发送的这些消息就全部“丢失”了，或者说 Consumer 无法读取到这些消息。Kafka 设计上的一个小缺陷，你有什么解决的办法吗？ cricket1981：consumer改用”从最早位置”读解决新加分区造成的问题 明翼：这个问题我想个办法就是程序停止再增加分区，如果不能停止那就找个通知机制了。请教一个问题min.insync.replicas这个参数如果设置成3，假设副本数设置为4，那岂不是只支持一台broker坏掉的情况？ 作者：能想到的一个简单方法是让consumer端缓存订阅信息，如果发现新的订阅分区出现，手动调整位移到最开始处执行（比如consumer.seekToBeginning） 参考文档 【1】简书主页·share猿 【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://lywlefan.github.io/tags/读书笔记/"},{"name":"kafka","slug":"kafka","permalink":"https://lywlefan.github.io/tags/kafka/"},{"name":"kafka核心技术与实战-胡夕","slug":"kafka核心技术与实战-胡夕","permalink":"https://lywlefan.github.io/tags/kafka核心技术与实战-胡夕/"}]},{"title":"es的FAQ","date":"2019-06-27T16:00:00.000Z","path":"2019/06/28/中间件/es/FAQ/","text":"问题整理 参考文档 【1】简书主页·share猿 【2】掘金主页·share猿 【3】redis官网 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"redis","slug":"redis","permalink":"https://lywlefan.github.io/tags/redis/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://lywlefan.github.io/tags/学习笔记/"}]},{"title":"es的VERSION","date":"2019-06-27T16:00:00.000Z","path":"2019/06/28/中间件/es/VERSION/","text":"问题整理 参考文档 【1】简书主页·share猿 【2】掘金主页·share猿 【3】redis官网 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"redis","slug":"redis","permalink":"https://lywlefan.github.io/tags/redis/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://lywlefan.github.io/tags/学习笔记/"}]},{"title":"es的COLLECTION","date":"2019-06-27T16:00:00.000Z","path":"2019/06/28/中间件/es/COLLECTION/","text":"学习基础学习 1.Elasticsearch学习，请先看这一篇！ 2.Elasticsearch 权威指南（中文版） 视频文章考试考试导航文章 Elastic认证考试，请先看这一篇！ 视频备考学习 参考文档 【1】简书主页·share猿 【2】掘金主页·share猿 【3】elasticsearch官网 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"collection","slug":"collection","permalink":"https://lywlefan.github.io/tags/collection/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://lywlefan.github.io/tags/elasticsearch/"}]},{"title":"redis的FAQ","date":"2019-06-27T16:00:00.000Z","path":"2019/06/28/中间件/redis/FAQ/","text":"问题整理 参考文档 【1】简书主页·share猿 【2】掘金主页·share猿 【3】redis官网 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"redis","slug":"redis","permalink":"https://lywlefan.github.io/tags/redis/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://lywlefan.github.io/tags/学习笔记/"}]},{"title":"redis的VERSION","date":"2019-06-27T16:00:00.000Z","path":"2019/06/28/中间件/redis/VERSION/","text":"问题整理 参考文档 【1】简书主页·share猿 【2】掘金主页·share猿 【3】redis官网 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"redis","slug":"redis","permalink":"https://lywlefan.github.io/tags/redis/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://lywlefan.github.io/tags/学习笔记/"}]},{"title":"10.生产者压缩算法面面观","date":"2019-06-27T16:00:00.000Z","path":"2019/06/28/中间件/kafka/读书笔记/kafka核心技术与实战-胡夕/10.生产者压缩算法面面观/","text":"阅读笔记 消息压缩 GZIP Snappy Zero Copy(零拷贝技术) 何时压缩 笔记压缩算法笔记 GZIP Snappy LZ4 Zstandard(zstd):2.1.0开始，facebook开源的压缩算法，能够提高超高性能压缩比。 如何压缩 v1（kafka 0.11.0之前）:message set, message ,v2（kafka 0.11.0以后）:record batch,record 我看了三遍老师的课，得到了我要的答案：1.如果生产者使用了压缩，broker为了crc校验，会启动解压，这个解压过程不可避免；2.v2的broker为了低版本的消费者，会把消息再次解压并进行协议转换。 CRC校验（每条消息执行CRC校验） 消息集合 消息 日志项 看一个压缩算法的指标 压缩比 原来占100份空间的东西压缩成20，那么压缩比就是5，显然压缩比越高越好。 吞吐量(压缩/解压缩) 每秒能压缩或者解压多少MB数据,同样吞吐量也是越高越好。 facebook各个压缩算法性能测试 1.png 如何选择压缩算法 启用压缩的一个条件就是Producer程序运行机器上的CPU要充足。 带宽资源有限建议开启压缩(带宽比cpu和内存还要珍贵) cpu资源富于，建议开启zstd压缩，这样能极大节省网络资源消耗。 规避意料之外的解压缩，比如：兼容老版本而引入解压缩 有条件尽量保证不要出现消息格式转换的情况 浓缩精华 Producer端压缩/Broker端保持/Consumer端解压 注意问题producer和broker端的压缩算法尽量保持一致建议京东小哥建议 去掉因为做消息校验而引入解压缩,据他们称，去掉解压缩后，Broker端CPU使用率至少降低了50%。 社区未采纳建议，原因是消息校验特别重要，不能盲目去掉。 应用实践实时日志收集系统 参考文档 【1】简书主页·share猿 【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://lywlefan.github.io/tags/读书笔记/"},{"name":"kafka","slug":"kafka","permalink":"https://lywlefan.github.io/tags/kafka/"},{"name":"kafka核心技术与实战-胡夕","slug":"kafka核心技术与实战-胡夕","permalink":"https://lywlefan.github.io/tags/kafka核心技术与实战-胡夕/"}]},{"title":"09.生产者消息分区机制原理剖析","date":"2019-06-27T16:00:00.000Z","path":"2019/06/28/中间件/kafka/读书笔记/kafka核心技术与实战-胡夕/09.生产者消息分区机制原理剖析/","text":"阅读笔记生产者消息分区机制原理剖析 如何将大的数据均匀的分配到Kafka的各个Broker上？ 为什么分区？ 为什么分区？ 三级结构：主题-分区-消息 主题下的每条消息只会保存在某一个分区中，而不会在多个分区中被保存多份 疑问:为什么kafka要这样设计？有什么好处？ 回答:我们设想一个问题，我们在学校找一个学生，如果我们直接把学生集中在一起去找是不是很麻烦，很低效。换种方式，每50个学生一组，配置一个负责人，然后通知这些负责人去找某个同学，是不是很快就可以找到了，这也就是分区的意义所在。如果，我们把这种思想放到我们的系统中，就可以提高我们系统的负载均衡能力，实现了系统的高伸缩性(Scalability) 不同的分区能够被放置到不同节点的机器上 疑问：同一个topic下不同的分区是保存到相同机器的不同磁盘上的吗？ 回答: 在 MongoDB 和 Elasticsearch 中就叫分Shard，而在HBase中则叫Region,在Cassandra中又被称作vnode。 实现业务级别的消息顺序的问题 都有哪些分区策略？所谓分区策略是决定生产者将消息发送到那个分区的算法。提供了默认的分区策略，同时支持自定义分区策略。 自定义分区 配置partitioner.class参数 实现Partitioner接口 1int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster); 这里的topic、key、keyBytes、value和valueBytes都属于消息数据，cluster则是集群信息(比如当前Kafka集群有多少主题，多少Broker等)。 策略 轮询策略(Round-robin) 轮询是kafka默认的消息存储策略，新增的消息会依次进入1/2/3/4/….对应的分区。轮询策略有非常优秀的负载均衡表现，它总能保证消息最大限度地平均分配到所有分区上，故默认情况下它是最合理的分区策略，也是我们常用的分区策略之一。 随机策略(Randomness) 12345678910111213141516171819202122List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);return ThreadLocalRandom.current().nextInt(partitions.size());``` 实现比较简单，先计算出该主题总的分区数，然后随机地返回一个小于它的正整数。该策略是kafka老版本的策略，追求数据均匀分布还是轮询策略比较好。- 按消息键保序策略 - 同一个消息key的消息进入同一个分区 - 一个分区只能被同一个消费组（ConsumerGroup）内的一个消费者消费 这里我们可以给我们的消息以时间的维度定义key，如此同一时间的消息就进入了同一个分区，同一个分区下的消息也有了顺序性。 - 每个分区消息都是有顺序的 - 代码实现 ```java List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic); return Math.abs(key.hashCode()) % partitions.size(); 其他分区策略(比如：基于地理位置的分区策略) 场景 公司有两个机房，一个在广州，一个在北京，在每个机房里面抽取部分机器组成kafka集群。现在公司app搞活动，北京新注册的用户送北京烤鸭一只，广州注册的用户送一次大保健，我们如何用kafka实现这一需求？ 解决方案一 解决方案二 提出问题自己提问问题1 通过kafka创建一个topic，默认分几个区？ 回答：创建topic的时候就需要指定需要创建的分区个数. 问题2 基于地理位置的分区策略可以通过按消息键保序策略实现，这样做有什么意义？ 其他人的问题问题1 老师能不能有空能不能讲讲kafka和rocketMQ的对比, 我用下来感觉整体挺像的但是具体使用场景和性能优劣方面还是有点不知道该使用选择, 谢谢. 回答：在我看来RocketMQ与Kafka的主要区别 ：1. Kafka吞吐量大，多是面向大数据场景。RocketMQ吞吐量也很强， 不过它号称是金融业务级的消息中间件，也就是说可以用于实际的业务系统；2. RocketMQ毕竟是阿里出品，在国内技术支持力度要比Kafka强；3. Kafka现在主要发力Streaming，RocketMQ在流处理这块表现如何我不太清楚，至少streaming不是它现阶段的主要卖点。 问题2 kafka的主题只有一级、像mq可以进行主题分层：一级主题、二级主题。kafka为何这样设计？ 参考文档 【1】简书主页·share猿 【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://lywlefan.github.io/tags/读书笔记/"},{"name":"kafka","slug":"kafka","permalink":"https://lywlefan.github.io/tags/kafka/"},{"name":"kafka核心技术与实战-胡夕","slug":"kafka核心技术与实战-胡夕","permalink":"https://lywlefan.github.io/tags/kafka核心技术与实战-胡夕/"}]},{"title":"Java并发编程：CountDownLatch、CyclicBarrier和Semaphore","date":"2019-06-26T16:00:00.000Z","path":"2019/06/27/高并发/基础/Java并发编程：CountDownLatch、CyclicBarrier和Semaphore/","text":"面向对象的语言最好的学习方法就是在实际生活中找一个列子类比。 CountDownLatch(计数器) CyclicBarrier(回环栅栏) Semaphore(信号量) CountDownLatchCountDownLatch类位于java.util.concurrent包下，利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。 基础构造方法123456//count代表计数的个数public CountDownLatch(int count) &#123; if (count &lt; 0) throw new IllegalArgumentException(\"count &lt; 0\"); this.sync = new Sync(count);&#125; 方法123456//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行public void await() throws InterruptedException &#123; &#125;; //和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行public boolean await(long timeout, TimeUnit unit) throws InterruptedException &#123; &#125;; //将count值减1public void countDown() &#123; &#125;; 类比理解大家在考科目一的时候是如何考的？我们知道车管所的考试机器比考试人数要少很多，假如机器有50个，每次考官让50个人进去，然后再宣布考试开始，其他人继续等待。 CountDownLatch就可以实现这个效果，我们可以这样做： CountDownLatch latch=new CountDownLatch(50) 进入考场一个学员，我们就latch.countDown()减一 到latch为0的时候，考官宣布考试开始，如此而已 12345678910111213141516171819202122232425262728293031323334353637383940public class Test &#123; public static void main(String[] args) &#123; final CountDownLatch latch = new CountDownLatch(2); new Thread()&#123; public void run() &#123; try &#123; System.out.println(\"子线程\"+Thread.currentThread().getName()+\"正在执行\"); Thread.sleep(3000); System.out.println(\"子线程\"+Thread.currentThread().getName()+\"执行完毕\"); latch.countDown(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;; &#125;.start(); new Thread()&#123; public void run() &#123; try &#123; System.out.println(\"子线程\"+Thread.currentThread().getName()+\"正在执行\"); Thread.sleep(3000); System.out.println(\"子线程\"+Thread.currentThread().getName()+\"执行完毕\"); latch.countDown(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;; &#125;.start(); try &#123; System.out.println(\"等待2个子线程执行完毕...\"); latch.await(); System.out.println(\"2个子线程已经执行完毕\"); System.out.println(\"继续执行主线程\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行结果： 1234567线程Thread-0正在执行线程Thread-1正在执行等待2个子线程执行完毕...线程Thread-0执行完毕线程Thread-1执行完毕2个子线程已经执行完毕继续执行主线程 CyclicBarrier基础字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。我们暂且把这个状态就叫做barrier，当调用await()方法之后，线程就处于barrier了。 CyclicBarrier类位于java.util.concurrent包下，CyclicBarrier提供2个构造器： 构造方法12345public CyclicBarrier(int parties, Runnable barrierAction) &#123;&#125; public CyclicBarrier(int parties) &#123;&#125; 参数parties指让多少个线程或者任务等待至barrier状态；参数barrierAction为当这些线程都达到barrier状态时会执行的内容。 方法然后CyclicBarrier中最重要的方法就是await方法，它有2个重载版本： 12public int await() throws InterruptedException, BrokenBarrierException &#123; &#125;;public int await(long timeout, TimeUnit unit)throws InterruptedException,BrokenBarrierException,TimeoutException &#123; &#125;; 第一个版本比较常用，用来挂起当前线程，直至所有线程都到达barrier状态再同时执行后续任务； 第二个版本是让这些线程等待至一定的时间，如果还有线程没有到达barrier状态就直接让到达barrier的线程执行后续任务。 类比理解例1假若有若干个线程都要进行写数据操作，并且只有所有线程都完成写数据操作之后，这些线程才能继续做后面的事情，此时就可以利用CyclicBarrier了： 1234567891011121314151617181920212223242526272829public class Test &#123; public static void main(String[] args) &#123; int N = 4; CyclicBarrier barrier = new CyclicBarrier(N); for(int i=0;i&lt;N;i++) new Writer(barrier).start(); &#125; static class Writer extends Thread&#123; private CyclicBarrier cyclicBarrier; public Writer(CyclicBarrier cyclicBarrier) &#123; this.cyclicBarrier = cyclicBarrier; &#125; @Override public void run() &#123; System.out.println(\"线程\"+Thread.currentThread().getName()+\"正在写入数据...\"); try &#123; Thread.sleep(5000); //以睡眠来模拟写入数据操作 System.out.println(\"线程\"+Thread.currentThread().getName()+\"写入数据完毕，等待其他线程写入完毕\"); cyclicBarrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;catch(BrokenBarrierException e)&#123; e.printStackTrace(); &#125; System.out.println(\"所有线程写入完毕，继续处理其他任务...\"); &#125; &#125;&#125; 执行结果： 123456789101112线程Thread-0正在写入数据...线程Thread-3正在写入数据...线程Thread-2正在写入数据...线程Thread-1正在写入数据...线程Thread-2写入数据完毕，等待其他线程写入完毕线程Thread-0写入数据完毕，等待其他线程写入完毕线程Thread-3写入数据完毕，等待其他线程写入完毕线程Thread-1写入数据完毕，等待其他线程写入完毕所有线程写入完毕，继续处理其他任务...所有线程写入完毕，继续处理其他任务...所有线程写入完毕，继续处理其他任务...所有线程写入完毕，继续处理其他任务... 从上面输出结果可以看出，每个写入线程执行完写数据操作之后，就在等待其他线程写入操作完毕。 当所有线程线程写入操作完毕之后，所有线程就继续进行后续的操作了。 例2如果说想在所有线程写入操作完之后，进行额外的其他操作可以为CyclicBarrier提供Runnable参数： 1234567891011121314151617181920212223242526272829303132333435public class Test &#123; public static void main(String[] args) &#123; int N = 4; CyclicBarrier barrier = new CyclicBarrier(N,new Runnable() &#123; @Override public void run() &#123; System.out.println(\"当前线程\"+Thread.currentThread().getName()); &#125; &#125;); for(int i=0;i&lt;N;i++) new Writer(barrier).start(); &#125; static class Writer extends Thread&#123; private CyclicBarrier cyclicBarrier; public Writer(CyclicBarrier cyclicBarrier) &#123; this.cyclicBarrier = cyclicBarrier; &#125; @Override public void run() &#123; System.out.println(\"线程\"+Thread.currentThread().getName()+\"正在写入数据...\"); try &#123; Thread.sleep(5000); //以睡眠来模拟写入数据操作 System.out.println(\"线程\"+Thread.currentThread().getName()+\"写入数据完毕，等待其他线程写入完毕\"); cyclicBarrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;catch(BrokenBarrierException e)&#123; e.printStackTrace(); &#125; System.out.println(\"所有线程写入完毕，继续处理其他任务...\"); &#125; &#125;&#125; 运行结果: 1234567891011121314线程Thread-0正在写入数据...线程Thread-1正在写入数据...线程Thread-2正在写入数据...线程Thread-3正在写入数据...线程Thread-0写入数据完毕，等待其他线程写入完毕线程Thread-1写入数据完毕，等待其他线程写入完毕线程Thread-2写入数据完毕，等待其他线程写入完毕线程Thread-3写入数据完毕，等待其他线程写入完毕当前线程Thread-3所有线程写入完毕，继续处理其他任务...所有线程写入完毕，继续处理其他任务...所有线程写入完毕，继续处理其他任务...所有线程写入完毕，继续处理其他任务... 从结果可以看出，当四个线程都到达barrier状态后，会从四个线程中选择一个线程去执行Runnable。 例3下面看一下为await指定时间的效果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Test &#123; public static void main(String[] args) &#123; int N = 4; CyclicBarrier barrier = new CyclicBarrier(N); for(int i=0;i&lt;N;i++) &#123; if(i&lt;N-1) new Writer(barrier).start(); else &#123; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; new Writer(barrier).start(); &#125; &#125; &#125; static class Writer extends Thread&#123; private CyclicBarrier cyclicBarrier; public Writer(CyclicBarrier cyclicBarrier) &#123; this.cyclicBarrier = cyclicBarrier; &#125; @Override public void run() &#123; System.out.println(\"线程\"+Thread.currentThread().getName()+\"正在写入数据...\"); try &#123; Thread.sleep(5000); //以睡眠来模拟写入数据操作 System.out.println(\"线程\"+Thread.currentThread().getName()+\"写入数据完毕，等待其他线程写入完毕\"); try &#123; cyclicBarrier.await(2000, TimeUnit.MILLISECONDS); &#125; catch (TimeoutException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;catch(BrokenBarrierException e)&#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\"所有线程写入完毕，继续处理其他任务...\"); &#125; &#125;&#125; 执行结果： 12345678910111213141516171819202122232425262728线程Thread-0正在写入数据...线程Thread-2正在写入数据...线程Thread-1正在写入数据...线程Thread-2写入数据完毕，等待其他线程写入完毕线程Thread-0写入数据完毕，等待其他线程写入完毕线程Thread-1写入数据完毕，等待其他线程写入完毕线程Thread-3正在写入数据...java.util.concurrent.TimeoutExceptionThread-1所有线程写入完毕，继续处理其他任务...Thread-0所有线程写入完毕，继续处理其他任务... at java.util.concurrent.CyclicBarrier.dowait(Unknown Source) at java.util.concurrent.CyclicBarrier.await(Unknown Source) at com.cxh.test1.Test$Writer.run(Test.java:58)java.util.concurrent.BrokenBarrierException at java.util.concurrent.CyclicBarrier.dowait(Unknown Source) at java.util.concurrent.CyclicBarrier.await(Unknown Source) at com.cxh.test1.Test$Writer.run(Test.java:58)java.util.concurrent.BrokenBarrierException at java.util.concurrent.CyclicBarrier.dowait(Unknown Source) at java.util.concurrent.CyclicBarrier.await(Unknown Source) at com.cxh.test1.Test$Writer.run(Test.java:58)Thread-2所有线程写入完毕，继续处理其他任务...java.util.concurrent.BrokenBarrierException线程Thread-3写入数据完毕，等待其他线程写入完毕 at java.util.concurrent.CyclicBarrier.dowait(Unknown Source) at java.util.concurrent.CyclicBarrier.await(Unknown Source) at com.cxh.test1.Test$Writer.run(Test.java:58)Thread-3所有线程写入完毕，继续处理其他任务... 上面的代码在main方法的for循环中，故意让最后一个线程启动延迟，因为在前面三个线程都达到barrier之后，等待了指定的时间发现第四个线程还没有达到barrier，就抛出异常并继续执行后面的任务。 例5另外CyclicBarrier是可以重用的，看下面这个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Test &#123; public static void main(String[] args) &#123; int N = 4; CyclicBarrier barrier = new CyclicBarrier(N); for(int i=0;i&lt;N;i++) &#123; new Writer(barrier).start(); &#125; try &#123; Thread.sleep(25000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"CyclicBarrier重用\"); for(int i=0;i&lt;N;i++) &#123; new Writer(barrier).start(); &#125; &#125; static class Writer extends Thread&#123; private CyclicBarrier cyclicBarrier; public Writer(CyclicBarrier cyclicBarrier) &#123; this.cyclicBarrier = cyclicBarrier; &#125; @Override public void run() &#123; System.out.println(\"线程\"+Thread.currentThread().getName()+\"正在写入数据...\"); try &#123; Thread.sleep(5000); //以睡眠来模拟写入数据操作 System.out.println(\"线程\"+Thread.currentThread().getName()+\"写入数据完毕，等待其他线程写入完毕\"); cyclicBarrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;catch(BrokenBarrierException e)&#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\"所有线程写入完毕，继续处理其他任务...\"); &#125; &#125;&#125; 执行结果： 12345678910111213141516171819202122232425线程Thread-0正在写入数据...线程Thread-1正在写入数据...线程Thread-3正在写入数据...线程Thread-2正在写入数据...线程Thread-1写入数据完毕，等待其他线程写入完毕线程Thread-3写入数据完毕，等待其他线程写入完毕线程Thread-2写入数据完毕，等待其他线程写入完毕线程Thread-0写入数据完毕，等待其他线程写入完毕Thread-0所有线程写入完毕，继续处理其他任务...Thread-3所有线程写入完毕，继续处理其他任务...Thread-1所有线程写入完毕，继续处理其他任务...Thread-2所有线程写入完毕，继续处理其他任务...CyclicBarrier重用线程Thread-4正在写入数据...线程Thread-5正在写入数据...线程Thread-6正在写入数据...线程Thread-7正在写入数据...线程Thread-7写入数据完毕，等待其他线程写入完毕线程Thread-5写入数据完毕，等待其他线程写入完毕线程Thread-6写入数据完毕，等待其他线程写入完毕线程Thread-4写入数据完毕，等待其他线程写入完毕Thread-4所有线程写入完毕，继续处理其他任务...Thread-5所有线程写入完毕，继续处理其他任务...Thread-6所有线程写入完毕，继续处理其他任务...Thread-7所有线程写入完毕，继续处理其他任务... 从执行结果可以看出，在初次的4个线程越过barrier状态后，又可以用来进行新一轮的使用。而CountDownLatch无法进行重复使用。 SemaphoreSemaphore翻译成字面意思为 信号量，Semaphore可以控同时访问的线程个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。 基础Semaphore类位于java.util.concurrent包下，它提供了2个构造器： 构造方法123456public Semaphore(int permits) &#123; //参数permits表示许可数目，即同时可以允许多少线程进行访问 sync = new NonfairSync(permits);&#125;public Semaphore(int permits, boolean fair) &#123; //这个多了一个参数fair表示是否是公平的，即等待时间越久的越先获取许可 sync = (fair)? new FairSync(permits) : new NonfairSync(permits);&#125; 方法下面说一下Semaphore类中比较重要的几个方法，首先是acquire()、release()方法： 1234public void acquire() throws InterruptedException &#123; &#125; //获取一个许可public void acquire(int permits) throws InterruptedException &#123; &#125; //获取permits个许可public void release() &#123; &#125; //释放一个许可public void release(int permits) &#123; &#125; //释放permits个许可 acquire()用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许可。 release()用来释放许可。注意，在释放许可之前，必须先获获得许可。 这4个方法都会被阻塞，如果想立即得到执行结果，可以使用下面几个方法： 1234public boolean tryAcquire() &#123; &#125;; //尝试获取一个许可，若获取成功，则立即返回true，若获取失败，则立即返回falsepublic boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException &#123; &#125;; //尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回falsepublic boolean tryAcquire(int permits) &#123; &#125;; //尝试获取permits个许可，若获取成功，则立即返回true，若获取失败，则立即返回falsepublic boolean tryAcquire(int permits, long timeout, TimeUnit unit) throws InterruptedException &#123; &#125;; //尝试获取permits个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false 另外还可以通过availablePermits()方法得到可用的许可数目。 类比理解下面通过一个例子来看一下Semaphore的具体使用： 假若一个工厂有5台机器，但是有8个工人，一台机器同时只能被一个工人使用，只有使用完了，其他工人才能继续使用。那么我们就可以通过Semaphore来实现： 123456789101112131415161718192021222324252627282930public class Test &#123; public static void main(String[] args) &#123; int N = 8; //工人数 Semaphore semaphore = new Semaphore(5); //机器数目 for(int i=0;i&lt;N;i++) new Worker(i,semaphore).start(); &#125; static class Worker extends Thread&#123; private int num; private Semaphore semaphore; public Worker(int num,Semaphore semaphore)&#123; this.num = num; this.semaphore = semaphore; &#125; @Override public void run() &#123; try &#123; semaphore.acquire(); System.out.println(\"工人\"+this.num+\"占用一个机器在生产...\"); Thread.sleep(2000); System.out.println(\"工人\"+this.num+\"释放出机器\"); semaphore.release(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 执行结果： 12345678910111213141516工人0占用一个机器在生产...工人1占用一个机器在生产...工人2占用一个机器在生产...工人4占用一个机器在生产...工人5占用一个机器在生产...工人0释放出机器工人2释放出机器工人3占用一个机器在生产...工人7占用一个机器在生产...工人4释放出机器工人5释放出机器工人1释放出机器工人6占用一个机器在生产...工人3释放出机器工人7释放出机器工人6释放出机器 FAQ总结下面对上面说的三个辅助类进行一个总结： 1）CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同： CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行； 而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行； 另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。 2）Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。 参考文档 【1】简书主页·share猿 【2】掘金主页·share猿 【3】disruptor官网 【4】JAVA CAS原理深度分析 【5】并发框架Disruptor译文 【6】从构建分布式秒杀系统聊聊Disruptor高性能队列 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"基础","slug":"基础","permalink":"https://lywlefan.github.io/tags/基础/"},{"name":"并发","slug":"并发","permalink":"https://lywlefan.github.io/tags/并发/"}]},{"title":"架构导航","date":"2019-06-25T16:00:00.000Z","path":"2019/06/26/架构/架构导航/","text":"万丈高楼平地起的前提是地基好. 技术选型网关 Nginx Kong Zuul GateWay 缓存 Redis MemCached OsCache EhCache 搜索 ElasticSearch Solr 熔断 Hystrix resilience4j 负载均衡 DNS F5 LVS Nginx OpenResty HAproxy 注册中心 Eureka Zookeeper Redis Etcd Consul 认证鉴权 JWT 消费队列 RabbitMQ ZeroMQ Redis ActiveMQ Kafka 系统监控 Grafana Prometheus Influxdb Telegraf Lepus Istio 文件系统 OSS NFS FastDFS MogileFS RPC框架 Dubbo Motan Thrift grpc 构建工具 Maven Gradle 集成部署 Docker Jenkins Git Maven 分布式配置 Disconf Apollo Spring Cloud Config Diamond Diamond是淘宝研发的分布式配置管理系统。使用Diamond可以让集群中的服务进程动态感知数据的变化，无需重启服务就可以实现配置数据的更新。 具有简单、可靠、易用等特点 压测 LoadRunner JMeter AB webbench ab.exe 数据库 MySql Redis MongoDB PostgreSQL Memcache HBase MPP数据库(Greenplum、TiDB、Postgresql XC、HAWQ等) 网络 专用网络VPC 弹性公网IP CDN CDN就可以理解为分布在每个县城的火车票代售点，用户在浏览网站的时候，CDN会选择一个离用户最近的CDN边缘节点来响应用户的请求，这样海南移动用户的请求就不会千里迢迢跑到北京电信机房的服务器（假设源站部署在北京电信机房）上了。 数据库中间件 DRDS Mycat 360 Atlas Cobar (不维护了) 分布式框架 Dubbo Motan Spring-Could 分布式任务 XXL JOB Elastic-Job Saturn Quartz 分布式追踪 Pinpoint CAT zipkin 分布式日志 elasticsearch logstash Kibana redis kafka 版本发布 蓝绿部署 A/B测试 灰度发布／金丝雀发布 持续交付 链路监控 监控架构四层监控 前端监控：IP、PV、运营商、系统、性能、状态码 业务监控：登录、注册、下单、支付 应用层监控：service、sql、cache、相应时间 系统监控：物理机、虚拟机、容器，CPU、内存、IO、硬盘 基础监控：网络、交换机、路由器 监控分类 日志监控 调用链监控 告警系统 Metrics监控 监控检查 Docker、Grafana、Prometheus、Telegraf、Influxdb、Lepus、Elasticsearch、Logstash、Kibana、kafka、node插件、dashboards仪表盘、钉钉、邮件、微信。 服务框架和治理 架构必备 负载均衡（负载均衡算法） 反向代理 服务隔离 服务限流 1.限流文章 服务降级（自动优雅降级） 失效转移 超时重试（代理超时、容器超时、前端超时、中间件超时、数据库超时、NoSql超时） 回滚机制（上线回滚、数据库版本回滚、事务回滚） 高并发 应用缓存 HTTP缓存 多级缓存 分布式缓存 连接池 异步并发 分布式事务 二阶段提交(强一致) 三阶段提交(强一致) 消息中间件(最终一致性)，推荐阿里的RocketMQ 队列 任务队列 消息队列 请求队列 扩容 单体垂直扩容 单体水平扩容 应用拆分 数据库拆分 数据库分库分表 数据异构 分布式任务 网络安全 SQL注入 XSS攻击 CSRF攻击 拒绝服务（DoS，Denial of Service）攻击 参考文档 【1】简书主页·share猿 【2】掘金主页·share猿 【3】LMAX架构简介·汤雪华 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"架构导航","slug":"架构导航","permalink":"https://lywlefan.github.io/tags/架构导航/"}]},{"title":"撮合系统设计","date":"2019-06-25T16:00:00.000Z","path":"2019/06/26/业务场景/交易所/撮合系统设计/","text":"摘要：撮合技术主要是从数据库撮合技术向内存撮合技术发展，这是因为数据库撮合技术越来越无法满足金融交易对于高可靠性、高性能、强安全性、可扩展性以及易维护性的需求。本文来自中生代技术群的34期分享，将和大家讨论基于内存的撮合的系统设计。李伟山，毕业于国防科技大学，曾就职于华为、阿里巴巴，目前人江苏大圆银泰技术总监，对于高并发、大数据架构设计有深刻的了解。1.概述 随着信息技术的日新月异和金融业务的快速发展,金融交易领域对于核心技术的求也在不断增强,国内外金融交易模式已经从传统的人工叫价的方式变成了由高度电子化交易系统撮合订单的方式。传统的金融交易主要发生在有型金融市场中,金融交易的买卖双方通过叫价进行价格协商等方式最终达成一致,从而形成一笔交易,同时按照交易订单到指定的交割地点进行实物交割的交易方式。由于交易的整个过程主要依靠人来执行,传统的金融交易缺点主要有:效率低速度慢、交易时间限制大、交易空间限制大、交易成本非常髙、容易有内幕交易、交易扩展性差、交易容易出错、资金安全性差等一系列的缺点。 时代不断变迁,金融交易通过与计算机技术的结合,走上了电子化交易的道路,通过将金融交易市场电子化,电子交易不仅消除了传统金融交易的种种弊端,也促进了现代金融业的快速发展。电子金融交易的主要优点有:交易效率高速度快、交易透明度高、交易成本低、系统安全性高、不受交易时间的限制、不受交易空间的限制、可以进行多方位的扩展、大力推动现代金融业发展等。 因此现在电子交易己经成为了金融交易市场的主流交易方式。随着交易人数、笔数的不断增加,系统承受着越来越大的压力,如果在交易时间内系统发生故障,造成的损失往往不可估量。因此发出更可靠更高效的电子交易系统己经成为了金融交易领域的当务之急。 撮合交易在金融交易系统中扮演者非常重要的角色。了解撮合交易的本质以及业务对于设计撮合系统至关重要。江苏大泰技术有限公司，致力于互联网金融平台的开发，目前已经在运行的平台有大宗交易、普洱茶交易系统，后期会发布连续现货和发售交易平台，接下来为大家介绍基于内存的撮合交易系统设计概要。 2.系统总体设计2.1 层次设计一般而言,金融交易撮合系统中包括以下几个核心模块: 用户:终端用户委托报价与数量,生成订单发送至交易平台。 网关:负责收集用户订单,并将其派发给撮合引擎。 撮合引擎:交易系统中的核心部分,用于接收订单并根据业务逻辑实现订单 撮合同时生成交易记录,随后给予用户交易结果反馈。 数据库:用来存放交易过程中的订单和交易记录,实现数据持久化。 此外,本文根据不同类型的金融交易展品将撮合模块划分为若干业务分区,每个分区独立进行撮合,彼此不受影响。对于单个业务分区而言,撮合系统整体架构设计如图1.2所示,本章的总体设计围绕撮合引擎层以及撮合引擎与网关层、数据库层的交互方式的总体设计。 2.2 撮合交易算法如图2.1所示,撮合引擎的核心业务模块就是撮合交易算法撮合交易算法的任务一方面是完成对客户所下订单进行公平合理的排列和撮合功能,也要保证撮合算法的公平性、高效性以及扩展性等。由于不同金融交易系统的撮合业务各有不同,因此本节对通用的撮合交易算法进行概括性描述。 2.2.1订单队列撮合交易的重要组成部分就是买卖订单,通过对买卖订单进行撮合最后形成交易记录。所以对无法立刻完成撮合的订单,需要有买入队列和卖出队列保存订单。队列按照“价格优先、同价格下时间优先”的原则。买入队列按照委托价格从低到高的顺序,卖出队列则按照委托价格从低到高的顺序排列,如图 2.2.2撮合顺序撮合引擎接收到新的买入订单,则会到卖出队列的头部查找是否存在符合价格规则的卖出订单,如果存在卖出价格小于或等于买入价格的订单,则从队列中取出此订单并撮合成一笔交易;如果卖出队列为空或队列头部不满足价格关系,则将买入订单插入买入队列中,由于买入队列是按照价格与时间先后进行排序,所以新插入的订单会经过一次排序插入到买入队列的相应位置。 相同的,当撮合引擎接收到新的卖出订单,则会到买入队列的头部査找是否存在符合价格规则的买入订单,如果存在买入价格大于或等于卖出价格的订单,则从订单队列中取出此订单并撮合成一笔交易;如果买入队列为空或队列头部不满足价格关系,则将卖出订单插入到卖出队列中,由于卖出队列也是按照价格与时间先后进行排序的所以新插入的订单会经过一次排序插入到卖出队列的相应位置[23]。 结合买卖订单情况,撮合算法流程如图2.3所示。从图2.3所示的撮合顺序可知,买卖队列的有序性是保证撮合顺序的确定性的基础,并且撮合过程中每笔订单都可以撮合出当前最优交易。 2.3 内存撮合当前的数据库撮合技术的性能低下的原因在于过多与数据库交互,使得I/O很多,系统整体处理速度同时受数据库事务逻辑约束。 本文釆用内存撮合技术,通过最大程度去除与数据库的交互过程,将整个错和逻辑放在内存中进行(如图2.4所示)。因此比数据库撮合技术少了许多I/O交S间,在性能上可以大幅提升撮合速度;例是内存撮合的弊端就是由于内存的易失性,.?服务器出现故障停机时,所有的交易数据将会丢失,系统的可靠性以及一致性都相应人幅降低。因此本文在提高内存撮合技术可靠性的方面采用丫多机热备份及分布式一致性技术作为补充,从而获得内存撮合技术的高性能以及数据库撮合技术的数据持久性。 2.4 多机热备份由于内存撮合技术在撮合引攀出现异常时的可靠性和一致性非常差,而金融交场系统因为其业务特性,对服务小断以及数据丢失的容忍度非常低,提高容错性,一般多采取的是多机热条份技术。本文采用多机热备份技术,将一组撮合引樂部署成互为备份的撮合引擎集群,并且在同一时间内只有一台撮合引擎提供服务。当-其中运行这的一台撮六引擎出现故障无法继续正常工作 ,撮合引擎集群会迅速检测到这个故障,并选举出一个备份撮合引擎接管故障撮合引舉的任务从而保证整个撮合系统的正常运行多机热备份技术的本质就足针对服务器临时故障所做的一种备份技术,本文迎过采用多机热备份技术,来避免长 间的撮合服务中断,保证撮合系统长期、可靠的服务。如阁2.5所示,通过将多台撮合引擎进行热格份,从而保证在撮合引擎出现故障时,会在可以接受的时间内完成主机和备机之间的切换,由备份机提供无缝连续服务。 通过釆用多机热备份技术,降低了单一内存撮合引擎故障时系统不可用的问题,但仍旧无法提供100%的可用性,因为当出现大规模服务器集群故障时,仍旧存在服务不可用的可能性,但在实际生产环境中,三台互为备份的服务器就可以提供较高的可以用于生产环境的可靠性。 2.5 内存状态机复制由于多机热备份技术引入了多台互为热备份的撮合引擎,根据撮合系统设计以及撮合逻辑要求,需要保证服务器之间的数据一致,这就需要保证多服务器之间一致性,这也是本文难点之一。 本文提出一种内存状态机复制方案,即将撮合算法视作一个确定性状态机,将其复制多份并部署到撮合系统中的多台撮合引擎中。每个撮合引擎副本从相同的初始状态开始运行,当撮合系统收到网关发来的订单时,系统中的每个撮合引擎都会撮合这个订单,并依次产生交易记录,同时更新确定性撮合算法状态机的独立状态。通过这样的方式,当撮合系统正常运转时,每个撮合引擎副本都会具有相同的结果状态;当撮合系统出现故障或异常时,撮合引擎就会出现状态的不一致情况,换句话说一旦撮合系统的结果或状态出现了不一致的情况就可以断定系统出现了异常。 2.5.1关键技术点本文为了实现这样的内存状态机复制撮合系统,将撮合系统划分为以下组成关键技术点： 将确定性撮合算法状态机服务部署到多个独立撮合引擎 接收网关订单,并作为确定性撮合算法状态机的输入 根据撮合算法需求,选择一种订单排序方式 每个撮合引擎对按照排序方式排序过的订单进行撮合 将确定性撮合算法状态机输出的交易记录作为给用户或数据库的响应 监控撮合引擎副本的状态或输出的差别 2.5.2实现方案为实现基于内存状态机复制的撮合系统,本文主要通过以下方案实现状态机复制的关键技术点: 采用原子多播解决撮合引擎订单的可靠多播与全局有序性 采用基于无锁订单队列的流水线撮合技术提供快速的订单撮合 采用异步一致性持久化技术实现与数据库的交互 采用失效备援技术对撮合引擎集群进行状态监控并保证系统的容错能; 采用进度追赶技术解决将故障撮合引擎的恢复或新撮合引擎的加入 2.6 系统架构2.6.1系统硬件体系架构典型的高可靠高性能撮合模型硬件架构如图2.6所示,系统由n台客户端、N台网关、X个产品集群(每个集群由2至3台撮合引擎组成,负责响应产品订单的处理)、一个交易记录数据库和可选的监视系统组成。其中客户端连接到相应网关,网关负责接收客户端提交的订单,并根据订单相关的金融产品类别,转发到相对应的产品集群。产品集群中所有撮合引擎均接收网关发送的订单,根据撮合业务规则,将其撮合并回馈消息给网关和客户端,同时将撮合生成的交易记录持久化到交易记录数据库中。 通过对产品集群进行扩充,增加撮合引擎数量,可以增强产品集群的可靠性。将不同金融产品转发到不同的撮合产品集群中可以实现多产品高效并行撮合。 2.6.2 系统软件体系架构 如图2.7所示,高可靠高性能撮合模型主要由表示层、转发层、业务层和数据层组成。其核心部分业务层主要由撮合引擎集群组成,每个撮合引擎采用原子多播将订单定序后进行撮合处理,并结合无锁订单队列实现高效流水线撮合,最后结果写入本地日志。整个业务流程由消息传递总线将消息反馈给转发层。转发层则根据产品转发规则将订单转发给相应撮合引擎集群;而撮合引擎将本地日志中的交易记录读取到异步持久化代理进程中,并进而与数据层的异步持久化写入进程通信,并最终持久化到数据库中。本地日志增强了撮合系统数据的可靠性,在出现故障后,数据仍就可以从本地日志中恢复;而界步的持久化机制则提高了数据的持久化吞吐率。 2.6.3撮合引擎架构 为了使系统可扩展易维护,撮合引擎由原子多播订单定序模块、撮合处理器模块、交易记录日志模块和内存数据组成,每个模块根据功能业务划分。其中各部分主要有以下功能:交易订单接收线程:负责从网关接收订单,并完成原子多播定序流程。交易订单发送线程:将定序完成的订单发送给相关撮合业务线程。交易信息发送线程:将订单交易状态反馈给网关。外围业务逻辑线程:进行撮合数据的准备处理,更新内存订单数据。撮合业务逻辑线程:根据确定性撮合算法撮合接收的订单。交易行情发布线程:处理内存行情信息并发布给网关。同步日志写线程:将订单撮合产生的交易记录同步持久化到本地日志文件。异步持久化代理进程:异步将日志文件中的数据读取并持久化到数据库。订单信息:存储订单的相关价格、数量、用户、限制、类型和状态等信息交易行情信息:撮合交易过程中的交易行情信息。 2.6.4系统接口撮合系统主要为使用者提供订单的下单和查询服务、交易行情的实时反馈功能以及系统状态的监控查看服务。因此系统需要实现预留的接口主要包括:下单接口、订单查询接口、行情查询接口、系统控制接口和运行状态查询接口等。 2.7 小节从总体设计入手,将撮合业务处理从数据库迁移至内存中,同时釆用多机热备份技术解决内存撮合技术的易失性问题,最终提出内存状态机复制方案作为高可靠髙性能撮合系统的实现路线。撮合技术的具体实现将在下一章进行详细论述。 ###FAQ Q：热备的机制上。多个机器内存上的状态如何保证强一致性的？ A： 是热备机器都是无状态，普洱茶按照不同品种产生不同撮合序列，只要保证单品种有序，其他撮合机和本机没有关系。 Q: 如果新加入一台撮合引擎，怎么判断所有的撮合数据都同步到了这台新的引擎上？ A: 委托单先要写raid文件系统，新增撮合引擎，也可以拿到数据。 Q: 根据你的描述，一个集群中为了判断撮合引擎是否有故障，至少应该有3台撮合引擎吧? A: zk来管理，并且有风控进程监控撮合进度。 Q: 内存状态机的复制究竟是结果还是数据？ A: 数据，就是把处理到某个状态的数据复制出来。 Q: 如果只有两台撮合引擎，如果对一个买入订单，发现结果不一致，如何判断是哪一台的故障？ A: 撮合只有一台进行撮合，撮合结束才回写数据库产生行情和分发个个终端，用户就可以看到自己委托单是否成交。 【1】简书主页·share猿【2】掘金主页·share猿【3】撮合系统· 李伟山【4】撮合系统·技术方舟【5】交易所视角下的套利指令撮合机制 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"交易所","slug":"交易所","permalink":"https://lywlefan.github.io/tags/交易所/"},{"name":"撮合","slug":"撮合","permalink":"https://lywlefan.github.io/tags/撮合/"}]},{"title":"2.disruptor应用","date":"2019-06-25T16:00:00.000Z","path":"2019/06/26/高并发/disruptor学习/2.disruptor应用/","text":"disruptor号称能够在一个线程里每秒处理6百万订单,业务逻辑处理器完全是运行在内存中，使用事件源驱动方式。 本节导航 Disruptor核心链路场景应用讲解 并行计算- 串行操作 并行计算- 并行操作 并行计算- 多遍形高端操作 并行计算- 多生产者消费模型 并行计算- 多消费者消费模型 Disruptor核心链路场景应用讲解概念啥是核心链路?就拿京东来说,下单支付就是核心链路,物流也是核心链路. 核心链路特点 代码复杂 业务逻辑复杂 如何实现 传统完全解耦的方式 模板模式 使用框架 有限状态机框架：Spring-StateMachine 使用Disruptor 参考文档 【1】简书主页·share猿 【2】掘金主页·share猿 【3】disruptor官网 【4】JAVA CAS原理深度分析 【5】并发框架Disruptor译文 【6】从构建分布式秒杀系统聊聊Disruptor高性能队列 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"并发","slug":"并发","permalink":"https://lywlefan.github.io/tags/并发/"},{"name":"disruptor","slug":"disruptor","permalink":"https://lywlefan.github.io/tags/disruptor/"}]},{"title":"1.disruptor初识","date":"2019-06-25T16:00:00.000Z","path":"2019/06/26/高并发/disruptor学习/1.disruptor初识/","text":"disruptor号称能够在一个线程里每秒处理6百万订单,业务逻辑处理器完全是运行在内存中，使用事件源驱动方式。 要学的概念乐观锁打个比方理解乐观锁就是到桥头再看有没有车来过此桥,没有的话快速过桥. 悲观锁打个比方理解悲观锁说白了就是先发制人,我的车要过桥,但是我担心桥上有其他车,所以我提前把桥口加一个锁,我到桥头了在开锁过桥,过去了再把锁子接触了. 死锁打个比方理解简单的比方,两俩车同时过一个桥,不能倒车,如果两辆车同时在桥上就会造成死锁,车就相当于我们的线程,桥就相当于资源. CASCAS简介谷歌翻译CAS是比较并转换,java.util.concurrent包中借助CAS实现了区别于synchronouse同步锁的一种乐观锁。 CAS应用CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。 非阻塞算法 （nonblocking algorithms） 一个线程的失败或者挂起不应该影响其他线程的失败或挂起的算法。 CAS原理CAS通过调用JNI的代码实现的。JNI:Java Native Interface为JAVA本地调用，允许java调用其他语言而compareAndSwapInt就是借助C来调用CPU底层指令实现的。 CAS缺点 ABA问题 循环时间长开销大 只能保证一个共享变量的原子操作 缓存行初识性能 一个线程每秒处理6百万订单 内存中运行 ,使用事件源驱动方式 业务逻辑处理核心Disruptor hello world 建立一个event类,用于创建Event类实例对象 需要有一个监听事件类,用于处理数据(Event类) 实例化Disruptor实例,配置一系列参数,编写Disruptor核心组件 编写生产者组件,向Disruptor容器中去投递数据 核心讲解 RingBuffer基于数组的缓存实现,也是创建sequencer与定义WaitStrategy的入口 RingBuffer拥有一个序号,这个需要指向数组中下一个可用的元素 收尾相接的环 (环状数组) 假如缓存区芝麻满了,芝麻扔到哪里? 假如缓存区没芝麻了,如何取芝麻? 2的n次方更利于计算 Disruptor持有RingBuffer、消费者线程池Executor、消费者集合ConsumerRepository等引用. Sequence 通顺序递增的序号来编号,管理进行交换的数据(事件) 对数据(事件)的处理过程总是沿着序号逐个递增处理 一个Sequence用于跟踪标识某个特定的事件处理者(RingBuffer/Producer/Consumer)的处理进度 Sequence可以看成是一个AtomicLong用于标识进度 还有另外一个目的就是防止不同Sequence之间CPU缓存伪共享(Flase Sharing)的问题 Sequencer Sequencer是Disruptor的真正核心,包含Sequence 此接口有两个实现类 SingleProducerSequencer MultiProducerSequencer 主要实现生产者和消费者之间快速、正确的传递数据并发算法 Sequence Barrier 用于保持RingBuffer的Main Published Sequence(Producer)和Consumer之间平衡关系; 决定Consumer是否还有可处理事件逻辑 WaitStrategy 决定一个消费者将如何等待生产者将Event置入Disruptor 主要策略 BlockWaitStrategy 最低效策略 cpu消耗最小 在各种不同部署环境中提供更加一致性能表现 SleepingWaitStrategy 和上面性能差不多 cpu性能和上面差不多 对生产者线程影响最小,适合用于异步日志类似的场景 YieldingWaitStrategy 性能最好 适用低延迟系统 要求极高性能 要求极高性能且事件处理线数小于CPU逻辑核心数场景,列如:CPU开启超线程的特性 Event 从生产者到消费者过程中所处理的数据单元 Disruptor中没有代码表示Event,因为它完全是由用户定义的 EventProcessor 主要事件循环,处理Disruptor中的Event,拥有消费者Sequence 他是一个实现类是BatchEventProcessor,包含了event loop有效的实现,并且将回调一个EventHandler接口的实现对象. EventHandler 由用户并且代表了Disruptor中的一个消费者接口,也就是我们消费者逻辑都要写到这里. WorkProcessor 确保每个sequence只被一个processor消费,在同一个WorkPool中处理多个WorkProcessor不会消费同样的sequence 参考文档 【1】简书主页·share猿 【2】掘金主页·share猿 【3】disruptor官网 【4】JAVA CAS原理深度分析 【5】并发框架Disruptor译文 【6】从构建分布式秒杀系统聊聊Disruptor高性能队列 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"并发","slug":"并发","permalink":"https://lywlefan.github.io/tags/并发/"},{"name":"disruptor","slug":"disruptor","permalink":"https://lywlefan.github.io/tags/disruptor/"}]},{"title":"自定义线程池","date":"2019-06-25T16:00:00.000Z","path":"2019/06/26/基础巩固/java/线程/自定义线程池/","text":"万丈高楼平地起的前提是地基好. 为什么要定义线程池??如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？在Java中可以通过线程池来达到这样的效果。首先我们从最核心的ThreadPoolExecutor类中的方法讲起。 进一步学习实现原理java.uitl.concurrent.ThreadPoolExecutor类是线程池中最核心的一个类，因此如果要透彻地了解Java中的线程池，必须先了解这个类。下面我们来看一下ThreadPoolExecutor类的具体实现源码。 在ThreadPoolExecutor类中提供了四个构造方法： 1234567891011121314151617181920212223242526272829public class ThreadPoolExecutor extends AbstractExecutorService &#123; ..... public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue); public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory); public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler); public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler); ...&#125; 从上面的代码可以得知，ThreadPoolExecutor继承了AbstractExecutorService类，并提供了四个构造器，事实上，通过观察每个构造器的源码具体实现，发现前面三个构造器都是调用的第四个构造器进行的初始化工作。 下面解释下一下构造器中各个参数的含义： corePoolSize：核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中； maximumPoolSize：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程； keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0； unit：参数keepAliveTime的时间单位 workQueue：一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择： ArrayBlockingQueue; LinkedBlockingQueue; SynchronousQueue; threadFactory：线程工厂，主要用来创建线程； handler：表示当拒绝处理任务时的策略，默认有以下四种取值： ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程） ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 线程池执行的流程当任务提交给ThreadPoolExecutor 线程池中，先检查核心线程数是否已经全部使用，如果没有交由核心线程去执行任务，如果核心线程数已经全部占用，则将任务添加到队列里面，如果队列已经占满，比较当前线程池的中线程的数量是不是与超过maximumPoolSize，如果没有查过则创建线程去执行，也就是说线程池最多可以接受多少任务呢？就是maximumPoolSize+队列的大小。当线程池中的线程的数量大于corePoolSize数量有空闲线程则执行回收，回收时间是keepAliveTime，单位是unit，都是初始化的时候设置的。 下面通过代码来说明： 定义一个实现了Runnable接口的类，当作任务类； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class MyTask implements Runnable &#123; private int taskId; private String taskName; public int getTaskId() &#123; return taskId; &#125; public void setTaskId(int taskId) &#123; this.taskId = taskId; &#125; public String getTaskName() &#123; return taskName; &#125; public void setTaskName(String taskName) &#123; this.taskName = taskName; &#125; public MyTask(int taskId, String taskName) &#123; this.taskId = taskId; this.taskName = taskName; &#125; @Override public void run() &#123; System.out.println(\"taskId:\" + taskId + \",taskName:\" + taskName); try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"基础","slug":"基础","permalink":"https://lywlefan.github.io/tags/基础/"},{"name":"线程","slug":"线程","permalink":"https://lywlefan.github.io/tags/线程/"},{"name":"线程池","slug":"线程池","permalink":"https://lywlefan.github.io/tags/线程池/"}]},{"title":"环形缓冲区","date":"2019-06-24T16:00:00.000Z","path":"2019/06/25/基础巩固/java/数据结构/环形缓冲区/","text":"万丈高楼平地起的前提是地基好. 环形缓冲区介绍圆形缓冲区（circular buffer），也称作圆形队列（circular queue），循环缓冲区（cyclic buffer），环形缓冲区（ring buffer），是一种数据结构用于表示一个固定尺寸、头尾相连的缓冲区，适合缓存数据流。 用法圆形缓冲区的一个有用特性是：当一个数据元素被用掉后，其余数据元素不需要移动其存储位置。相反，一个非圆形缓冲区（例如一个普通的队列）在用掉一个数据元素后，其余数据元素需要向前搬移。换句话说，圆形缓冲区适合实现先进先出缓冲区，而非圆形缓冲区适合后进先出缓冲区。 圆形缓冲区适合于事先明确了缓冲区的最大容量的情形。扩展一个圆形缓冲区的容量，需要搬移其中的数据。因此一个缓冲区如果需要经常调整其容量，用链表实现更为合适。 写操作覆盖圆形缓冲区中未被处理的数据在某些情况下是允许的。特别是在多媒体处理时。例如，音频的生产者可以覆盖掉声卡尚未来得及处理的音频数据。 工作过程一个圆形缓冲区最初为空并有预定的长度。例如，这是一个具有七个元素空间的圆形缓冲区，其中底部的单线与箭头表示“头尾相接”形成一个圆形地址空间： 假定1被写入缓冲区中部（对于圆形缓冲区来说，最初的写入位置在哪里是无关紧要的）： 再写入2个元素，分别是2 &amp; 3 — 被追加在1之后： 如果两个元素被处理，那么是缓冲区中最老的两个元素被卸载。在本例中，1 &amp; 2被卸载，缓冲区中只剩下3: 如果缓冲区中有7个元素，则是满的： 如果缓冲区是满的，又要写入新的数据，一种策略是覆盖掉最老的数据。此例中，2个新数据— A &amp; B — 写入，覆盖了3 &amp; 4: 也可以采取其他策略，禁止覆盖缓冲区的数据，采取返回一个错误码或者抛出异常。 最终，如果从缓冲区中卸载2个数据，不是3 &amp; 4 而是 5 &amp; 6 。因为 A &amp; B 已经覆盖了3 &amp; 4： 圆形缓冲区工作机制由于计算机内存是线性地址空间，因此圆形缓冲区需要特别的设计才可以从逻辑上实现。 读指针与写指针一般的，圆形缓冲区需要4个指针： 在内存中实际开始位置； 在内存中实际结束位置，也可以用缓冲区长度代替； 存储在缓冲区中的有效数据的开始位置（读指针）； 存储在缓冲区中的有效数据的结尾位置（写指针）。 读指针、写指针可以用整型值来表示。 下例为一个未满的缓冲区的读写指针： 下例为一个满的缓冲区的读写指针： 区分缓冲区满或者空缓冲区是满、或是空，都有可能出现读指针与写指针指向同一位置： 250px有多种策略用于检测缓冲区是满、或是空. 总是保持一个存储单元为空缓冲区中总是有一个存储单元保持未使用状态。缓冲区最多存入个数据。如果读写指针指向同一位置，则缓冲区为空。如果写指针位于读指针的相邻后一个位置，则缓冲区为满。这种策略的优点是简单、鲁棒；缺点是语义上实际可存数据量与缓冲区容量不一致，测试缓冲区是否满需要做取余数计算。 使用数据计数这种策略不使用显式的写指针，而是保持着缓冲区内存储的数据的计数。因此测试缓冲区是空是满非常简单；对性能影响可以忽略。缺点是读写操作都需要修改这个存储数据计数，对于多线程访问缓冲区需要并发控制。 镜像指示位缓冲区的长度如果是n，逻辑地址空间则为0至n-1；那么，规定n至2n-1为镜像逻辑地址空间。本策略规定读写指针的地址空间为0至2n-1，其 中低半部分对应于常规的逻辑地址空间，高半部分对应于镜像逻辑地址空间。当指针值大于等于2n时，使其折返（wrapped）到ptr-2n。使用一位表 示写指针或读指针是否进入了虚拟的镜像存储区：置位表示进入，不置位表示没进入还在基本存储区。 在读写指针的值相同情况下，如果二者的指示位相同，说明缓冲区为空；如果二者的指示位不同，说明缓冲区为满。这种方法优点是测试缓冲区满/空很简 单；不需要做取余数操作；读写线程可以分别设计专用算法策略，能实现精致的并发控制。 缺点是读写指针各需要额外的一位作为指示位。 如果缓冲区长度是2的幂，则本方法可以省略镜像指示位。如果读写指针的值相等，则缓冲区为空；如果读写指针相差n，则缓冲区为满，这可以用条件表达式（写指针 == (读指针 异或 缓冲区长度)）来判断。 读/写 计数用两个有符号整型变量分别保存写入、读出缓冲区的数据数量。其差值就是缓冲区中尚未被处理的有效数据的数量。这种方法的优点是读线程、写线程互不干扰；缺点是需要额外两个变量。 记录最后的操作使用一位记录最后一次操作是读还是写。读写指针值相等情况下，如果最后一次操作为写入，那么缓冲区是满的；如果最后一次操作为读出，那么缓冲区是空。 这种策略的缺点是读写操作共享一个标志位，多线程时需要并发控制。 POSIX优化实现Linux内核的kfifo在Linux内核文件kfifo.h和kfifo.c中，定义了一个先进先出圆形缓冲区实现。如果只有一个读线程、一个写线程，二者没有共享的被修改的控制变量，那么可以证明这种情况下不需要并发控制。kfifo就满足上述条件。kfifo要求缓冲区长度必须为2的幂。读、写指针分别是无符号整型变量。把读写指针变换为缓冲区内的索引值，仅需要“按位与”操作：（指针值 按位与 （缓冲区长度-1））。这避免了计算代价高昂的“求余”操作。且下述关系总是成立： 读指针 + 缓冲区存储的数据长度 == 写指针即使在写指针达到了无符号整型的上界，上溢出后写指针的值小于读指针的值，上述关系仍然保持成立（这是因为无符号整型加法的性质）。 kfifo的写操作，首先计算缓冲区中当前可写入存储空间的数据长度：len = min[待写入数据长度, 缓冲区长度 - （写指针 - 读指针）]然后，分两段写入数据。第一段是从写指针开始向缓冲区末尾方向；第二段是从缓冲区起始处写入余下的可写入数据，这部分可能数据长度为0即并无实际数据写入。 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"基础","slug":"基础","permalink":"https://lywlefan.github.io/tags/基础/"},{"name":"数据结构","slug":"数据结构","permalink":"https://lywlefan.github.io/tags/数据结构/"},{"name":"环形缓冲区","slug":"环形缓冲区","permalink":"https://lywlefan.github.io/tags/环形缓冲区/"}]},{"title":"LMAX架构","date":"2019-06-20T16:00:00.000Z","path":"2019/06/21/架构/从100到1000万高并发的架构演进之路/","text":"万丈高楼平地起的前提是地基好. 基本概念在介绍架构之前，为了避免部分读者对架构设计中的一些概念不了解，下面对几个最基础的概念进行介绍。 什么是分布式？系统中的多个模块在不同服务器上部署，即可称为分布式系统，如Tomcat和数据库分别部署在不同的服务器上，或两个相同功能的Tomcat分别部署在不同服务器上。 什么是高可用？系统中部分节点失效时，其他节点能够接替它继续提供服务，则可认为系统具有高可用性。 什么是集群？一个特定领域的软件部署在多台服务器上并作为一个整体提供一类服务，这个整体称为集群。 如Zookeeper中的Master和Slave分别部署在多台服务器上，共同组成一个整体提供集中配置服务。 在常见的集群中，客户端往往能够连接任意一个节点获得服务，并且当集群中一个节点掉线时，其他节点往往能够自动的接替它继续提供服务，这时候说明集群具有高可用性。 什么是负载均衡？请求发送到系统时，通过某些方式把请求均匀分发到多个节点上，使系统中每个节点能够均匀的处理请求负载，则可认为系统是负载均衡的。 什么是正向代理和反向代理？系统内部要访问外部网络时，统一通过一个代理服务器把请求转发出去，在外部网络看来就是代理服务器发起的访问，此时代理服务器实现的是正向代理； 当外部请求进入系统时，代理服务器把该请求转发到系统中的某台服务器上，对外部请求来说，与之交互的只有代理服务器，此时代理服务器实现的是反向代理。 简单来说，正向代理是代理服务器代替系统内部来访问外部网络的过程，反向代理是外部请求访问系统时通过代理服务器转发到内部服务器的过程。 架构演讲纯真年代：单机架构 以淘宝作为例子：在网站最初时，应用数量与用户数都较少，可以把Tomcat和数据库部署在同一台服务器上。浏览器往www.taobao.com发起请求时，首先经过DNS服务器（域名系统）把域名转换为实际IP地址10.102.4.1，浏览器转而访问该IP对应的Tomcat。 架构瓶颈：随着用户数的增长，Tomcat和数据库之间竞争资源，单机性能不足以支撑业务。 第一次演进：Tomcat与数据库分开部署 Tomcat和数据库分别独占服务器资源，显著提高两者各自性能。 架构瓶颈：随着用户数的增长，并发读写数据库成为瓶颈。 第二次演进：引入本地缓存和分布式缓存 在Tomcat同服务器上或同JVM中增加本地缓存，并在外部增加分布式缓存，缓存热门商品信息或热门商品的html页面等。通过缓存能把绝大多数请求在读写数据库前拦截掉，大大降低数据库压力。其中涉及的技术包括：使用memcached作为本地缓存，使用Redis作为分布式缓存，还会涉及缓存一致性、缓存穿透/击穿、缓存雪崩、热点数据集中失效等问题。 架构瓶颈：缓存抗住了大部分的访问请求，随着用户数的增长，并发压力主要落在单机的Tomcat上，响应逐渐变慢。 第三次演进：引入反向代理实现负载均衡 在多台服务器上分别部署Tomcat，使用反向代理软件（Nginx）把请求均匀分发到每个Tomcat中。此处假设Tomcat最多支持100个并发，Nginx最多支持50000个并发，那么理论上Nginx把请求分发到500个Tomcat上，就能抗住50000个并发。 其中涉及的技术包括：Nginx、HAProxy，两者都是工作在网络第七层的反向代理软件，主要支持http协议，还会涉及session共享、文件上传下载的问题。 架构瓶颈：反向代理使应用服务器可支持的并发量大大增加，但并发量的增长也意味着更多请求穿透到数据库，单机的数据库最终成为瓶颈。 第四次演进：数据库读写分离 把数据库划分为读库和写库，读库可以有多个，通过同步机制把写库的数据同步到读库，对于需要查询最新写入数据场景，可通过在缓存中多写一份，通过缓存获得最新数据。其中涉及的技术包括：Mycat，它是数据库中间件，可通过它来组织数据库的分离读写和分库分表，客户端通过它来访问下层数据库，还会涉及数据同步，数据一致性的问题。 架构瓶颈：业务逐渐变多，不同业务之间的访问量差距较大，不同业务直接竞争数据库，相互影响性能。 第五次演进：数据库按业务分库 把不同业务的数据保存到不同的数据库中，使业务之间的资源竞争降低，对于访问量大的业务，可以部署更多的服务器来支撑。这样同时导致跨业务的表无法直接做关联分析，需要通过其他途径来解决，但这不是本文讨论的重点，有兴趣的可以自行搜索解决方案。 架构瓶颈：随着用户数的增长，单机的写库会逐渐会达到性能瓶颈。 第六次演进：把大表拆分为小表 比如针对评论数据，可按照商品ID进行hash，路由到对应的表中存储；针对支付记录，可按照小时创建表，每个小时表继续拆分为小表，使用用户ID或记录编号来路由数据。只要实时操作的表数据量足够小，请求能够足够均匀的分发到多台服务器上的小表，那数据库就能通过水平扩展的方式来提高性能。其中前面提到的Mycat也支持在大表拆分为小表情况下的访问控制。 这种做法显著的增加了数据库运维的难度，对DBA的要求较高。数据库设计到这种结构时，已经可以称为分布式数据库，但是这只是一个逻辑的数据库整体，数据库里不同的组成部分是由不同的组件单独来实现的，如分库分表的管理和请求分发，由Mycat实现，SQL的解析由单机的数据库实现，读写分离可能由网关和消息队列来实现，查询结果的汇总可能由数据库接口层来实现等等，这种架构其实是MPP（大规模并行处理）架构的一类实现。 目前开源和商用都已经有不少MPP数据库，开源中比较流行的有Greenplum、TiDB、Postgresql XC、HAWQ等，商用的如南大通用的GBase、睿帆科技的雪球DB、华为的LibrA等等，不同的MPP数据库的侧重点也不一样，如TiDB更侧重于分布式OLTP场景，Greenplum更侧重于分布式OLAP场景，这些MPP数据库基本都提供了类似Postgresql、Oracle、MySQL那样的SQL标准支持能力，能把一个查询解析为分布式的执行计划分发到每台机器上并行执行，最终由数据库本身汇总数据进行返回，也提供了诸如权限管理、分库分表、事务、数据副本等能力，并且大多能够支持100个节点以上的集群，大大降低了数据库运维的成本，并且使数据库也能够实现水平扩展。 架构瓶颈：数据库和Tomcat都能够水平扩展，可支撑的并发大幅提高，随着用户数的增长，最终单机的Nginx会成为瓶颈。 第七次演进：使用LVS或F5来使多个Nginx负载均衡 由于瓶颈在Nginx，因此无法通过两层的Nginx来实现多个Nginx的负载均衡。图中的LVS和F5是工作在网络第四层的负载均衡解决方案，其中LVS是软件，运行在操作系统内核态，可对TCP请求或更高层级的网络协议进行转发，因此支持的协议更丰富，并且性能也远高于Nginx，可假设单机的LVS可支持几十万个并发的请求转发；F5是一种负载均衡硬件，与LVS提供的能力类似，性能比LVS更高，但价格昂贵。由于LVS是单机版的软件，若LVS所在服务器宕机则会导致整个后端系统都无法访问，因此需要有备用节点。可使用keepalived软件模拟出虚拟IP，然后把虚拟IP绑定到多台LVS服务器上，浏览器访问虚拟IP时，会被路由器重定向到真实的LVS服务器，当主LVS服务器宕机时，keepalived软件会自动更新路由器中的路由表，把虚拟IP重定向到另外一台正常的LVS服务器，从而达到LVS服务器高可用的效果。 此处需要注意的是，上图中从Nginx层到Tomcat层这样画并不代表全部Nginx都转发请求到全部的Tomcat，在实际使用时，可能会是几个Nginx下面接一部分的Tomcat，这些Nginx之间通过keepalived实现高可用，其他的Nginx接另外的Tomcat，这样可接入的Tomcat数量就能成倍的增加。 架构瓶颈：由于LVS也是单机的，随着并发数增长到几十万时，LVS服务器最终会达到瓶颈，此时用户数达到千万甚至上亿级别，用户分布在不同的地区，与服务器机房距离不同，导致了访问的延迟会明显不同。 第八次演进：通过DNS轮询实现机房间的负载均衡 在DNS服务器中可配置一个域名对应多个IP地址，每个IP地址对应到不同的机房里的虚拟IP。当用户访问www.taobao.com时，DNS服务器会使用轮询策略或其他策略，来选择某个IP供用户访问。此方式能实现机房间的负载均衡，至此，系统可做到机房级别的水平扩展，千万级到亿级的并发量都可通过增加机房来解决，系统入口处的请求并发量不再是问题。 架构瓶颈：随着数据的丰富程度和业务的发展，检索、分析等需求越来越丰富，单单依靠数据库无法解决如此丰富的需求。 第九次演进：引入NoSQL数据库和搜索引擎等技术 当数据库中的数据多到一定规模时，数据库就不适用于复杂的查询了，往往只能满足普通查询的场景。对于统计报表场景，在数据量大时不一定能跑出结果，而且在跑复杂查询时会导致其他查询变慢，对于全文检索、可变数据结构等场景，数据库天生不适用。因此需要针对特定的场景，引入合适的解决方案。如对于海量文件存储，可通过分布式文件系统HDFS解决，对于key value类型的数据，可通过HBase和Redis等方案解决，对于全文检索场景，可通过搜索引擎如ElasticSearch解决，对于多维分析场景，可通过Kylin或Druid等方案解决。 当然，引入更多组件同时会提高系统的复杂度，不同的组件保存的数据需要同步，需要考虑一致性的问题，需要有更多的运维手段来管理这些组件等。 架构瓶颈：引入更多组件解决了丰富的需求，业务维度能够极大扩充，随之而来的是一个应用中包含了太多的业务代码，业务的升级迭代变得困难。 第十次演进：大应用拆分为小应用 按照业务板块来划分应用代码，使单个应用的职责更清晰，相互之间可以做到独立升级迭代。这时候应用之间可能会涉及到一些公共配置，可以通过分布式配置中心Zookeeper来解决。 架构瓶颈：不同应用之间存在共用的模块，由应用单独管理会导致相同代码存在多份，导致公共功能升级时全部应用代码都要跟着升级。 第十一次演进：复用的功能抽离成微服务 如用户管理、订单、支付、鉴权等功能在多个应用中都存在，那么可以把这些功能的代码单独抽取出来形成一个单独的服务来管理，这样的服务就是所谓的微服务，应用和服务之间通过HTTP、TCP或RPC请求等多种方式来访问公共服务，每个单独的服务都可以由单独的团队来管理。此外，可以通过Dubbo、SpringCloud等框架实现服务治理、限流、熔断、降级等功能，提高服务的稳定性和可用性。 架构瓶颈：不同服务的接口访问方式不同，应用代码需要适配多种访问方式才能使用服务，此外，应用访问服务，服务之间也可能相互访问，调用链将会变得非常复杂，逻辑变得混乱。 第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异 通过ESB统一进行访问协议转换，应用统一通过ESB来访问后端服务，服务与服务之间也通过ESB来相互调用，以此降低系统的耦合程度。 这种单个应用拆分为多个应用，公共服务单独抽取出来来管理，并使用企业消息总线来解除服务之间耦合问题的架构，就是所谓的SOA（面向服务）架构，这种架构与微服务架构容易混淆，因为表现形式十分相似。 个人理解，微服务架构更多是指把系统里的公共服务抽取出来单独运维管理的思想，而SOA架构则是指一种拆分服务并使服务接口访问变得统一的架构思想，SOA架构中包含了微服务的思想。 架构瓶颈：业务不断发展，应用和服务都会不断变多，应用和服务的部署变得复杂，同一台服务器上部署多个服务还要解决运行环境冲突的问题，此外，对于如大促这类需要动态扩缩容的场景，需要水平扩展服务的性能，就需要在新增的服务上准备运行环境，部署服务等，运维将变得十分困难。 第十三次演进：引入容器化技术实现运行环境隔离与动态服务管理 目前最流行的容器化技术是Docker，最流行的容器管理服务是Kubernetes(K8S)，应用/服务可以打包为Docker镜像，通过K8S来动态分发和部署镜像。Docker镜像可理解为一个能运行你的应用/服务的最小的操作系统，里面放着应用/服务的运行代码，运行环境根据实际的需要设置好。把整个“操作系统”打包为一个镜像后，就可以分发到需要部署相关服务的机器上，直接启动Docker镜像就可以把服务起起来，使服务的部署和运维变得简单。 在大促的之前，可以在现有的机器集群上划分出服务器来启动Docker镜像，增强服务的性能，大促过后就可以关闭镜像，对机器上的其他服务不造成影响（在第18节之前，服务运行在新增机器上需要修改系统配置来适配服务，这会导致机器上其他服务需要的运行环境被破坏）。 架构瓶颈：使用容器化技术后服务动态扩缩容问题得以解决，但是机器还是需要公司自身来管理，在非大促的时候，还是需要闲置着大量的机器资源来应对大促，机器自身成本和运维成本都极高，资源利用率低。 第十四次演进：以云平台承载系统 系统可部署到公有云上，利用公有云的海量机器资源，解决动态硬件资源的问题，在大促的时间段里，在云平台中临时申请更多的资源，结合Docker和K8S来快速部署服务，在大促结束后释放资源，真正做到按需付费，资源利用率大大提高，同时大大降低了运维成本。 所谓的云平台，就是把海量机器资源，通过统一的资源管理，抽象为一个资源整体，在之上可按需动态申请硬件资源（如CPU、内存、网络等），并且之上提供通用的操作系统，提供常用的技术组件（如Hadoop技术栈，MPP数据库等）供用户使用，甚至提供开发好的应用，用户不需要关系应用内部使用了什么技术，就能够解决需求（如音视频转码服务、邮件服务、个人博客等）。 在云平台中会涉及如下几个概念： IaaS：基础设施即服务。对应于上面所说的机器资源统一为资源整体，可动态申请硬件资源的层面； PaaS：平台即服务。对应于上面所说的提供常用的技术组件方便系统的开发和维护； SaaS：软件即服务。对应于上面所说的提供开发好的应用或服务，按功能或性能要求付费。 至此：以上所提到的从高并发访问问题，到服务的架构和系统实施的层面都有了各自的解决方案。但同时也应该意识到，在上面的介绍中，其实是有意忽略了诸如跨机房数据同步、分布式事务实现等等的实际问题，这些问题以后有机会再拿出来单独讨论。 小结架构的调整是否必须按照上述演变路径进行？不是的，以上所说的架构演变顺序只是针对某个侧面进行单独的改进，在实际场景中，可能同一时间会有几个问题需要解决，或者可能先达到瓶颈的是另外的方面，这时候就应该按照实际问题实际解决。如在政府类的并发量可能不大，但业务可能很丰富的场景，高并发就不是重点解决的问题，此时优先需要的可能会是丰富需求的解决方案。 对于将要实施的系统，架构应该设计到什么程度？对于单次实施并且性能指标明确的系统，架构设计到能够支持系统的性能指标要求就足够了，但要留有扩展架构的接口以便不备之需。对于不断发展的系统，如电商平台，应设计到能满足下一阶段用户量和性能指标要求的程度，并根据业务的增长不断的迭代升级架构，以支持更高的并发和更丰富的业务。 服务端架构和大数据架构有什么区别？所谓的“大数据”其实是海量数据采集清洗转换、数据存储、数据分析、数据服务等场景解决方案的一个统称，在每一个场景都包含了多种可选的技术，如数据采集有Flume、Sqoop、Kettle等，数据存储有分布式文件系统HDFS、FastDFS，NoSQL数据库HBase、MongoDB等，数据分析有Spark技术栈、机器学习算法等。总的来说大数据架构就是根据业务的需求，整合各种大数据组件组合而成的架构，一般会提供分布式存储、分布式计算、多维分析、数据仓库、机器学习算法等能力。而服务端架构更多指的是应用组织层面的架构，底层能力往往是由大数据架构来提供。 有没有一些架构设计的原则？ a. N+1设计：系统中的每个组件都应做到没有单点故障； b. 回滚设计：确保系统可以向前兼容，在系统升级时应能有办法回滚版本； c. 禁用设计：应该提供控制具体功能是否可用的配置，在系统出现故障时能够快速下线功能； d. 监控设计：在设计阶段就要考虑监控的手段； e. 多活数据中心设计：若系统需要极高的高可用，应考虑在多地实施数据中心进行多活，至少在一个机房断电的情况下系统依然可用； f. 采用成熟的技术：刚开发的或开源的技术往往存在很多隐藏的bug，出了问题没有商业支持可能会是一个灾难； g. 资源隔离设计：应避免单一业务占用全部资源； h. 架构应能水平扩展：系统只有做到能水平扩展，才能有效避免瓶颈问题； i. 非核心则购买：非核心功能若需要占用大量的研发资源才能解决，则考虑购买成熟的产品； j. 使用商用硬件：商用硬件能有效降低硬件故障的机率； k. 快速迭代：系统应该快速开发小功能模块，尽快上线进行验证，早日发现问题大大降低系统交付的风险； l. 无状态设计：服务接口应该做成无状态的，当前接口的访问不依赖于接口上次访问的状态。 参考文档 【1】简书主页·share猿 【2】掘金主页·share猿 《新手入门：零基础理解大型分布式架构的演进历史、技术原理、最佳实践》 《腾讯资深架构师干货总结：一文读懂大型分布式系统设计的方方面面》 《一篇读懂分布式架构下的负载均衡技术：分类、原理、算法、常见方案等》 《快速理解高性能HTTP服务端的负载均衡技术原理》 《知乎技术分享：从单机到2000万QPS并发的Redis高性能缓存实践之路》 《达达O2O后台架构演进实践：从0到4000高并发请求背后的努力》 《小米技术分享：解密小米抢购系统千万高并发架构的演进和实践》 《通俗易懂：如何设计能支撑百万并发的数据库架构？》 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"架构发展","slug":"架构发展","permalink":"https://lywlefan.github.io/tags/架构发展/"}]},{"title":"java枚举的总结和学习","date":"2019-06-20T16:00:00.000Z","path":"2019/06/21/基础巩固/java/java枚举的总结和学习/","text":"万丈高楼平地起的前提是地基好. 枚举基础规范 实例常量用大写 enum是个类(特别实用的特性,可以在switch语句中使用) 方法 toString:显示某个实例的名字 ordinal:显示常量的顺序 static values:按枚举常量顺序,产生常量构成的数组. 枚举类可以实现一个接口 使用常量123public enum Color &#123; RED, GREEN, BLANK, YELLOW &#125; switch12345678910111213141516171819enum Signal &#123; GREEN, YELLOW, RED &#125; public class TrafficLight &#123; Signal color = Signal.RED; public void change() &#123; switch (color) &#123; case RED: color = Signal.GREEN; break; case YELLOW: color = Signal.RED; break; case GREEN: color = Signal.YELLOW; break; &#125; &#125; &#125; 构造方法&emsp;&emsp;规定构造方法必须为private修饰符所修饰，也就是说只能在类的内部构造，不能在其他类中通过构造方法新增枚举类型。 在枚举类中创建一个构造函数 123456789@Getter@AllArgsConstructorpublic enum CommonEnum &#123; SUCCESS(\"交易成功\",\"SUCCESS\"); private String name; private String value; &#125; 枚举可以实现一个接口 123456789101112131415161718192021222324252627public interface Behaviour &#123; void print(); String getInfo(); &#125; public enum Color implements Behaviour&#123; RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;, 4); // 成员变量 private String name; private int index; // 构造方法 private Color(String name, int index) &#123; this.name = name; this.index = index; &#125; //接口方法 @Override public String getInfo() &#123; return this.name; &#125; //接口方法 @Override public void print() &#123; System.out.println(this.index+&quot;:&quot;+this.name); &#125; &#125; 使用接口组织枚举12345678public interface Food &#123; enum Coffee implements Food&#123; BLACK_COFFEE,DECAF_COFFEE,LATTE,CAPPUCCINO &#125; enum Dessert implements Food&#123; FRUIT, CAKE, GELATO &#125; &#125; 关于枚举集合的使用&emsp;&msp;java.util.EnumSet和java.util.EnumMap是两个枚举集合。EnumSet保证集合中的元素不重复；EnumMap中的 key是enum类型，而value则可以是任意类型。关于这个两个集合的使用就不在这里赘述，可以参考JDK文档。 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"java","slug":"java","permalink":"https://lywlefan.github.io/tags/java/"},{"name":"基础","slug":"基础","permalink":"https://lywlefan.github.io/tags/基础/"}]},{"title":"LMAX架构","date":"2019-06-20T16:00:00.000Z","path":"2019/06/21/架构/LMAX架构/LMAX架构/","text":"万丈高楼平地起的前提是地基好. LMAX架构简介 该架构主要基于：Disruptor + In Memory DDD + Event Sourcing 通过高并发框架（Disruptor）实现用户事件的输入和Domain Event的输出； 一个常驻内存的Business Logic Processor（DDD领域模型），它负责在纯内存中处理业务逻辑；关键点：首先确保用户输入事件被持久化到数据库，并定时创建快照，然后在内存中响应事件更改业务对象的状态；因为一切都是在内存中处理，所以没有IO，也不需要数据库事务，非常快； 机器down了怎么办？因为我们首先确保了业务对象的任何状态改变之前先持久化用户输入事件，所以在down机的时候通过事件回溯重新得到最新的业务对象。因为有了快照的保存，所以重建对象也非常快； 该架构的主要观点： 肯定了In-Memory内存模式 + 异步输入与输出事件（Disruptor） + Event Sourcing 架构，LMAX实践也验证了这个架构。这个架构降低复杂性。 LMAX的核心是新型并发框架Disruptor，其核心是根据现代CPU硬件缓存特点发明不同于通用LinkedList或Queue的新型数据结构RingBuffer。 号称并发未来的Actor模型被LMAX团队验证是有瓶颈的。 提出新的并发模型，每个CPU一个线程，多个CPU多个线程并发模式，摒弃了锁模式。 ORM等Hibernate没有完全解决OO的目标，关系数据库的事务也不是最后救命的稻草。LMAX用自己的事件记录的方式实现事务，这也不同于所谓内存事务STM。 架构师要分离关注，一是通过DDD降低业务的复杂性；二是通过技术探索创新，降低技术平台的复杂性，让程序员更多精力投入业务问题解决上。 参考文档 【1】简书主页·share猿 【2】掘金主页·share猿 【3】LMAX架构简介·汤雪华 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"并发","slug":"并发","permalink":"https://lywlefan.github.io/tags/并发/"},{"name":"LMAX","slug":"LMAX","permalink":"https://lywlefan.github.io/tags/LMAX/"}]},{"title":"使用Java8新的时间API使用","date":"2019-06-20T16:00:00.000Z","path":"2019/06/21/基础巩固/java/工具类/使用 Java8 新的时间 API使用/","text":"使用Java8新的时间API使用 【1】简书主页·share猿【2】掘金主页·share猿【3】使用 Java8 新的时间 API·吾辈 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"java","slug":"java","permalink":"https://lywlefan.github.io/tags/java/"},{"name":"基础","slug":"基础","permalink":"https://lywlefan.github.io/tags/基础/"},{"name":"工具类","slug":"工具类","permalink":"https://lywlefan.github.io/tags/工具类/"}]},{"title":"学习的方法论","date":"2019-06-16T16:00:00.000Z","path":"2019/06/17/指导思想/方法论/学习的方法论/","text":"高效学习方法学习要有明确的目的性&emsp;&emsp; 比如我现在要学习java基础,那么我学习java基础的目的性是啥? 给自己提出问题,把似是而非的问题用自己的话能讲清楚,进一步完善自己的基础总结笔记,记住,任何知识不是一蹴而就的,要不断的迭代学习. 学习要有整体规划学习要有一个好的环境,在好的环境下不成长都难 【1】简书主页·share猿【2】掘金主页·share猿【3】JavaGuide·Snailclimb 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"指导思想","slug":"指导思想","permalink":"https://lywlefan.github.io/tags/指导思想/"},{"name":"学习方法","slug":"学习方法","permalink":"https://lywlefan.github.io/tags/学习方法/"}]},{"title":"富爸爸投资指南","date":"2019-06-15T16:00:00.000Z","path":"2019/06/16/读书/归档/2019/7月/富爸爸投资指南/","text":"读书笔记序言10%的人赚了90%的钱 财富是一种思维方式，而不是存在银行里的钱。 税法是不公平的，它由富人制定，为富人服务。如果你想致富，就得利用富人适用的税法 大多数投资者会说：“不要冒险。”而富有的投资者敢于“冒险”。2.大多数投资者强调“多元化”，而富有的投资者强调专注。3.普通投资者尽力最小化债务，而富有的投资者增加对他们有利的债务。4.普通投资者尽力减少支出，而富有的投资者懂得通过增加支出使自己变得更富有。5.普通投资者拥有工作，而富有的投资者创造工作。6.普通投资者拼命工作，富有的投资者工作越来越少，赚钱却越来越多。 谨慎从事，不要冒险’时，富有的投资者却在考虑怎样提高技巧，以冒更多的风险。 当普通投资者想着要减少债务的时候，富有的投资者却在思考如何增加有利的债务。 有的投资者十分注意事物的两面性，普通投资者只看到硬币的一面，而正是普通投资者没有看到的那一面，使普通投资者一直普通，使富有的投资者更加富有。第1章 我该投资什么 第一个100万最难赚，这种说法真的很有道理。 我和迈克做我们现在做的投资是合法的，但你做就是非法的。”富爸爸试图总结。 为什么？”我问。“因为你不够富有，”迈克轻声说，“我们做的投资是只有富人才有资格做的投资。” 那么，因为我不够富有，所以不能跟你们一起投资了，”一阵失神后，我说，“如果我投资你们所投资的项目，就会违法？”富爸爸和迈克点了点头。“在某些情况下是这样的。”迈克补充道。“谁制定的法律？”我问。“联邦政府。”迈克回答。“还有SEC。”富爸爸补充道。“SEC？”我问，“SEC是什么？”“美国证券交易委员会，”富爸爸回答，“它是20世纪30年代，在前总统约翰·肯尼迪的父亲约瑟夫·肯尼迪的主持下创立的。” 我笑是因为SEC在保护公众远离最坏的投资的同时，也使公众与最好的投资无缘。” “因为在现实中坏交易比好交易多得多。如果一个人不够清醒，就会将所有交易无论好坏都看成一样。在众多复杂的投资中分辨出好坏，需要足够成熟的教育和投资经验。成熟意味着你要有这样一种能力：知道什么使一项投资是好投资，使另一项投资变得危险。但多数人都没有这种教育和经验， 本投资仅适用于特许投资者。特许投资者通常应具备下列条件之一：“净资产为100万美元或以上；“在最近几年中每年收入20万美元或以上（或一对夫妇年收入30万美元或以上）并在今后几年能保持此收入水平。” 特许投资者的概念是用于定义因为有钱而具有投资资格的人，所以特许投资者通常也被称为合格投资者。”富爸爸解释道，“但光有钱还称不上是成熟投资者。” “成熟投资者具备3个E。 1.教育（Education）；2.经验（Experience）；3.充足的现金（Excessive cash）。 回想一下，其实赚100万也并没有多么难，难的是留住这100万，并让它努力为你工作。尽管这么难，我还是得以在1994年我47岁时退休，实现了财务自由，带着足够的钱去享受生活。 去获取3个E：教育、经验和充足的现金。 “正如富人、穷人和中产阶级有不同的房子一样，他们每一种人的投资类型也不同。如果你希望像富人一样投资，就不仅仅要变得富有，还需要成为一个成熟投资者，而不仅仅是一个做投资的富人。” 1.你做好成为投资者的思想准备了吗；2.你想成为哪种类型的投资者；3.怎样建立一家强大的企业；4.谁是成熟投资者；5.财富回馈。 助你反思旧观念，并找到新的致富理念，也许还能成为你生活转变的一个典范。 富爸爸经常说：“你想钱是什么，它就会是什么。” 第2章 为财富奠基他从镇里的穷人区起步，极尽节俭，建立企业，购买地产，按照自己的计划前进。 因为，极少有人有这样的机会来对比两个爸爸的生活道路，然后选择适合自己的道路。这种选择，我不能轻率作出。 原来世上有仅为富人提供的投资，也有为其他人提供的投资 当你作为一个雇员去投资时，大多数投资项目都很昂贵，但如果让你的企业去为你购买这些投资项目，就会容易得多。” 富爸爸和他的银行家、会计师、律师、股票经纪人、房地产经纪人、财务规划师、保险代理人讨论的时候，我就坐在一旁喝着汽水。这是我商业教育的开始。在 学习创立企业，学习通过你的企业去投资。 在一个象限合法的在另一个象限可能不合法 “富人不为钱工作，”我立刻回答，“他们知道怎样让钱为他们工作。” 课程从思想准备和自我控制开始，因为这是让投资产生作用的唯一地方。从根本上说，投资以自我控制开始，也以自我控制结束。 在很多方面，他比我早起步了50年，而我还没有起步。 第3章 投资者第1课：选择对于钱和投资，人们通常有3个基本的原因或选择，它们分别是：1.安全；2.舒适；3.富有。 当谈及金钱时，他们的第一选择是安全，第二选择是舒适，第三选择才是富有。 那些把安全和舒适作为第一和第二选择的人，试图寻找简单、没有风险又舒服的快速致富方法。确实有极少人通过某种幸运的投资致富，但大多数时候，他们只会满盘皆输。” 回到1973年，那时我选择的优先次序是：1.富有；2.舒适；3.安全。 第4章 投资者第2课：你眼中的世界是什么样的不要担心钱的问题，只要做好自己的事，自然会有很多钱。”或者：“不要以没钱为借口而不去争取你想要的东西。” 富爸爸说过：“人们越寻求安全，他们的生活就会越贫乏。” 第5章 投资者第3课：为什么投资常令人困惑富爸爸哈哈大笑，说：“首先，投资对不同的人有不同的意味。这就是投资看起来让人困惑的原因。大多数人的所谓的投资并不是真正的投资。对于投资，人们在谈不同的事物，却还以为是在谈相同的事物。” 第6章 投资者第4课：投资是计划，不是产品或过程投资是计划，不是产品或过程 对你来说，投资是一种计划，一种把你从现在的所在地送到你想到达的地点的计划。 有些人在一种产品和程序上成了专家，这就是我说他们变得依赖于手推车的意思。手推车工作着，拉着大量的现金打转，然而它依然只是手推车。真正的投资者不会依附于某种工具或程序。真正的投资者有一个计划，并且有多种投资工具和程序可以选择。真正投资者想做的事情，是在预定时间内安全地从A地到达B地。他不想拥有或者亲自去推手推车 所以你不必爱上你乘坐的波音747客机，就像你不必爱上你的股票、债券、共同基金或办公大楼一样。它们仅仅是工具，把你送到你想到达的地方而已。”我说。 富爸爸点点头：“我感谢那些工具，我也相信人们会善待那些工具。我只是不想依附于工具，也不想一定要拥有或者花时间操作它们。 事实上，你应该先计划，再投资。千万记住投资是一种计划，而不是某种产品或程序，这是非常重要的一课。” 以意向测试为：1.你是否愿意花时间了解你目前所处的财务阶段和你期望达到的财务目标？你是否愿意仔细考虑一下怎样计划才能实现目标？此外，一定要牢记，只有你写出了计划，并且将它展示给别人看时，计划才是真正意义上的计划。是 否2.你是否愿意与至少一位专业财务顾问会谈，以确定他怎样帮助你制订长期投资计划？是 否你可以与两三位财务顾问会谈，找出他们在制订财务计划方面的不同之处 第7章 投资者第5课：你计划变富还是变穷“如果你想看清一个人的过去、现在和将来，只需要听听他说的话。” “因为只有花钱才能赚钱的观点，是最糟糕的观点之一，特别是对那些想得到更多钱的人来说。”富爸爸说。 富爸爸摇摇头，“赚钱不用花钱。只需要一些我们都能使用的东西，而且比钱的成本小多了。实际上，在很多时候，那甚至是免费的。 “你有商人和投资者的词汇，我爸爸有中学教师的词汇。你使用‘资本化率’、‘财务杠杆’、‘息税前利润’、‘生产价格指数’、‘利润’和‘现金流’等词语，而他使用的是‘考试分数’、‘补助金’、‘语法’、‘文学’、‘政府拨款’、‘长期聘用’等词语。” 富爸爸笑了：“赚钱不用花钱，但要花费语言。富人和穷人的区别就在于他们使用的词汇。一个想致富的人需要做的，就是增加财务词汇。而好消息是，大多数词语是免费的。” 例如，当我投资单户式出租住宅这种小型房地产时，我应该首先增加在该领域的词汇。 富爸爸常说：“不只是不懂得词语的定义，错误使用词语的定义也是引起长期财务困境的真正原因。要破坏一个人的财务稳定，再没有什么比把‘负债’称做‘资产’更厉害了。” 所以富爸爸常说：“赚钱不用花钱。使用富人的词汇就能赚钱，而且更重要的是，还能留住钱。” 如果你富有，就至少应该计划到三代以后。如果你不这样做，钱就会随着你的去世而很快散去。而且，如果你在离开这个世界之前还没有安排好你的钱，那么政府将替你安排。” 不是我们大声说出的话决定了我们的生活，而是我们轻声对自己说的话更有影响力 “词语形成思想，思想形成现实，现实成为生活。 第8章 投资者第6课：计划使你致富大多数自认为是投资者的人，在某一天赚了钱，又会在一周之后赔进去。因此他们没有赔钱，只是没有赚钱。但他们仍然认为自己是投资者。” 巴菲特这样说：“我去市场的唯一目的，是看看有没有人做蠢事。” 但我认为的投资不是这样。对我来说，投资通常是一个枯燥乏味的计划，是一个近乎机械化的致富过程。” “投资仅仅是一个由固定程序和策略组成的计划，是一套致富的系统——这一切几乎能保证你致富。 “因为遵循一个简单的致富计划是一件乏味的事情。”富爸爸说，“人们总是很快厌倦，然后想要找一些更刺激、更有趣的事情做。这就是100个人中只有3个人致富的原因。 相信我，涉及投资时，简单好于复杂。” 如果你有一个简明的策略，并认真执行，投资和致富就会水到渠成。” 在大多数情况下，被动、机械的投资系统会打败由人组成的投资系统——即使是像基金管理人那样的专业投资者也不例外。 科学推理的局限性》一书的作者戴维·福斯特的一句话：“人类的判断力远远小于我们的想象。” 纯机械化的股票选择方式，胜过80%的专业选股人 投资是机械化的自然过程。”或者，你想得越少，风险就越小，就越是高枕无忧，赚的钱却越多。 富爸爸有相似的观点，因此他的公式是：创建自己的企业，通过企业购买房地产和有价证券。这个公式在过去至少200年中都是一个获取财富的制胜公式。 当你背离了简单的计划，改变方向去追逐眼前的诱惑时，灾难就要发生了。 第9章 投资者第7课：你怎样找到适合你的计划保险非常重要，它应该被认真考虑，成为你财务计划的一部分，尤其是在你刚刚起步时。 你希望这份保险永远不要生效。保险就是保内心的宁静。 你的财务团队成员可以包括：1.财务规划师；2.银行经理；3.会计师；4.律师；5.经纪人；6.簿记员；7.保险代理人；8.成功的顾问。 第10章 投资者第8课：现在就决定长大后你想要什么第一步，”富爸爸开始了，“给我的财务顾问打个电话，说‘我想制订一个实现终生财务安全的计划。’”“好的。”我说。“第二步，”富爸爸说，“你写完基本财务计划后，打电话给我，我们讨论一下。就这样吧，再见。” 现在你去找你自己的顾问，写一份实现财务舒适的计划。”富爸爸说,除非我自己很清楚，否则顾问也很难弄清楚并给我提供帮助 富爸爸笑着说，保持年轻的关键，就是在成长时决定你想要什么，然后不断地成长。最可悲的事，莫过于看到人们低估自己在生活中的可能性。他们过着俭朴的生活，精打细算，拼命储蓄，并认为这样才叫有经济头脑。其实，这是财务节制，随着年龄的增长，这会在他们脸上和生活态度上表现出来。 毕竟，爱和尊敬远比金钱重要。 如果你想富有，就需要所有这3种计划。 第11章 投资者第9课：每一种计划都有代价对大多数人来说，代价是用金钱来衡量的。但如果你仔细观察，就会发现代价不是用金钱，而是用时间来衡量的。而且在时间和金钱这两项资产中，时间是最宝贵的。” “与其说是节省时间，不如说是花钱买时间。从你认识到时间的宝贵以及时间也有价格的那一刻开始，你将变得更富有。” 时间，而不是节约时间”这个观念对富爸爸很重要，但对我来说却从未如此重要过。 我仅仅把金钱看做一种交换的媒介。事实上，金钱本身没有多大价值。所以我一有钱，就想用它去交换有价值的东西。可笑的是，把钱看得越重的人，花钱买的东西就越没有价值。这就是他们很穷的原因。 你可以用一套自动的投资系统或计划来实现安全和舒适。 以这种方式投资的人，可能要比自认为是华尔街高手的人强。遵循一个稳定的计划有步骤地进行投资，是大多数人最好的投资方式。 一个人至少应该有一个实现安全或舒适的财务计划。 但请永远记住代价，一项投资越安全，为了赚钱需要花的时间也越多，如果这项投资还能赚钱的话。 第12章 投资者第10课：为什么投资不是冒险象限左侧的人通常从外部投资，而象限右侧的人既能从外部投资，也能从内部投资。 当你在安全和舒适的投资水平上进行投资的时候，外部投资发挥着完美的作用。这就是你把钱交给一位专业人士的原因，你希望他比你更接近内部。但如果你想致富，你就必须比那些受人之托的投资专家们更加接近内部。 “游戏背后的企业才是真正的游戏。不论谁赢谁输、市场是涨是跌，是游戏背后的企业在真正赚钱。这些企业卖出游戏的门票，而不是购买门票。”这就是富爸爸教我的投资游戏，也是本书余下部分要讲述的内容，是投资游戏造就了世界上最富有的人。 第13章 投资者第11课：你想坐在桌子的哪一边穷爸爸总是说：“要努力工作，积极储蓄。”而富爸爸说：“如 果你想要安全和舒适，努力工作和储蓄就很重要。但如果你想富有，努力工作和储蓄或许就不能让你达到目标了。而且，努力工作和储蓄的人通常也是说‘投资很冒险’的人。 他说：“努力工作和储蓄的人要致富很难，因为他们的税负过重。当人们取得收入时，储蓄时，消费时，甚至死亡时，政府都要对他们征税。所以，如果你想致富，就不仅需要努力工作和储蓄，还需要更多的理财智慧。” 富爸爸进一步解释说：“当你存入1000美元时，政府已经征过税了。所以，要储蓄1000美元，你或许得挣1300美元或更多才行。然后，那1000美元还会被通货膨胀蚕食，价值逐年降低。你的那点微薄利息也会被通货膨胀和税收吞噬。所以，假设银行付给你5%的利息，通货膨胀率为4%，利息税为30%，你的最后结果就是损失惨重。” 2.第二个原因是，努力工作和储蓄的人通常认为投资很冒险。这种人常常逃避学习新东西。3.第三个原因是，坚信努力工作和储蓄，并坚信投资有风险的人，很难看到硬币的另一面。 损益表和资产负债表 “我们正进入经济全球化时代。”富爸爸说，“参与全球竞争的公司，需要降低成本。而它们的主要成本之一，就是员工工资和退休基金。你记住我的话，几年之内，企业将把退休金投资的责任转移给员工。” 让I象限成为最重要的象限。长大后，选择做投资者。让钱为你工作，只有这样，当你不想或不能工作的时候，你才可以不去工作。 。我的很多富有的朋友都谈到，他们很小的时候，在决定将来从事什么职业之前，他们的家庭就让他们开始经营一个投资组合，引导他们学习成为一个投资者 第14章 投资者第12课：投资的基本原则投资不是赛跑。你并不是在与别人竞争，竞争者的财务生活一般是大起大落，所以你不要一心想着拿第一。在赚钱方面，你只需努力做一个更好的投资者。如果你作为一个投资者，专注于提升自己的经验和教育，你就会获得巨大的财富 谈到一开始就让迈克选择I象限而不是B或E象限的原因时，富爸爸解释说：“富人的目标就是让钱为他工作，而他自己不必工作。为什么不一开始就瞄准这样的目标呢？你可以一辈子都打高尔夫球，但橄榄球只能打几年，既然如此，为什么不在一开始，就选择与你相伴一生的游戏呢？” 一个是实现安全的计划，一个是实现舒适的计划 与之相反，富爸爸很有钱，会享受生活，这是因为他拥有3种源源不断的收入。 投资的第二个基本原则是要尽可能有效地把你的劳动收入转化为证券收入或被动收入 投资的第三个基本原则就是通过购买证券将劳动收入转化为被动收入或证券收入，以保证劳动收入的安全。” 但在这里我想指出的是，并不像人们所想的那样，所有的证券都是资产。 所以，投资者要分清哪些证券是资产，哪些证券是负债。 我只把证券看做投资工具，作为一个投资者，由我来决定一种证券是资产还是负债。” 投资者本身才是真正的资产或者负债 “怪不得你喜欢听那些投资者抱怨投资损失，”我说，“你是想知道他们错在哪里，看看能否找到一个好机会。” 只有傻瓜才会迷恋那些快速赚钱、瞬间拥有财富的童话，这种故事只能吸引失败者。如果一只股票为众人熟知或者已经赚了很多钱，这时通常盛宴已经结束或者马上就要结束了。我情愿听一些不幸的投资故事，因为那里才有不错的投资机会。作为B象限和I象限的人，我希望能找到还是负债的证券，然后把它们转变为资产，或是持有它们并等待其他人将它们转变为资产。” 要关注其他人正在寻找什么。如果你想买股票，那就参加教你如何选股的培训班。投资房地产也是一样。都要从训练你的大脑知道要寻找什么，以及为瞬间出现的投资项目提前做好准备开始。 如果你是右侧象限的人，你就会有更多的时间和商机，你会信心十足，因为你知道，你能抓住大多数人放弃的坏交易，并把它转化为一个好交易。 除此之外，成为投资高手的另一个基本要求是无论市场上涨还是下跌，都应该随时准备获利 实际上，最好的投资者在市场下跌时反倒能赚更多的钱，因为市场下跌的速度比上涨的速度快。 正如投资高手所言，牛市缓缓来临，而熊市瞬间光顾。如果你无法把握住市场的每一种情况，作为投资者，你就太冒险了，而不是投资本身。 卖空、买方期权、卖方期权、双向期权， 只要知道做好准备比所谓的预测更重要，就足够了。” 你有了教育和经验，并且找到了一笔好买卖，这时，钱就会自动找上门来，或者，你就会找到钱。 如果这笔买卖不佳，要筹钱就的确不容易了。 提到房地产，人们总认为，成功的关键在于房地产的地理位置，除了位置还是位置。 我不这么认为。实际上，在投资领域，不管是房地产、企业或者是证券，成功的关键永远是人，人，人。我曾见过占尽天时地利的房地产赔钱的例子，就是因为由不合适的人在管理它。” SEC 投资者的首要任务是确保他们的钱安全。然后才是尽力把钱转化为现金流或资本收益。 不是投资安全或有风险，而是投资者安全或有风险。 对风险和回报的评估能力。” 要达到富人的投资水平，投资者应具备以下3个E：1.教育；2.经验；3.充足的现金。 KISS”（Keep It Simple，Silly，即傻瓜财务原则）公式， 如果某人不能在两分钟内给你解释清楚一项投资，那么不是你不明白，就是他不明白，或者你们都不明白。无论什么情况，你最好放弃这项投资。 市盈率 资本化率 我常发现，太多的人在还没有雄厚的资金做后盾时，就急于进行富人的投资了。 正如富爸爸所言：“你可以用一生的时间学习投资基础知识。”他的意思是：“投资一开始听起来很复杂，但之后会变得简单。投资越简单化，或者你学的基础知识越多，你就会越富有，同时风险会越小。不过，对大多数人而言，最大的问题还是投入时间。” 第15章 投资者第13课：用财务知识降低风险让事情简单化，懂得做事的基本原则。首先制订你的安全和舒适的投资计划，然后把这些计划交给称职的人，让他们照现成的程序去做。最后，你就得付出代价，从而成为一个赚钱多而风险少的投资者。” 时间是你最重要的资产。如果你不愿意付出时间，那么就把你的资本交给能够按你的投资计划行事的人。许多人梦想致富，但大多数人不愿意付出时间。” 如果你让股市涨跌左右你的生活，你就不是一个投资者。作为一个投资者，你首要的控制是自我控制。如果你不能自我控制，股市的变化就会驾驭你，总有一天你会在股市的起伏里迷失方向。人们做不好投资者，首要原因就是缺乏对自我和感情的控制。 富爸爸滔滔不绝地说着：“如果你想低风险高收益地投资，你就必须付出代价。这种代价就是学习，大量的学习。你需要学习商业基础知识。此外，要成为富有的投资者，你还必须成为一个好的企业主，或者知道企业主知道的知识。 如果你想成为一个富有的投资者，那么这可能是所有投资形式中最好的一种。约有80%的超级富翁是通过创建企业致富的。大多数人都在为创建企业或投资于企业的人打工，然后他们又惊异于雇主的巨额财富。究其原因，那就是企业的创立者把钱变成了资产。” 格雷欣定律 政府发行了带锯齿的货币，足值货币的边缘都有细小的沟槽。 富人用钱购买企业、股票和房地产。他们总在货币价值降低时，寻找更为安全的保障。所以我一直对你和迈克说，‘富人不为钱工作’。如果你想致富，就必须知道良币与劣币、资产和负债之间的区别。” 如果你为劣币拼命工作，而且不知道资产与负债、好证券与坏证券之间的区别，那么你就会一辈子都在财务上苦苦挣扎。 正是由于格雷欣定律的影响，那些工作最辛苦的人才会遭遇最困难的时候。 所以每一个有经济头脑的人都必须不断寻找具有真正价值的、能带来更多钱的东西。如果你不这样做，就永远会在经济上处于落后地位，而不是走在前面。” 所以他一直依赖着工作安全和虚假的资产。而且，他始终没能把劳动收入转化为真正的资产，以获得那些富人的收入，即被动收入或证券收入。 他看到了有钱人左右政治的能量以及他们得到的各种好处，他也知道法律是为维护富人的利益而制定的。我爸爸看到金钱侵入政治中，所以去竞选副州长，试图制止这种不正之风，却付出了失去工作的代价。他知道法律是有利于富人的。 富爸爸说，“IBM和施乐公司都有非常好的销售培训计划。如果你想成为B象限的人，就必须在了解市场的同时懂得如何销售。你还必须有‘厚脸皮’，不介意别人对你说‘不’。而且你要能够用恰当的方法尽力改变他们的想法。对于想致富的人，尤其是想进入B象限和I象限的人来说，销售是一种必要的、基本的技能。 大多数人毕业了就去找工作，而不是寻找机会；他们被教导为劳动收入努力工作，而不是为被动收入或证券收入；他们大多数人连记账都不会，更别提读写财务报表了。所以他们认为投资是冒险也就不奇怪了 只要涉及金钱交易，就会有损益表和资产负债表， 不知道资产与负债之间、劳动收入与被动收入和证券收入之间的区别，也不知道这些收入怎样体现在财务报表上，对你爸爸来说，是一种代价高昂的疏忽 财务知识是基础投资的基础 。当我看到公司的财务报表时，就等于看到了它的内部情况。通过财务报表，我能判断公司的基本面是好还是坏，它是会发展还是会衰落；我还能说出它的管理是否有效，是不是在浪费投资者的钱。对于住宅建筑或办公楼项目，以上方法同样适用。” “首先，财务知识会告诉我们哪些是重要的。我会认真阅读每一行，并考虑哪些是没做好的，或者还能做点什么，以此来完善公司业务，使情况好转。 当我看一项投资时，我会把它放在我的个人财务报表上，看看在哪里合适。我说过，投资是一个计划。 我想知道这项投资是否安全，会不会为我赚钱。我能在短时间内迅速判断这项投资是赚钱还是亏本。要是它不能为我赚钱，或者我找不到让它为我赚钱的方法，那我为什么要投资它呢？那样做就会很冒险。” 极少数成熟的商界人士和投资者知道如何利用政策为自己谋利，但真正做到的人，却寥寥无几。为什么不在赚1美元的同时，从政府那儿再得到30美分的额外奖金呢？这才是真正的投资者要做的事情。” 阅读财务报表是基本原则之一。在富人的投资层次，财务知识绝对是一条重要的投资者基本原则。另一条原则是投资一定要赚钱。 你投资只为一个原因，就是得到一项资产，并用它将劳动收入转化为被动收入或证券收入。这种收入形式的转化是一个真正投资者的首要目标。要达到这个目标，不仅要会平衡支票簿，还需要更高的财务知识水平。” ，”富爸爸说，“这是一场致富的游戏。损益表和资产负债表是首要的两张财务报表，我把这两张财务报表叫做魔毯。” 因为这两张财务报表能神奇地让你看到世界上任何一家企业、任何一项房地产和任何一个国家表面现象背后的东西。就好像潜水时戴上潜水面罩，你就能看清潜藏于水面下的东西一样。 。不断增加财务知识最终能降低投资风险并增加投资回报。 通过财务报表，我能看到普通投资者看不到的东西，同时，我还能掌控自己的经济状况，实现我的人生目标。掌握财务报表还能让我在不在公司的时间里，继续掌握各项业务的运转。真正理解财务报表，是一个S象限的人进入B象限的必要环节之一。正因为如此，我才把财务报表称为魔毯。” 不经训练的眼睛，是无法捕捉到最好的投资机会的 爸爸教导我，作为一个投资者，如果你想赚更多的钱，就必须熟悉财务知识，同时要洞察投资内部的优势和劣势。他说：“绝佳的投资机会来自对会计、税法、商法和公司法的认识和理解，正是在这些无形的领域中，真正的投资者猎取到最大的投资项目。所以，我把损益表和资产负债表称为魔毯。”第16章 投资者第14课：财务知识使事情简单化 爸爸常对我说：“你父亲会陷入经济困境是因为他虽然有文化知识，但缺乏财务知识。如果他肯花点时间学习怎么读数字和金钱词汇，他的生活就会发生巨大的变化。” 很多人在财务上痛苦挣扎，原因就在于他们购买负债，并把负债列于资产栏中。也是因为这个原因，很多人把他们的房子看做资产，而实际上房子在很多时候是一种负债。” 富爸爸强调的是财务知识的重要性。他说：“不要把负债当做资产，即使是你的房子。”读者们下一个问题是：“如果我已偿还了购房贷款，房子是不是就成为资产了？”在多数情况下，对这个问题的答案依旧是否定的，仅仅因为你在房子上不再负债，并不意味着它就一定是资产，你可以在“现金流”这个概念中找到原因。 下面是资产的现金流图。富爸爸是这样定义资产的：能把钱放进你口袋里的东西就是资产。 爸爸同样给负债下了一个定义：把钱从你口袋里取走的东西就是负债。 租金收入和净租金收入之间，关键区别就在‘净’字上。财务报表上这样一个变动就把房子由负债转化成了资产。” 资产不是母鸡本身，而且可以持续下蛋的母鸡 小鸡没有孵出之前不能算数’， 小鸡没有孵出之前不能算数’， 1.为了获得税收减免而甘愿亏损的意识，导致人们在选择投资时很草率。2.有这种意识的人不会努力寻找真正的投资，在分析投资时，也不会仔细研究财务报表。3.亏损会使你的经济状况不稳定。换句话说，投资本身就有了足够的风险，为什么还要冒更多的风险呢？你可以多花一点时间，去寻找一些可靠的投资项目。如果能看懂财务数据，你就能找到它们。4.政府一定会修改法规。5.今天是资产，明天就有可能变成负债。6.1986年在数以百万计的人亏损的同时，也有其他一些投资者为这种变化做好了准备。他们从那些没有准备的投资者手中赚取了巨额利润。 富爸爸说：“普通投资者将还没有孵出的小鸡也计算在内。他们买入让他们每月花钱的东西，然后主观上认为它们是资产，指望他们的房子将来能升值，或者觉得他们的房子一定能按房地产经纪人所说的价格迅速售出。你曾经以低于经纪人告诉你的价格或者以低于银行的估价出售过房屋吗？我有过这样的经历。把财务决策建立在主观臆断或期望之上，必然导致人们对自己的个人财务失去控制。我认为这样做太冒险了。如果你想富有，那么你必须控制你的教育和现金流。只要你现在能够很好地控制你的财务状况，那么期望你的某种东西将来会升值也无可厚非。 普通投资者常常喜欢打如意算盘，或者行事孤注一掷，总是期待好事自来 成熟投资者懂得，财商教育会使你把握住今天，如果你不断学习，还将有助于你更好地把握明天。 正如富爸爸所说：“指数是对普通投资者而言的。一个专业投资者需要的是控制，这种控制从你自身和你的财务知识、信息资源及现金流开始。”所以富爸爸告诫普通投资者：“不要太普通。”对他而言，做一个普通投资者等同于做一个冒险的投资者。 当人们开出支票时，他们是在减少自己的资产。在使用信用卡时，他们在增加自己的负债。换句话说，信用卡使你更容易地深陷债务。 我叫我的税务顾问兼会计师戴安娜·肯尼迪把磁带和笔记作了整理，目的是要你：1.学习个人财务报表的运作原理；2.控制你自己的财务报表；3.走上财务自由之路；4.学习如何像富人一样，通过降低税费来理财。 戴安娜和我制作的这些磁带，有助于你们摆脱债务。然而更重要的是，你将从中学到如何像富人一样理财。这极为重要，因为大多数人认为挣更多钱就可以解决他们的财务问题。 “财务自由入门”这一套带子中 “你要永远记住，你的支出就是别人的收入。无法控制自己现金流的人，使那些能够控制自己现金流的人致富。 这就是你说至少要两张不同的财务报表，才能看到整体财务状况的原因，”我说，“你的每一项支出都是别人的收入，你的每一项负债都是别人的资产。” 人们每次使用信用卡，实际上是在增加自己的负债，同时增加银行资产的原因。” “而一个投资者应该做的是获得别人为你支付的资产 就是投资者拥有出租公寓的原因。每个月都有现金流从房客流入投资者的收入栏，就像他们的抵押贷款流入银行的收入栏一样。” 政府通过税收刺激你去负债，这就是给你税收减免让你去买房子的原因。” 政府因为我们负债而减免我们的税收，因为我们拥有资产而向我们征税？” 普通投资者为负债兴奋不已，获取资产时却没有感觉。” 专业投资者必须超越投资对象价格的涨落。成熟投资者会通过研究数据来了解真实信息，看到普通投资者看不到的情况。 换句话说，你需要两名不同的专业人员才能获得真实信息。好消息是，如果你肯投入时间和精力研究现象背后的细节，那么你会找到投资机遇，从而获得只有极少数人才能发现的巨额财富。 我只知道我想做的是合法地从内部投资，而不是游离于圈外。不管我会不会富有，我只想知道真相，我要知道富人如何致富，以及他们致富的原因。 一个老师必须知道教与学之间的区别，明白哪些能教，哪些要学生亲身实践才能掌握。 他 接着说：“你可以教一个小孩记住‘自行车’这个单词，但你教不了他如何骑自行车，这要他自己通过实践才能学会。” 你阅读的财务报表、年度报告和招股说明书越多，你的理财智慧、财务眼光就会更胜一筹，你就会逐渐发现那些普通投资者难以发现的信息 彼得·林奇 30多年以来，富爸爸一直叫我反复检查财务报表。 当我们学骑自行车的时候，我们必须用心去想怎样骑车。一旦我们学会了，就不必刻意去想或回忆怎样骑车。 好消息是，只要你坚持不懈地练习，这个过程会越来越简单，你的进步会越来越快。 如果你确实想成为一名成功的投资者，使自己多挣钱而少担风险，那么我建议你学着训练自己大脑对财务报表的分析能力。 投入时间持续提升你的财务知识水平。 如果你拥有丰富的财务知识，你就已做好准备来发现世界上最好的投资项目 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"投资","slug":"投资","permalink":"https://lywlefan.github.io/tags/投资/"},{"name":"财商","slug":"财商","permalink":"https://lywlefan.github.io/tags/财商/"}]},{"title":"用得上的商学课-骆骋","date":"2019-06-15T16:00:00.000Z","path":"2019/06/16/读书/归档/2019/6月/用得上的商学课-骆骋/","text":"读书笔记自序你有多久没有投资你自己了？ 傅盛曾在一篇文章中提到，所谓成长，就是认知升级。有一幅认知结构图，说明了人们认知的四种状态。第一种，不知道自己不知道——以为自己什么都知道。这种人占95%。第二种，知道自己不知道——有敬畏之心，有空杯心态。这种人占4%。第三种，知道自己知道——抓住了事物的规律，提升了自己的认知。这种人只有0.9%。1 看得透的用户心理 机会成本我们每天都在做选择，而每个人所拥有的时间、金钱、社会资源都是有限的，所以我们为了得到某一样东西，通常都不得不放弃另外一些东西。在经济学里，这些不得不放弃的东西，就是我们为当前选择所付出的机会成本。 鱼与熊掌不可兼得。放弃的鱼，就是你选择熊掌的代价。 一句话理解比较优势：我做得比你好，也得你来做。应该把事情交给机会成本最低的人去做。 沉没成本人并不总是理性的，在做决策时总会被已经发生的成本影响。经济学上将这种已经发生且无法收回的投入称为沉没成本。 经济学告诉我们，做决策时，不要考虑沉没的成本。 懂得“放弃”比“坚持”更可贵。 沉没成本 只有交55美元成为会员，你才能进入好市多门店，并可享受海量的优质低价商品。这55美元就相当于商家给你制造的一个沉没成本，让你控制不住自己，就算吃不完、用不完，也总想再多买一点儿。消费者的心理是：只有多买，才能把拿不回来的会员费摊薄一点儿。这种想法一旦作祟，商家就可以坐等数钱了。 只有交55美元成为会员，你才能进入好市多门店，并可享受海量的优质低价商品。这55美元就相当于商家给你制造的一个沉没成本，让你控制不住自己，就算吃不完、用不完，也总想再多买一点儿。消费者的心理是：只有多买，才能把拿不回来的会员费摊薄一点儿。这种想法一旦作祟，商家就可以坐等数钱了。 一句话理解沉没成本：因为“来都来了”，所以“将错就错”。 工业经济告诉我们一个规律：生产一件产品，越标准化越好，越流程化越好，款式越少越好，规模越大越好。 边际成本边际成本是生产者理论中的一个概念，是指额外生产一单位产品需要付出的成本。相应地，每多销售一单位产品获取的收益就是边际收益。 一句话理解边际成本：飞机起飞前的座位，甚至可以只卖一元。 因交易行为本身而产生的成本，就是交易成本。 科斯认为，企业的内部交易成本如果高于市场交易成本，企业就不应该内部扩张了，也就是别再雇人做了，而应该更多地寻求外部合作；反过来，如果内部交易成本更低，那么就应该自己雇人做。 丰田一贯推行的看板管理，就是决策流程信息化的典范。 一句话理解交易成本：一个人的世界中不存在的成本，都是交易成本。 第2章 价格，是你想定就能定的吗？ 微观经济·价格 供需定理[插图]经济学告诉我们，产品有价，不是因为制造产品有成本，而是因为市场对产品有需求。产品售价如何，是由市场上供给对于需求的相对稀缺性来决定的。 供需定理是经济学中最基础的概念，相对简单，这里不再赘述，但是学会给定价归因，可以让你对商业有更透彻的理解。以下三点也许能给你一些启示。 第一，找准真实需求。 第二，摸清竞争环境。 第三，垄断更高利润。 一句话理解供需定理：供不应求，价格上涨；供过于求，价格下跌。 需求弹性就是某种商品的需求量对其价格变化所做出的反应程度。 需求弹性商品价格的变化会在不同程度上影响销量，这种价格和销量之间的动态关系，叫作需求价格弹性，简称需求弹性。 从另一个角度来说，当大家都想用低价策略抢夺市场，行业深陷价格战的时候，你的最优策略可能是通过技术创新或效率提升，来优化消费者的体验，提升品牌的附加值，让消费者愿意为你的优质品牌或产品买单。这种做法叫作“差异化战略”。 那如何判断商品需求弹性的大小呢？我建议从以下三个方面入手。 第一，看商品是否属于生活必需品。 第二，看商品是否存在可替代性。 第三，看消费者调整需求的时间。 一句话理解需求弹性：弹性小，我涨价；弹性大，我降价。 沃图（Vertu） 凡勃伦效应凡勃伦效应由美国经济学家凡勃伦[插图]提出。他发现，有的商品价格越高，越能吸引消费者购买。高价不一定代表高品质，但这件商品一定能让购买者自我感觉良好。 商品包含两种价值：一种是功能性价值，一种是炫耀性价值 教你如何让品牌平添奢侈品的基因。 气质这个词我是不赞同的，更准确的说应该是让品牌有高端的文化。 第一，给品牌打造气质。 第一，给品牌打造气质。 第二，给产品增加辨识度。 第三，给用户贴标签。 一句话理解凡勃伦商品：越贵越买，不是“傻”，而是“壕”。 这个故事告诉我们，世界上最好吃的东西，叫作“饿”。 消费者在一段时间内连续消费同一种商品时，所获得的满足感会越来越低 古人云：“入芝兰之室，久而不闻其香。” 边际效用边际效用是指某物品每增加一单位消费量，消费者获得的额外满足程度。 第一，如果你是商家，就要学会利用消费者的“贪得无厌”。 第二，如果你是管理层，就要学会利用员工的“喜新厌旧”。 第三，如果你是单身，找对象时要学会预见自己的“审美疲劳”。 一句话理解边际效用：世界上最好吃的东西，叫作“饿”。 “价格歧视” 价格歧视价格歧视是指针对不同的消费者或者不同的消费场景，设定不同的价格，从而攫取消费者愿意付出的最后一分钱。 要想把价格歧视运用到商业策略中，具体该从什么角度入手？ 第一，划分时间。 第二，区隔地点。 第三，筛选人群。 一句话理解价格歧视：没有看低你，只想“掏空”你。 第3章 博弈，也是有价格的 微观经济·博弈论不怕神一样的对手，就怕猪一样的队友。” 要想摆脱囚徒困境，有以下三种方法。 第一，增加背叛的成本。 第二，引入第三方。 囚徒困境囚徒困境最早是由普林斯顿大学的数学家阿尔伯特·塔克在1950年提出的。它告诉我们，每当个人利益与集体利益发生冲突的时候，足够理性的人会优先追求个人利益，正所谓“人不为己，天诛地灭”。但是，当大家都从利己角度出发的时候，结果却往往是损人不利己。 第三，重复博弈。 一句话理解囚徒困境：背叛，也是有价格的，而聪明人懂得怎样让这个价格高到对方不会背叛。 人质困境在一群人面对威胁或损失时，“第一个采取行动”的决定是最难做出的，因为“出头鸟”往往会付出惨重的代价，因此也有人把人质困境叫作出头鸟困境。 “明哲保身”的人质困境 第一，力挺“出头鸟”。 第二，保护“出头鸟” 第三，奖励“出头鸟” 一句话理解人质困境：出头，也是有价格的。而聪明人懂得怎样让这个价格低到对方愿意出头。 智猪博弈博弈论大师约翰·纳什在1950年提出了著名的智猪博弈模型。他指出，在博弈过程中，无论大猪去不去踩踏板，小猪的最优策略都是等待。 作为市场上处于弱势的“小猪”，我们可以怎样应用智猪博弈？还是老套路，给你三条建议。 第一，有自知之明，不要轻言“教育市场”。 第二，盯紧大猪，它可能是你最好的合作伙伴。 实际上，如果你仔细思考就会知道，滴滴出行的竞争对手从来就不是快的打车，而是传统的出租车公司。两家公司一起“烧钱”，目的就是让消费者了解并接受“用手机叫车”这种消费方式。 神州专车就很聪明，它没有正面参与“烧钱”大战，而是一方面借助互联网专车的风口推广自己的品牌，另一方面将自己定位为高端用车服务，和滴滴出行、快的打车形成差异化。 第三，顺应认知，静静地等待属于自己的风口。 一句话理解智猪博弈：成大事者，有所不为才能有所为。 斗鸡博弈斗鸡博弈指两强相争时，最好的结果应该是：其中的一方进，另一方退，双方达成一种不对等的均衡。换句话说，狭路相逢，该勇则勇，该怂就怂。 比如投资圈的人特别喜欢打德州扑克 那么懂得了斗鸡博弈的道理，遇到两强相争之时，具体该怎么做？还是三种方法，我们一起拆解一下 第一，释放信号，展现决心。 不战而屈人之兵 第二，一方妥协，一方补偿 第三，永远考虑机会成本。 一句话理解斗鸡博弈：狭路相逢，该勇则勇，该怂就怂。 枪手博弈正所谓“木秀于林，风必摧之”，在关系错综复杂的多人博弈中，一位参与者最后能否胜出不仅取决于他自身实力的强弱，更重要的是各方实力的对比关系，以及各方的选择策略。 第一，坐山观虎斗 第二，联吴抗曹。 第三，求“包养 一句话理解枪手博弈：懂得避其锋芒，身为草根也终有“逆袭”之日。 第4章 消费者，从来就不是理性的 消费心理（上）心理账户人们会在心里构建分门别类的账户，不同的账户有不同的记账方式和心理运算规则。 我在这里向你介绍心理账户的三种应用方法。 第一，替换概念。 第二，创造收益。 第三，打包项目 一句话理解心理账户：想让消费者买单，你需要给他一个更容易说服自己的理由 损失规避人们面对同样数量的收益和损失时，损失给人的负面影响，比收益给人的正面影响大很多。 了解了损失规避的原理之后，我们如何将它运用到商业策略中？有三种方法，分别是“避免”、“打消”和“放大” 第一，避免损失描述。 第二，打消损失顾虑。 第三，放大损失感受 一句话理解损失规避：同样一件东西，失去的痛苦大于得到的快乐。 路径依赖人类社会中的技术或制度演变具有惯性，人一旦进入一种行为路径，就会对其产生依赖。 怎样做才能让用户在你这里形成路径依赖？ 第一，补贴策略 第二，任务策略 第三，情境策略 益达的广告语是“饭后嚼两粒”，德芙则是说“下雨天和巧克力更配” 一句话理解路径依赖：习惯，我们每个人或多或少都是它的奴隶。 比例偏见参照对象的变化导致比例的不同，而不同的比例会带来不同的感受、行为和态度，这就是我们所说的比例偏见。 “比例有偏见，掏钱莫‘打脸’。” 你应该怎样让消费者买单买得更爽、掏钱掏得更痛快呢？有三招。 第一，放大促销价值。 第二，巧设参照对象。 你觉得这个促销活动够吸引人吗？相比1 000元的商品，50元的赠品只是个小便宜。那聪明的商家应该怎么做呢？它应该告诉你，购买这双鞋的顾客，只要加1元，就能换购一双价值50元的袜子。白送都不一定好用的招数，居然还要收钱？而真实的情况是，愿意加1元换购袜子的人不在少数。这就是比例偏见的神奇作用。免费送袜子，袜子的价值只有鞋子的5%；而加钱换购，1元就能换取50倍的收益。 第三，善用搭配销售 一句话理解比例偏见：比例有偏见，掏钱莫“打脸”。 赌徒谬误人们往往会错误地认为一些事件有内在关联，而事实是，每个事件都是独立的，无论前面的结果如何，都不会对下一次事件产生任何影响。 要想避免落入这个心理陷阱，具体如何做？还是三招 第一，独立判断，客观评价 第二，排除干扰，合理归因。 第三，错就翻倍？除非无限。 一句话理解赌徒谬误：你以为的天命之选，只不过是一厢情愿。 第5章 不但不理性，还会骗自己 消费心理（下）诱饵效应诱饵效应也叫吸引效应或不对称占优效应，是指人们在面临两个难以抉择的选项时，增加一个新选项，也就是诱饵，会让原来的某个选项更具吸引力。 第一，设置次优选项。 第二，干扰占优选项 第三，套餐打包售卖 一句话理解诱饵效应：人与人之间最远的路，就是商家的“套路”。 羊群效应羊群效应也叫从众效应，指的是个人的观念和行为受到群体压力的影响，从而与多数人产生一致行为的现象。 运用羊群效应，引导消费者狂购你的产品，通常有三种方法。 第一，包装成功案例。 第二，凸显用户规模。 第三，引导用户分享。 一句话理解羊群效应：案例，胜过“安利”。 禀赋效应当一个人拥有某项物品或资产的时候，他对该物品或资产的价值评估，要大于尚未拥有这项物品或资产的时候。 了解禀赋效应后，我们如何将其运用到工作和生活中呢？这里有三种应用场景可供你借鉴。 第一，提供免费试用。 第二，兜售亲身参与。 第三，夸赞他人拥有。 一句话理解禀赋效应：“得不到的才是最好的”，这句话可能是世界上最大的谎言。 预期效应人们对事物的判断在很大程度上受主观预期的影响。预期来自已有的认知、他人的评价、权威的意见、公众的舆论等。 第一，品牌塑造更好的预期。 第二，产地构建莫名的预期。 第三，价格锚定效果的预期。 一句话理解预期效应：你看到的，其实是你希望看到的。 锚定效应锚定效应又叫沉锚效应，指的是第一印象或第一信息更容易支配人们的判断，就像沉入海底的锚一样，会把思想固定在某个地方。 那么应该如何运用锚定效应呢？ 第一，产品先定位。 第二，营销先定量。 第三，谈判先开价。 一句话理解锚定效应:最初的瞬间决定最终的结果。 读得懂的互联商业共享经济共享经济，又称作分享经济，是指闲置资源的临时使用权被所有者转让，从而为供给方和需求方同时创造价值。 要想了解共享经济席卷全球的内在逻辑，我们还需要知道以下这三个概念 第一，产消者（prosumer） 第二，U盘化生存 第三，增量价值。 萧伯纳说过：“你有一个苹果，我有一个苹果，彼此交换一下，每个人仍然只有一个苹果。但你有一种思想，我有一种思想，共享一下，我们就都拥有了两种思想。” 一句话理解共享经济：物尽其用，好过仅仅是拥有。[插图] 社群经济一种建立在产品与粉丝群体之间，由信任连接和价值“反哺”共同作用所形成的自组织、自运转、自循环的经济形态。 要想深入了解社群经济，至少有三点你可以记住。 第一，内容：一切产品皆媒体。 就像乔布斯说过的：“好的产品本身，就是最好的营销。” 第二，社群：一切连接皆渠道。 第三，商业：一切参与皆体验。 小米联合创始人黎万强写过一本书，叫作《参与感》，其中提出了参与感“三三法则”，分别是：三个战略（做爆品、做粉丝、做自媒体）；三个战术（开放参与节点、设计互动方式、扩散口碑事件）。 人的商业” 一句话理解社群经济：构筑自己的核心内容，并尽量把连接的成本降为零。 网红经济互联网让“追星”的权利天平发生了倾斜，用户开始有能力自己生产内容，自主消费内容，甚至围绕“网红”形成了一条生机勃发的全新产业链，这就是所谓的网红经济。 网红经济这么火，人人都要当“网红”吗？“网红”是想当就能当的吗？我们来盘点一下。 第一，创业者就要当“网红”？ 第二，怎么当“网红”？ 第三，“网红”怎么赚钱？“ 一句话理解网红经济：使出“洪荒之力”，我为自己代言。 她经济她经济即女性经济，由著名经济学家史清琪女士提出，是指随着女性经济能力和社会地位的提高，围绕女性消费形成的特有的经济现象。 商家如何顺应她经济这种独特的经济形态呢？我总结了三招供你参考 第一，产品端，吸引她的眼球。互联网的世界，真的是一个“看脸的世界 第二，营销端，运用她的思维。 “不在乎天长地久，只在乎曾经拥有 心有眷恋，一花倾念 第三，传播端，撬动她的嘴巴。 一句话理解她经济：你想给她一座城，她却想要一个人。 Baby经济。 Baby经济的市场如此可观，如何从中找到商机呢？还是三招。 第一，从线下到线上 Baby经济Baby经济也叫婴童经济，是指随着婴儿潮的出现而形成的一种经济模式。奶粉、尿布、童装、玩具、早教、亲子游……Baby经济正在形成巨大的产业链。 第二，从单一到多元 第三，从国内到海外。 一句话理解Baby经济：给孩子花的钱，不叫钱。 第7章 5个数字读懂经济大环境 宏观经济GDPGDP指的是一个经济体一年内生产的最终商品和劳务的总价值。粗略地理解起来就是，一个国家的所有人在一年内创造了多少价值。 为了让你更好地理解GDP，我还是带你记住3个数字。 第一，2018年中国人均GDP：6.6万元。 第二，2018年中国GDP增速：6.6%。 第三，中国第三产业占GDP比重：54%。 一句话理解GDP：一个国家的所有人在一年内创造了多少价值。 PICPI也叫居民消费价格指数，由国家统计局负责统计发布。我们买东西、买服务的价格是不断变化的，CPI就是反映这个变化情况的宏观经济指标。 那么普通人怎么应对“通胀”，跑赢CPI呢？至少有以下三种方法。第一，学会投资，提升自己的财商。 第二，投资自己，是永远不会亏本的买卖。老祖宗有一句话：“千金在手，不如一技傍身。” 时刻保持学习精进，成为不可替代的稀缺人才，才是王道 第三，学会消费，把钱有价值地花在当下。 一句话理解CPI：CPI越高，钱就越不值钱。 正在流通的现金叫M0 M1又叫作狭义货币，它反映了经济中的现实购买力，代表消费和终端市场的活跃度。 M2严谨地讲，M2叫作广义货币供应量，你可以把它粗略地等同于央行印钞的数量。 于M2，和你有关联的就是三个数字。第一，183万亿元。 第二，12%。 第三，8%。 一句话理解M2：广义货币，就是央行印钞的数量。 如果请经济学家列出人类面临的最困难的三个问题，那么你听到的回答很可能是：第一，生命的意义是什么？第二，如何统一量子力学和广义相对论？第三，外汇市场到底是怎么回事？ 汇率汇率是一种货币兑换另一种货币的比率，或者说，是以一种货币表示另一种货币的价格。 关于汇率，记住这样三个数字就够了。 第一，6.5。 第二，5万美元。 第三，3万亿美元。 一句话理解汇率：一种货币兑换另一种货币的价格。 利率从本质上说，利率的水平就是金融资本的价格，也就是钱的价格。与普通商品一样，它们都是由市场的供需决定的。 利率有三个概念，对应三个数字，记住这些可能对你有帮助。 第一，名义利率 第二，真实利率 第三，无风险利率。 说到利率，一定要提到爱因斯坦提名的“世界第八大奇迹”——复利。 一句话理解利率的高低是怎么被决定的：钱多了，钱就便宜；钱少了，钱就贵。 第8章 关于互联网，我们只知道一半 互联网思维（上）用户思维，是指在价值链各个环节中都要“以用户为中心”去考虑问题。 互联网思维互联网思维，是指在（移动）互联网、大数据、云计算等科技不断发展的背景下，对市场、用户、产品、企业价值链，乃至整个商业生态进行重新审视的思考方式。 懂得了用户思维的重要性，具体怎么应用？有三大法则。第一，得草根者得天下 第二，兜售参与感。 《100个梦想的赞助商》的视频，这里面的人就是小米的100个“种子用户” 第三，超越预期的用户体验。 一句话理解用户思维：一箭射在膝盖上，让他长跪不起。 凸显核心价值的简约 第一，看起来简洁。 第二，用起来简化。 第三，说起来简单。 一句话理解简约思维：少即是多，用户喜欢你只需要一个理由。 极致思维极致思维体现的是一种匠人精神，就是要把产品和服务做到最好，是从99%到99.99%的坚持。 所谓极致，不等于完美。在践行极致思维时，有三点你需要特别注意。第一，择优求精，而非面面俱到 第二，价值为先，而非一厢情愿。 第三，坚持创新，而非故步自封。 一句话理解极致思维：从99%到99.99%的坚持。 小步快跑，快速迭代——迭代思维—— 迭代思维迭代，在汉语词典里的解释是“更相代替”。说简单点儿，从版本1.01到版本1.02，就是一次迭代。迭代的目标有可能是不确定的，只是为了试探用户的反馈，发现新的市场机会。迭代的周期也是较为随机的，出现问题随时解决，没有问题就优化细节，变换风格，提升用户的新鲜感。 知道了什么叫迭代思维，你又应该如何运用呢？还是三招。 第一，定原型。《 MVP（minimum virable product，即最小可行性产品）。 第二，迈碎步 第三，抢窗口 一句话理解迭代思维：自己选的路，用小碎步快速跑完。 流量思维流量思维是指用多种方式获取大量新用户的思维。经营流量，就像在一个熙熙攘攘的广场上，想办法让尽可能多的人走到你面前。 互联网教父”凯文·凯利有一句很精辟的话：“目光聚集之处，金钱必将追随。” 今天，我们不着重论述流量思维的重要性，更多的还是告诉你如何运用流量思维。具体可以参考三个方面。第一，噱头做得妙。很 第二，广告打得巧 第三，免费玩得呱呱叫 一句话理解流量思维：目光聚集之处，金钱必将追随。 第9章 我们所知道的这一半，都是错的 互联网思维（下）在一个社会化的环境中，每一个人都是节点，他们接收信号，也发出信号。” 六度空间 六度分割理论 最多通过五个中间人，你就能够认识这个世界上的任何一个陌生人。 社会化思维社会化思维，是指组织利用社会化工具、社会化媒体和社会化网络，重塑企业和用户的沟通关系，以及组织管理和商业运作模式的思维方式。 第一，重建用户关系 第二，重构营销思维。 第三，重塑商业模式。 一句话理解社会化思维：用户即媒介，人就是节点。 数据思维传统的数据更多的是数据化运营，也就是在分析已有的数据后进行决策。而大数据思维，本质上是从数据化运营升级为运营数据，也就是有针对性地设置、收集并利用大数据，为商业创造新的价值点。 ，了解大数据有什么用处呢？还是要将其归结为三点。第一，大数据帮你实现创新模式 第二，大数据帮你实现精准营销 第三，大数据帮你实现智能生活 一句话理解大数据思维：从数据化运营到运营数据。 产融思维所谓产融思维，就是一切产业皆可金融。你一定听说过“羊毛出在猪身上”这句话。没错，现如今，很多传统产业本身只作为免费的流量入口，真正的变现方式，或者说产出羊毛的，正是这只叫作“金融”的猪。 那么，产融思维具体可以在哪些方面帮助我们呢？至少有以下三个维度。 第一，降低融资成本 第二，快速跑马圈地。 第三，创新盈利模式。 一句话理解产融思维：拥有多少钱，不重要；能调动多少钱，才重要。 生态思维单拿出来任何一款产品，都不具备舍我其谁的绝对优势，但是当所有的产品构建起一种生态时，则会因为互相之间的协同效应产生巨大的价值壁垒。这也是我们常说的生态思维。 第一，别着急连，先当垂直老大。 要想合纵连横，第一件事是先找到一个足够垂直、不怕小众的缝隙市场，成为绝对的第一。 只有服从大自然，才能战胜大自然”。 第二，横着连，以用户为轴。所 第三，纵着连，以整合为尺。 一句话理解生态思维：只有服从大自然，才能战胜大自然。 跨界思维简单地说，跨界就是别有用心地“不务正业”。比如，星巴克除了卖咖啡，还卖光盘；宜家除了卖家具，还卖肉丸子；宝马除了卖汽车，还卖休闲服装。 理解了什么是跨界思维，又该如何运用跨界思维呢？给你三个建议。 第一，核心能力，要稳。 第二，颠覆方向，要准。 第三，对待自己，要狠。企 贝索斯就说过：“伟大的公司，要学会被人误解。” 一句话理解跨界思维：跨界，就是别有用心地“不务正业”。 第10章 你看赚多少钱，投资人看值多少钱 融资融资融资是指企业通过借钱（举债）、出售所有权（股票），或由获利盈余（留存收益）来筹集所需资本的行为。 我们来分别看一下投融资过程的三个阶段：投资早期、投资中期和投资后期。第一，投资早期，一般指的是“种子轮”和“天使轮”。 第二，投资中期，包括A轮、B轮。 第三，投资后期，主要是C轮、D轮和IPO（Initial Public Offerings，即首次公开募股）。 一句话粗浅地理解投资轮次：“天使轮”看人，A轮看产品，B轮看数据，C轮看收入，上市看利润。 一份优秀的BP通常只需包含12页 第1页是项目概述。这一页需要精练地概括项目，最好只用一句话，越简单越好。第2页是用户的痛点分析。用户有哪些需求场景？行业有哪些痛点？有哪些需求是还没被满足，或者是竞争对手没有解决好的？这个需求市场有多大？这一页的重点是描述市场边界，通俗的说法是描述这个市场的天花板有多高。 商业计划书Business Plan，简称BP，通常是创业者为了对外融资而编写的对公司的画像，包括公司业务、财务状况、市场分析、管理团队等方面的内容。 第3~4页是产品展示页。围绕之前的痛点，你要提供什么样的产品来满足这种市场需求。这部分一般是用几张简单的图片（比如产品截图、业务流程图）描述产品的核心功能，以及产品的开发进度。第5页是竞争分析。同一赛道的竞争对手有哪些？你和他们有什么不同？优势在哪里？有没有可能实现“弯道超车”？这一部分主要是回答投资人关心的“你如何跑赢市场竞争”这个问题。第6~7页是团队介绍。一流的团队可以做好二流的项目，但是二流的团队没办法做好一流的项目。介绍团队不要宽泛地说“技术高超，经验丰富”，这样的描述都是0分，最好的表述是“某某曾经开发一款小软件，帮公司半年内增加100万用户和1 000万元的收入……”用数字说话更有信服力。第8页是里程碑。这一部分主要展示公司从成立到现在的用户数据、收入数据、盈利数据……用已有的运营数据证明你的商业思路可行，流程顺畅，并不是仅有一个想法就来融资了。第9页是发展规划。这款产品做出来以后怎么推广？打算用多长时间达到多少用户量？公司会怎样扩展市场，希望占有多少市场份额？这一步做好以后，下一步会怎么做？这里需要一步一步地展示你公司的长远发展规划。第10~11页也是非常重要的一个部分——融资方案。融资方案有两个核心部分：融资金额和融资用途。首先是你出让多少股份，要多少钱。融资并不是越多越好，你漫天要价就会把投资人吓跑。一般的惯例是，融到足够公司未来18个月所需的资金量就可以了。出让多少股份其实就是估值的问题，怎么估值是一门大学问，我们在之后的章节会专门讲这个主题。然后就是这些钱的用途。再大方的投资人也不会让你拿着钱买豪车、豪宅，环球旅行，而是让你把钱用在刀刃上，优化产品，开发市场。最后一页，也就是第12页，用一句话清晰明了地总结整个项目，给人留下深刻的印象，简约而不简单。 距离优秀的BP还差3件事 第一，自己写，你的公司你做主 第二，慎吹牛，爱用户别爱技术。 第三，说人话，少用文字多用图。 一句话理解怎么做一份好的商业计划书：简约不简单，真诚不做作，理性不吹牛。 路演路演的英文是Roadshow，简单理解就是在路边吆喝。在融资中，站在路边的是创业者，卖的东西就是企业的股权。 第一，讲好故事 第二，霸气外现。 王峰说过：“项目是我的孩子，我每天醒着想，睡着了也想，我怎么可能被投资人问住？” 第三，相信自己 别高看他们”，你可以理解为：战略上藐视对手，战术上重视对手。 一句话理解路演：自信、真诚地讲好故事。 估值估值，顾名思义，就是估算出来的价值。公司估值就是企业在寻求融资的过程中对企业价值的估算。 常用的估值方法有三种：成本法、相对估值法和绝对估值法。 第一，成本法，也就是看过去。 第二，相对估值法，也就是看现在。 第三，绝对估值法，也就是看未来。 永远记住那句话：创业者考虑的是公司赚多少钱，而投资人考虑的永远是公司值多少钱。 一句话理解公司估值：对于估值算法，你要先学会，再忘记。 Term Sheet投资条款清单，简称TS，也被称为投资意向书，是投资者和拟被投资企业就未来的投资交易所达成的原则性约定。 我们来一起简单了解一下3项常见的投融资条款：清算优先权、反稀释条款、股份回购权。 第一，清算优先权。 第二，反稀释条款。 第三，股份回购权 一句话理解融资条款：融资就是博弈，对条款有舍有得，是为真正的帅才。 学得会的品牌传播客户细分客户细分，就是根据客户的属性、行为、需求、偏好，以及价值等因素对客户进行分类，并为其提供有针对性的产品、服务和销售模式。 具体如何来进行准确的客户细分呢？ 第一，统计内在属性 第二，分析外部特征。 第三，识别行为轨迹。 一句话理解客户细分：百人百姓，千人千面。 好店不愁客，好货不愁卖 客户生命周期对企业而言，客户是有生命的，从诞生、成长、成熟、衰老到死亡，商家要想尽可能多地从客户身上捞取油水，就得在不同的阶段，用不同的方法刺激客户。 客户生命周期管理（Customer Life Cycle，简称CLC）。 初始期、成熟期和衰退期 那面对不同阶段的客户，具体怎么管理呢？简单来说，你要做的就是这三件事。 第一，用激素缩短初始期 第二，用多巴胺延长成熟期。 第三，用内啡肽延迟衰退期。 一句话理解客户生命周期：今宵离别后，何日君再来 客户获取客户获取即我们常说的“获客”，一般由公司的市场部负责。在传统商业环境里，获客就是两件事：1.广告，想办法让人“慕名而来”；2.渠道，想办法“近水楼台”，然后“先得月” 第一，理性买。 第二，尽量换。 第三，努力钓。你 好玩的方式增强用户参与感，去“钓取”更多用户。 一句话理解客户获取：要么慕名而来，要么近水楼台 客户终身价值客户终身价值，是指一个客户在他生命周期内一共能贡献多少钱。说白了就是你能从一只“羊”身上薅下来多少“羊毛”。 理解了什么叫客户终身价值，想要做好客户价值转化，你可能需要这三个“锦囊”。 第一，迭代制胜，使商品历久弥新。 第二，需求制胜，商家要得寸进尺 品类交叉引流 第三，品牌制胜，让用户买椟还珠。 一句话理解客户价值转化：对客户，要让他们人尽其“财”。 客户保留客户保留，是指企业为防止客户流失、建立客户忠诚所运用的一整套策略和方法。 客户保留具体来说就是，提升客户忠诚度，降低流失率，实现客户保留。对此，你可以从以下三个方面入手。 第一，培养小依赖。 第二，制造小惊喜。 第三，倾听小牢骚 一句话理解客户保留：让客户生是你的人，死是你的死人。 第12章 多便宜，才算便宜？ 定价策略撇脂定价法在产品生命周期的最早期，制定高价，榨取利润，就像从牛奶中捞取奶皮一样。 在什么条件下可以使用撇脂定价法。 第一，要有用户做“冤大头” “爱她，就带她去吃哈根达斯。 第二，要有技术做“护城河” 第三，要有品牌做“试金石” 一句话理解撇脂定价法：给用户定一个高价，你就可以优先获取“牛奶”里的“精华” 渗透定价法企业在产品投放市场的初期，将价格定得较低，以此来吸引大量顾客，提高市场占有率。 所以使用渗透定价法时需要注意限制条件，我在这里为你总结了三点。 第一，需求弹性大，更该用低价。 第二，边际成本低，才好用低价。 第三，初来乍到时，推荐用低价。 一句话理解渗透定价法：人间自有真情在，能省一块是一块。 阶梯定价法购买一定数量之内，是一种价格；超过一定数量以后，是另一种价格。如果画成图，形状就像阶梯一样。 第一，优惠金额不等比。 第二，上限保持吸引力。 第三，边际成本扛得住。 一句话理解阶梯定价法：别问多少钱，先说买多少。 动态定价法简单地说，动态定价法就是商家对商品或服务的价格进行灵活调整的一种定价策略。这种方法曾被普遍运用到航空业、酒店业。如今，在演出和体育比赛的票务市场，定价也在逐渐走向动态化。 第二，基于用户行为 第三，活用价格歧视。 一句话理解动态定价法：看人下菜，见风使舵。 反向定价法反向定价法，是指由消费者先出价，商家若选择接受，交易就算达成的一种定价方法。 ，反向定价法有什么优点呢？ 第一，价格敏感拽出来。 第二，成交价格藏起来。 第三，交易成本降下来。 一句话理解反向定价法：萝卜白菜，各有所爱；您说几块，就是几块。 第13章 有种资产，叫品牌 品牌管理关于品牌，有个很经典的笑话。有个人爬墙出学校，被校长抓着了。校长问他：“为什么不从校门走？”他说：“美特斯邦威，不走寻常路。”校长追问：“这么高的墙怎么翻过去的啊？”他指了指裤子，说：“李宁，一切皆有可能。”校长又问：“翻墙是什么感觉？”他指了指鞋子，说：“特步，飞一般的感觉。”校长大怒：“我记你大过！”他问：“为什么？”校长淡淡一笑，说：“动感地带，我的地盘我做主！” 品牌资产品牌资产，是指消费者关于品牌的知识和心理事实，是影响消费者感知产品和服务价值的重要因素。 可口可乐前董事长伍德鲁夫有一句名言：“假如我的工厂被大火毁灭，只要有可口可乐的品牌，第二天我又将重新站起。” 第一，建立鲜明的品牌认知。假 第二，形成有力的品牌联想 第三，借助优质的杠杆资源 一句话理解品牌资产：无论是皮囊还是灵魂，所追求的都得是万里挑一。 品牌定位品牌定位就是在客户的心智当中占领一个独特而有价值的位置。说得直白一点儿，就是三个字：你是谁。 第一，宁为鸡头，不当凤尾。 第二，求同存异，借力打力。 第三，不忘初心，方得始终。抢 一句话理解品牌定位：成为第一。如果你不能在这个领域争得第一，那就寻找一个你可以成为第一的领域。 品牌组合一家公司在同一品类里开发多个品牌，分别进入不同的细分市场，从而让整体的市场覆盖率更高。这种品牌管理的方式叫作品牌组合。 说到洗发水品牌，你可能听说过飘柔、潘婷、海飞丝、伊卡璐和沙宣，但你知道它们都属于宝洁吗？飘柔主打“柔顺优雅”；潘婷主打“修护滋养”；海飞丝主打“清爽去屑”；伊卡璐主打“草本天然”；沙宣主打“专业时尚”。5个品牌各显神通，让宝洁占据了国内洗发水数百亿元市场的半壁江山。 品牌组合已经是一种非常成熟的品牌管理方法 第一，借助高端品牌，建立价值优势。 第二，利用低端品牌，形成侧翼保护。 第三，看清交叉范围，避免自相残杀。 一句话理解品牌组合：三个臭皮匠，顶个诸葛亮。 品牌延伸品牌延伸，是指企业利用现有品牌进入新的产品类别，推出新产品的做法，本质上是借助已有的品牌信誉和市场影响力为新产品线赋能。 理解了品牌延伸的特点，我们在具体运用的时候，还需要注意以下三个方面 第一，贪多嚼不烂。 第二，树大好乘凉。 第三，“女大不中留”。 一句话理解品牌延伸：一根藤上七朵花，一个葫芦七个娃。 品牌激活品牌激活就是扭转品牌的衰退趋势，重获消费者青睐的一种品牌管理行为。 寒冰不能断流水，枯木也会再逢春。 关于品牌激活，具体的使用技巧还是三个。 第一，新陈代谢，开启年轻化 第二，倚老卖老，主打复古风。 第三，该放就放，有舍才有得 一句话理解品牌激活：寒冰不能断流水，枯木也会再逢春。 第14章 一件事儿，到底该怎么说？ 媒介管理整合营销传播整合营销传播（Integ-rated Marketing Communication），简称IMC。1992年，美国西北大学[插图]教授唐·舒尔茨提出了IMC的理论框架。舒尔茨教授认为，品牌在消费者心里发挥作用的过程，不只是心智占有，还是一种体验的累积。 那么具体如何做整合营销传播呢？我给你三条建议。 第一，上下要统筹 第二，左右要配合。 第三，前后要协调。已 一句话理解整合营销传播：One world，one voice.（同一个世界，同一种声音。) 你可以怎么做精准定向传播呢 第一，搜索引擎营销。 第二，程序化购买 第三，智能算法。 一句话理解精准定向传播:指哪儿打哪儿，打哪儿指哪儿。 意见领袖传播 KOL一声吼，行业抖三抖 意见领袖意见领袖又叫舆论领袖，最早在20世纪40年代由美国哥伦比亚大学的传播学者保罗·拉扎斯费尔德提出。保罗认为：对于媒介所传播的信息，有一部分人会积极接受，并再度传播，扩大影响，这些人就是意见领袖。 怎么做KOL传播呢？ 第一，圈层专业，领域深耕。 第二，潜移默化，润物无声。 第三，量的积累，质的飞跃。 一句话理解意见领袖传播：射人先射马，擒贼先擒王。 公关公关（PR）是公共关系（Public Relations）的简称，指的是企业和公众群体之间的关系。但凡是关系，都需要经营维护，公关就是企业先经营好与公众的关系，再通过公众群体所形成的口碑、舆论、正面印象，间接地影响终端消费者。 那么想要做好公共关系，应该如何操作呢？简单来说，还是三件事儿。 第一，携手媒体记者，搞事情 第二，担负社会责任，做公益。 第三，应对舆论危机，“擦屁股” 一句话理解公共关系：大家觉得好，才是真的好。 创意为王好的创意，自带流量。 人头马一开，好事自然来”[插图]，“钻石恒久远，一颗永流传” “广告教父”大卫·奥格威提出过一个特别简单但是绝对好用的广告创意法则：3B原则。3B是Baby、Beauty、Beast这3个单词的缩写，也就是说，出现小孩、美女和小动物的广告片，最能吸引人。 我在这里总结了三个新的创意方向，代表互联网广告的当下和未来。 第一，在内容里交织渗透。 第二，在媒介上耳目一新。 第三，在互动中花样百出。 一句话理解创意：好的创意，能把强迫用户看的广告，变成用户追着看的内容。 第15章 谈判，是“舍”与“得”的艺术 谈判BATNABATNA是由罗杰·费舍尔和威廉·尤里在1981年提出的谈判思维，是指假如当前的谈判破裂，你找别人合作能够拿到的最好条件。 第一，骑驴找马，优化你的BATNA。中 第二，步步为营，探出对方的BATNA。 第三，釜底抽薪，削弱对方的BATNA。 一句话理解BATNA：谈判之前，先找“备胎”。 开局策略谁能掌握更全面、更充分的信息，谁就能在谈判中享有巨大的优势。 除了知己知彼，还有哪些技巧，能够帮你形成一个对自己有利的开局呢？ 第一，狮子大开口。 第二，吃惊大开口 第三，假装大开口。一 一句话理解谈判的开局策略：知己知彼，做足功课。 让步策略谈判是一门妥协的艺术，它的本质应该是利益交换，谈判者不仅要得到自己想要的，还要适当让出对方想要的。 让步的重要性无须多言，我们更应该聚焦在如何运用让步策略上 第一，索取回报趁当前。 第二，让步幅度要递减 第三，折中让步要避免。 一句话理解让步策略：谈判里真正的赢，是双赢。 终局策略从心理学角度来解释，人在经历过恐惧之后，都特别渴望被安慰。“黑脸白脸”就是利用了人在情绪的快速转移过程中，心理会放松戒备这样一个弱点。 你可能会问，如果身边的人都很友善，没有一个会扮黑脸的，该怎么用这一招呢？很简单，你可以虚构一位上级领导，让他来扮演黑脸。 黑脸白脸战术的威力如此之大，万一对方用起来，你怎么办呢？有三种方法是我们可以尝试的。当我们学会拆解对方的黑脸白脸战术，自然也就可以把自己的黑脸白脸唱得更得心应手了。 第一，让装睡的白脸自我觉醒。 第二，跟脸皮薄的白脸统一战线。 第三，对强硬的黑脸施阴柔术。 一句话理解谈判的黑脸白脸战术：恩威并济，软硬兼施 一是地尽其利的能力。 二是要具备不失时机的能力。 谈判软技能商业的世界就是弱肉强食，要么店大压客，要么客大压店，这个观点我不止一次说过。那么，到底什么决定着你的大小呢？德州扑克这个游戏背后的逻辑，跟商业谈判有着惊人的相似点。在德州扑克中，你的筹码量比你拿到的牌更重要。谈判技巧决定你拿什么牌，你的筹码量还是决定于你自身的实力：你有多少用户，你有什么技术，你有什么核心竞争力是人无我有、人有我优的，你的团队凝聚着怎样的精神力和意志力，等等。 最厉害的谈判高手体现在能够化腐朽为神奇，把别人谈不成的生意谈成。这种“破局而生”的能力最为难能可贵。那么如何应对谈判场上的僵局和困境呢？有以下三种方法。 第一，临阵换将，发起持久战。 第二，按下暂停，让宾主尽欢。 局”的本意是棋盘，因此饭局就是在餐桌上的博弈。能够吃好喝好，宾主尽欢了，再谈正事，就能变得顺畅许多。 第三，共同利益，尽量一边坐。 一句话理解谈判软技能：破局而生，化腐朽为神奇。 做得到的自我迭代一万小时定律人们眼中的天才之所以卓越非凡，并非天资超人一等，而是付出了持续不断的努力。一万小时的锤炼是任何人从平凡变成世界级大师的必要条件。——格拉德威尔，《异类》 如果你认为“只要练一万个小时，就一定能成为专家”，那就大错特错了。 关于坚持，我给你三个建议 第一，带着目的学。 第二，带着喜欢学 第三，带着环境学。 一句话理解一万小时定律：以5年、10年为人生刻度，规划自己的职业生涯。 刻意练习杰出并不是一种天赋，而是人人都可以学会的技巧，这个技巧就是刻意练习。 第一，走出既有误区。 第二，建立心理表征 有人说，凡事都有三个阶段：第一个阶段，看山是山，看水是水；第二个阶段，看山不是山，看水不是水；第三个阶段，看山还是山，看水还是水。 第三，循环3个F。 方法就是循环3个F：第一个F是专注（Focus），在整个刻意练习的过程中，要带着明确的目的，注意力要高度集中，行为高度专注；第二个F是反馈（Feedback），在专注练习的过程中，要不断地主动获取外界的反馈；第三个F是修正（Fix）。任何刻意练习，都遵循这样一种简单的逻辑：1.取得进步；2.遭遇瓶颈；3.克服障碍；4.稳定提高；5.直到下一个障碍出现 一句话理解刻意练习：杰出不是一种天赋，而是人人都可以学会的技巧。 批判性思维批判性思维与海绵式思维的全盘接收不同，前者讲求的是在吸收信息的过程中，要质疑、分析、评价、反思。 有一段总结批判性思维的话，我觉得挺有意思，分享给你：怀疑，但不否定一切；开放，但不摇摆不定；分析，但不吹毛求疵；决断，但不顽固不化；评价，但不恶意揣测；有力，但不偏执自负。那么，要想具备批判性思维，到底该怎么做呢？我分享三个技巧给你。 第一，避免归因偏差。 第二，识破推理谬误。 第三，细听弦外之音 一句话理解批判性思维：对思考过程的“再思考” 图形化思维图形化思维就是用图形的组合，把我们接收的信息和我们的想法直观地呈现出来。 那么，图形化思维具体怎么用呢？还是三种方法。 第一，掌握基本模型。 第二，了解视觉规范。 第三，争取一气呵成。 一句话理解图形化思维：用简单的图形，演绎复杂的思考。 学习金字塔”从阅读、听课、运用多媒体到现场观摩、互动讨论，再到最后教别人，这个学习效果不断提升的过程，实际上是一个从“自己学”到“大家一起学”，从“被动学习”到“主动学习”的转化过程。 那具体来说，怎么运用“学习金字塔”提升自己的学习效率呢？我觉得有三种方法。 第一，复合感官。 第二，知行合一。 第三，教学相长 学员听课有两个结果，一是觉得这个老师好厉害，二是自己真的变厉害了。 一句话理解“学习金字塔”：从自己学到一起学；从被动学到主动学。 第17章 沟通就是好好说话？太傻太天真 沟通管理有一个著名的“沟通漏斗”理论：你心里想的是100%，嘴上能说出来的是80%，别人能听到60%，听懂40%，而最后付诸行动的只有20% 人际沟通划分为四个区：公开区、盲目区、隐蔽区、未知区。 乔哈里视窗乔哈里视窗是美国学者乔瑟夫和哈里共同提出的一个理论，它也被称为“自我意识的发现-反馈模型”。它把人际沟通比作一扇窗，将其分为四个区域：公开区、隐蔽区、盲目区和未知区。 第一，请教与反馈。 第二，自我暴露。 ，曾经有人告诉我交朋友最好的方法，就是告诉对方你的一个小秘密。 第三，共享发现。尝 一句话理解乔哈里视窗：你说的和别人听到的，很可能并不一样。 关键对话可以总结为三句话：意见不统一，气氛特紧张，结果风险大。 第一，从“心”开始，明确目标。 第二，营造氛围，避免冲突。 第三，主动耐心，化解沉默。 一句话理解什么是关键对话：意见不统一，气氛特紧张，结果风险大。 良言一句三冬暖，恶语伤人六月寒。” 暴力沟通分类 1.道德评判 2.做比较 3.强人所难 运用非暴力沟通，有以下三个关键步骤，我给你分别拆解一下 第一，提出陈述，不做评论 非暴力沟通非暴力沟通是用相互尊重、理解和包容的态度来完成对话的方式。用该理论的提出者——马歇尔·卢森堡博士的话来说，就是“情意相通，和谐相处”。 第二，表达感受，不加想法 第三，明确需求，不要含糊。 一句话理解非暴力沟通：良言一句三冬暖，恶语伤人六月寒。 等到30多岁，我才渐渐明白一个道理：沟通时，你说了什么不重要，怎么说的才重要。 通分解成三个部分，即语言内容、眼神手势、语速语调 信息传递=55%视觉+ 38%声音+ 7%语义 非语言沟通非语言沟通就是指沟通过程中利用身体动作、体态、语气、语调、语速，甚至穿着、空间距离等，传递和交流信息。 语言沟通的技巧有很多，我们在这里只谈最重要的三点。 第一，眼神：心灵的小窗户 第二，声音：情感的小象征。 第三，动作：内心的小表达。几 一句话理解非语言沟通：说了什么不重要，怎么说的才重要。 《高效演讲》 送礼物心态不要极力取悦那些不那么在乎你演讲的人，把心态调整成“我来送礼，喜不喜欢随你”这种感觉，紧张感自然就会缓解。 第一，七秒开场。 第二，“三事法则” 第三，“你”和“我们”。 一句话理解公众演讲：我来送礼，喜不喜欢随你。 第18章 让别人做你想让Ta做的事 职场沟通让别人做你想让Ta做的事 汇报谁经常向我汇报工作，谁就在努力工作；谁不经常汇报工作，谁就没有努力工作。——马克·麦考梅克，《哈佛学不到的经营策略》 这样重要的职场沟通技巧，如何才能用好？我给你三个建议。 第一，永远提供选择题 哈佛商业评论》杂志发表过一篇文章，叫《谁背上了猴子》 优秀的员工在汇报之前会准备3套方案：最可行的、最大胆的和最保守的，并提前衡量每个方案的利弊。 汇报的时候可以这么说：“我们有三个方案可以选，A方案是……优点是……缺点是……；B方案是……优点是……缺点是；C方案是……优点是……缺点是……我感觉A方案最可行，您看呢？” 第二，先说结论少闲扯。 “电梯测验”，做销售的人一般都经历过这种训练。就是要求你在等电梯的短短30秒里，清晰、准确地向客户说明白你的方案。 第三，拿捏时机才好办。 公司里讲求分工协作，一个细节变动，就可能“牵一发而动全身”，影响很多部门，所以汇报一定要及时。 一句话理解职场沟通：在对的时间，用对的方法，提高职场“能见度”。 马爸爸”的协调智慧 那马云是怎么做的呢？他先打电话给金庸，说了一番自己的雄心壮志，诚心诚意请他来当评委，没想到金庸爽快地答应了。然后，马云又打电话给网易和新浪的老大，这两个人都是金庸迷，一听说金庸要来，都马上点头说来。最后，马云打电话给搜狐老大张朝阳，张朝阳虽然不是金庸迷，但是听说网易和新浪的人都来，自己也不能落下，就一起出席了“西湖论剑”。 在职场中，一个人的协调能力如何，会直接反映在他的工作进展上 协调力协调力包括三种综合能力：确保整体平衡发展的“调整力”，在人与人之间起联系作用的“中介力”，以及向成功方向引导的“推进力”。——大久保幸夫，《12个工作的基本》 特别是在职场上协调资源的时候，别人为什么要听从于你呢？这也是最难的部分。 第一，花言巧语，把对方架上去。 比如，你在面对客户时可以说：“您在这行可比我有经验多了，这个方案的好处您肯定比我更明白。”你在面对同事时可以说：“总听老板讲，你是公司里最专业的，还特别有耐心，人特别好，我就厚着脸皮来了。” 第二，互换立场，从对方角度想。 “我们希望帮路总扩大一下商学课的影响力，所以想请您来做一场演讲。您把课程的二维码发给我，我在线上线下都做一些推广。” 第三，借用背书，让资源浪打浪。 我最看重你，所以第一个跟你说。 一句话理解协调：要想齐心协力，不能光靠默契。 拒绝一味地顺从，会失去自我。一味地拒绝，会失去朋友。就人生而言，一方面应该懂得有容乃大，另一方面也应该明晓不能是来者不拒。——汪国真，《拒绝》 以下这三种人的请求，我一定尽全力满足：1.真心帮助过我；2.真正关心过我；3.真的在乎我的时间。除此之外，不管是谁，一律说“不”。 以让你在拒绝别人的同时不伤情面。 第一，推却得留有余地。 第二，回绝得有理有据。 有一次，他的一位好朋友向他打听海军在一个小岛上建立潜艇基地的计划。罗斯福神秘地向四周看了看，压低声音问道：“你能保密吗？”朋友说：“当然能！”罗斯福微笑着说：“那么，我也能。” 第三，能不能之后再议。 事缓则圆。” 一句话理解拒绝：一味地拒绝，会失去朋友；一味地顺从，会失去自我。 争取“会哭的孩子有奶吃”这句话的确不错，但我们一直都理解错了。这个“会哭”，不是跟压根不哭相比，而是与“瞎哭”“乱哭”区别开来。聪明人知道在什么时候哭，该怎么哭。 非常规加薪”，具体该怎么做呢？还是三个建议。 第一，天时——看势头选时机。 第二，地利——用稀缺说价值。 第三，人和——用责任换利益。 一句话理解职场利益的争取：知道什么时候哭、怎么哭的孩子，有奶吃。 一是套话。 二是空话，就是说出口却兑现不了的话。 三是假话。 场沟通禁忌在职场，攻城略地要靠能力、靠付出、靠真本事。同时，为了防守，我们也要懂得基本的职场规则，否则进一步退三步，非智者所为。 四是真话。 还有以下三种情况，你得格外小心。 第一，不顾汇报关系。 第二，不看人前人后。 一直信奉一条处世之道：说别人好，要背着人说；说别人的不是，一定要当人面说。 第三，不分角色场合。 同事之间的关系就像刺猬：离得太远，彼此之间缺少温暖；挨得过近，难免就会伤到对方。 一句话理解职场沟通的禁忌：有些话，不该说，就别说。 第19章 你和比尔·盖茨，都只有24个小时 时间管理有这样一个实验。一位教授带着一个玻璃罐走进教室，他先在罐子里放入一堆高尔夫球，问学生：“这个罐子满了吗？”学生们回答：“满了。”教授倒入一杯小石子，填满了高尔夫球之间的空隙，然后问道：“满了吗？”学生们回答：“满了。”教授又倒入一杯沙子，将石子间的缝隙填得满满的，并问道：“满了吗？”学生们很无奈地答道：“这回肯定满了。”教授微微一笑，又拿出了一瓶啤酒。“现在你们把这个罐子想象成自己的人生，高尔夫球代表重要的东西，包括家人、朋友、健康、爱情；小石子代表一般重要的事情，比如工作、房子、车子；沙子代表不重要的小事。如果你先把沙子倒进去，会怎么样呢？你就没有空间放高尔夫球和小石子了。先放入高尔夫球，也就是真正重要的事，然后再放入小石子、沙子，就容易得多。”教授说道。“那啤酒代表什么呢？”有个学生问道。教授大笑着说：“它代表无论你的生活过得多么紧凑，你仍然有时间和朋友们喝几杯。 时间四象限法 时间管理如果你把所有的时间和精力都消耗在琐事上，那就不会有时间去做真正重要的事。 第一，不重要也不紧急的事，少做。 第二，紧急不重要的事，快做。 第三，重要不紧急的事，早做。 一句话理解时间四象限：大事早做，从容不迫。 拖延症的危害拖延行为会产生许多负面的结果：从外在看，也许是损失金钱、损失信用；从内在看，你会变得自责、焦虑、消极、倦怠，在“拖延怪圈”中苦苦挣扎。 那么，如何预防和治疗拖延症呢？有三个小技巧。 第一，拆分任务时间。 WBS（Work Breakdown Structure，工作分解结构）。 第二，用好碎片时间。 第三，找到最佳时间。 一句话理解拖延症：明日复明日，明日何其多。 心 流心流是指在做某些事情时，那种全神贯注、投入的、忘我的状态。 第一，物理屏蔽法。 第二，番茄工作法 第三，Deadline倒逼法。 我团队里的一个小伙伴在准备婚礼的时候，做了一张超大的“甘特图”，九大模块，共计80个小项目，按照婚礼时间倒推，标注好每个项目的完成时间，自己驱动自己，按计划完成。最终在几乎没有请假也没有花钱请专人策划的情况下，办了一场所有人都点赞的定制化婚礼。 一句话理解抵抗干扰：俯首埋头，进入心流。 ABC原理 A”代表事件本身，“B”代表你对这件事的看法，“C”是这件事带来的结果 压力管理让我们心理上受苦的不是事情本身，而是我们对事件的想法和围绕这个事件所编造的“故事”。——张德芬，《遇见未知的自己》 人的欲望是世界上最难填满的沟壑，只要有欲望，就会有压力。 除了心理的“按摩”，还有什么具体的方法可以帮助我们管理压力呢？我在这里还是提供三种小方法 第一，给自己“洗个脑” GTD工作法”（Getting Things Done，把事情搞定）。它的核心理念就是4个字：清空大脑。 第二，给自己扫个除 第三，给自己放个假。 一句话理解压力管理：尽人事，听天命。 精力管理管理精力，而非时间，才是高效表现的基础。——吉姆·洛尔、托尼·施瓦茨，《精力管理》 该干活就干活，该玩就玩，该休息就休息 如何让自己进入“高–正面”象限，保持全情投入呢？我想给你三点建议。 第一，做到张弛有度。 第二，突破惯常极限。 第三，养成仪式习惯。 一句话理解精力管理：该干活就干活，该玩就玩。 第20章 成为一个什么样的人，取决于你自己 职业生涯规划那到底什么是好工作呢？我们来看看关于好工作，通常会遇到的三个问题。 1.大公司真的好吗？ 大公司的成功缘于公司的资源和体系 不是你成就了乔家的生意，而是乔家的生意成就了你。 2.外企真的好吗？ 3.国外真的好吗？ 要先弄清楚你想要什么。如果你不清楚自己想要什么，你就永远也不会找到所谓的好工作。因为你永远只能看到你得不到的东西，而你得到的，都不是你想要的。 一句话想清楚什么是好工作：问问自己，你真的知道自己想要的是什么吗？ 跳槽之前，我建议大家注意三点 工作需要你理性对待。 在90%的情况下，你的公司并没有那么“烂”。 有些问题是躲不开的。 只是不要因为盲目和躲避而跳槽。对此，我想给你三个建议。 第一，不要重蹈覆辙。 第二，积累好再跳。 第三，年轻人敢闯就换。 记得有一位猎头朋友说过这样一句话：“如果你35岁还在通过招聘网站投简历，没有猎头一天到晚骚扰你的话，你就该反省一下，自己到底是哪里做错了。”这句话，你觉得有道理吗？ 一句话想清楚跳槽与积累：在这家公司解决不了的问题，在下一家公司真的能解决吗？ 那么，如何客观地评判一个行业是否够好，是否适合自己呢？我认为有三个标准。 第一，不可逆转的趋势。 第二，不可复制的天赋。 第三，不可替代的稀缺。 好的领导，不是让你钱多、事少、离家近，而是至少具备以下三个特点。 第一，宽广的心胸 第二，从下属角度思考问题。 第三，敢于承担责任。 一句话帮我们看清什么是好行业：入对行，跟对人，成功只是时间问题。 董卿在《朗读者》这个节目上，有过这样一段关于选择的朗读，我很喜欢，把它分享给你。生存还是毁灭，这是一个永恒的选择题，以至于到最后我们成为什么样的人，可能不在于我们的能力，而在于我们的选择。选择无处不在：面朝大海，春暖花开是海子的选择；人不是生来被打败的，是海明威的选择；人固有一死，或重于泰山，或轻于鸿毛，是司马迁的选择。选择是一次又一次自我重塑的过程，让我们不断地成长，不断地完善。如果说人生是一次不断选择的旅程，那么当千帆阅尽，最终留下的就是一片属于自己的独一无二的风景。 我认为有三个问题是你需要想清楚的。 第一，什么叫选择？ 第二，什么是更重要的选择？ 你选择相信什么？你选择和谁交朋友？你选择做什么？你选择怎么做？在这些选择当中，意识形态层面的选择又远比客观条件的选择重要：比如选择做什么产品其实并不那么重要，而选择怎么做才重要；选择用什么人并没有那么重要，而选择怎么用这些人才重要。 第三，什么是比选择更重要的？ 一句话理解选择：你最终会成为什么样的人，就决定在你的每个选择之间。 逆境，是上帝帮你淘汰竞争者的地方——等待—— 要知道，你不好受，别人也不好受，你坚持不下去了，别人也一样。千万不要告诉别人你坚持不住了，那只能让别人获得坚持的信心。让竞争者看着你微笑的面孔，失去信心，退出比赛。胜利终将属于那些有耐心的人。 一句话理解等待：不要告诉别人你坚持不住了，那只能让别人获得坚持的信心。","tags":[{"name":"商学","slug":"商学","permalink":"https://lywlefan.github.io/tags/商学/"},{"name":"常识","slug":"常识","permalink":"https://lywlefan.github.io/tags/常识/"}]},{"title":"java整体脉络总结","date":"2019-06-04T16:00:00.000Z","path":"2019/06/05/指导思想/java/java整体脉络总结/","text":"java学习指导战略。 基础 Java基础知识 阅读源代码 String Integer Long Enum BigDecimal ThreadLocal ClassLoader&amp;URLClassLoader ArrayList&amp;LinkedList HashMap&amp;LinkedHashMap&amp;TreeMap&amp;CouncurrentHashMap HashSet&amp;LinkedHashSet&amp;TreeSet Java中的各种变量类型 熟悉Java String的使用，熟悉String的各种函数 JDK6和JDK7中substring的原理及区别 replaceFirst、replaceAll、replace区别 String对“+”的重载 String.valueOf和Integer.toString的区别 字符串的不可变性 自动拆装箱 Integer的缓存机制 熟悉Java中各种关键字原理和用法 transient instanceof volatile synchronized final static const 集合类 常用集合类的使用 ArrayList和LinkedList和Vector的区别 SynchronizedList和Vector的区别 HashMap、HashTable、ConcurrentHashMap区别 Java 8中stream相关用法 apache集合处理工具类的使用 不同版本的JDK中HashMap的实现的区别以及原因 枚举 枚举的用法 枚举与单例 Enum类 Java IO&amp;Java NIO bio nio aio 三种IO的用法与原理 netty Java反射与javassist 反射与工厂模式 java.lang.reflect.* Java序列化 什么是序列化与反序列化、为什么序列化 序列化底层原理 序列化与单例模式 protobuf 为什么说序列化并不安全 注解 元注解 自定义注解 Java中常用注解使用 注解与反射的结合 JMS 什么是Java消息服务 JMS消息传送模型 JMX java.lang.management.* javax.management.* 泛型 泛型与继承 类型擦除 泛型中K T V E object等的含义、泛型各种用法 单元测试 junit mock mockito 内存数据库（h2） 正则表达式 java.lang.util.regex.* 常用的Java工具库 commons.lang commons.*… guava-libraries netty 什么是API&amp;SPI 异常 异常类型 正确处理异常 自定义异常 时间处理 时区 时令 Java中时间API 编码方式 解决乱码问题 常用编码方式 语法糖 Java中语法糖原理 解语法糖 Java并发编程 什么是线程，与进程的区别 阅读相关源代码，并学会使用 Thread Runnable Callable ReentrantLock、ReentrantReadWriteLock、Atomic*、Semaphore、CountDownLatch、、ConcurrentHashMap、Executors 线程池 自己设计线程池、submit() 和 execute() 线程安全 死锁、死锁如何排查、Java线程调度、线程安全和内存模型的关系 锁 CAS、乐观锁与悲观锁、数据库相关锁机制、分布式锁、偏向锁、轻量级锁、重量级锁、monitor、锁优化、锁消除、锁粗化、自旋锁、可重入锁、阻塞锁、死锁 死锁 volatile happens-before、编译器指令重排和CPU指令重 synchronized synchronized是如何实现的？ synchronized和lock之间关系，不使用synchronized如何实现一个线程安全的单例 sleep 和 wait wait 和 notify notify 和 notifyAll ThreadLocal 写一个死锁的程序 写代码来解决生产者消费者问题 守护线程 守护线程和非守护线程的区别以及用法 JVM JVM内存结构 堆 栈 方法区 直接内存 堆和栈的区别 Java内存模型 内存可见性 重排序 顺序一致性 volatile 锁 final 垃圾回收 内存分配策略 垃圾收集器 G1 GC算法 GC参数 对象存活的判定 JVM参数及调优 Java对象模型 oop-klass 对象头 HotSpot 即时编译器 编译优化 类加载机制 classLoader 类加载过程 双亲委派（破坏双亲委派） 模块化 jboss modules osgi jigsaw 虚拟机性能监控与故障处理工具 jps jstack jmap jstat jconsole jhat javap btrace TProfiler 编译与反编译 javac javap jad CRF 进阶 Java底层知识 字节码、class文件格式 CPU缓存，L1，L2，L3和伪共享 尾递归 位运算 位运算实现加、减、乘、除、取余 设计模式 了解23种设计模式 在软件工程中，设计模式（design pattern）是对软件设计中普遍存在的各种问题，所提出的解决方案。设计模式并不是固定的一套代码，而是针对某一特定问题的具体解决思路与方案。可以认为是一种最佳实践，因为他是无数软件开发人员经过长时间的实践总结出来的。 设计模式的六大原则 开闭原则 里氏代换原则 依赖倒转原则 接口隔离原则 迪米特法则（最少知道原则） 合成复用原则 设计模式分类 创建型模式 单例模式 保证一个类仅有一个实例，并提供一个访问它的全局访问点。 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如网站首页页面缓存）。 避免对资源的多重占用（比如写文件操作） 饿汉式 1234567891011public class Singleton &#123; //在类内部实例化一个实例 private static Singleton instance = new Singleton(); //私有的构造函数,外部无法访问 private Singleton() &#123; &#125; //对外提供获取实例的静态方法 public static Singleton getInstance() &#123; return instance; &#125; &#125; 饿汉式单例，在类被加载的时候对象就会实例化。这也许会造成不必要的消耗，因为有可能这个实例根本就不会被用到。而且，如果这个类被多次加载的话也会造成多次实例化。其实解决这个问题的方式有很多，下面提供两种解决方式，第一种是使用静态内部类的形式。第二种是使用懒汉式。 静态内部类式 饿汉式是只要Singleton类被装载了，那么instance就会被实例化（没有达到lazy loading效果），而这种方式是Singleton类被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance 想象一下，如果实例化instance很消耗资源，我想让他延迟加载，另外一方面，我不希望在Singleton类加载时就实例化，因为我不能确保Singleton类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化instance显然是不合适的。这个时候，这种方式相比饿汉式更加合理。 12345678910111213public class StaticInnerClassSingleton &#123; //在静态内部类中初始化实例对象 private static class SingletonHolder &#123; private static final StaticInnerClassSingleton INSTANCE = new StaticInnerClassSingleton(); &#125; //私有的构造方法 private StaticInnerClassSingleton() &#123; &#125; //对外提供获取实例的静态方法 public static final StaticInnerClassSingleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125; &#125; 懒汉式 1234567891011121314public class Singleton &#123; //定义实例 private static Singleton instance; //私有构造方法 private Singleton()&#123;&#125; //对外提供获取实例的静态方法 public static Singleton getInstance() &#123; //在对象被使用的时候才实例化 if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 这种懒汉式单例其实还存在一个问题，那就是线程安全问题。在多线程情况下，有可能两个线程同时进入if语句中，这样，在两个线程都从if中退出的时候就创建了两个不一样的对象。 懒汉，就是不会提前把实例创建出来，将类对自己的实例化延迟到第一次被引用的时候。getInstance方法的作用是希望该对象在第一次被使用的时候被new出来。 线程安全的懒汉式 1234567891011121314public class SynchronizedSingleton &#123; //定义实例 private static SynchronizedSingleton instance; //私有构造方法 private SynchronizedSingleton()&#123;&#125; //对外提供获取实例的静态方法,对该方法加锁 public static synchronized SynchronizedSingleton getInstance() &#123; //在对象被使用的时候才实例化 if (instance == null) &#123; instance = new SynchronizedSingleton(); &#125; return instance; &#125; &#125; 遗憾的是，他效率很低，因为99%情况下不需要同步。（因为上面的synchronized的加锁范围是整个方法，该方法的所有操作都是同步进行的，但是对于非第一次创建对象的情况，也就是没有进入if语句中的情况，根本不需要同步操作，可以直接返回instance。） 双重校验锁 123456789101112131415161718public class Singleton &#123; private static Singleton singleton; private Singleton() &#123; &#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; &#125; 线程A发现变量没有被初始化, 然后它获取锁并开始变量的初始化。 由于某些编程语言的语义，编译器生成的代码允许在线程A执行完变量的初始化之前，更新变量并将其指向部分初始化的对象。 线程B发现共享变量已经被初始化，并返回变量。由于线程B确信变量已被初始化，它没有获取锁。如果在A完成初始化之前共享变量对B可见（这是由于A没有完成初始化或者因为一些初始化的值还没有穿过B使用的内存(缓存一致性)），程序很可能会崩溃。 在J2SE 1.4或更早的版本中使用双重检查锁有潜在的危险，有时会正常工作（区分正确实现和有小问题的实现是很困难的。取决于编译器，线程的调度和其他并发系统活动，不正确的实现双重检查锁导致的异常结果可能会间歇性出现。重现异常是十分困难的。） 在J2SE 5.0中，这一问题被修正了。volatile关键字保证多个线程可以正确处理单件实例 子主题 双重校验锁优化 1234567891011121314151617public class VolatileSingleton &#123; private static volatile VolatileSingleton singleton; private VolatileSingleton() &#123; &#125; public static VolatileSingleton getSingleton() &#123; if (singleton == null) &#123; synchronized (VolatileSingleton.class) &#123; if (singleton == null) &#123; singleton = new VolatileSingleton(); &#125; &#125; &#125; return singleton; &#125; &#125; 12345678910111213141516171819202122232425class FinalWrapper&lt;T&gt; &#123; public final T value; public FinalWrapper(T value) &#123; this.value = value; &#125; &#125; public class FinalSingleton &#123; private FinalWrapper&lt;FinalSingleton&gt; helperWrapper = null; public FinalSingleton getHelper() &#123; FinalWrapper&lt;FinalSingleton&gt; wrapper = helperWrapper; if (wrapper == null) &#123; synchronized (this) &#123; if (helperWrapper == null) &#123; helperWrapper = new FinalWrapper&lt;FinalSingleton&gt;(new FinalSingleton()); &#125; wrapper = helperWrapper; &#125; &#125; return wrapper.value; &#125; &#125; 防止序列化方式 123456789101112131415161718192021222324package com.hollis; import java.io.Serializable; /** * Created by hollis on 16/2/5. * 使用双重校验锁方式实现单例 */ public class Singleton implements Serializable&#123; private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; private Object readResolve() &#123; return singleton; &#125; &#125; 抽象工厂模式 建造者模式 工厂模式 原型模式 结构型模式 适配器模式 桥接模式 组合模式 装饰模式 外观模式 享元模式 代理模式 行为型模式 模板方法模式 命令模式 迭代器模式 观察者模式 中介者模式 解析器模式（Interpreter模式） 状态模式 策略模式 责任链模式 访问者模式 使用常用设计模式 单例 策略 工厂 适配器 责任链 实现AOP 实现IOC 不用synchronized和lock，实现线程安全的单例模式 nio和reactor设计模式 网络编程 tcp、udp、http、https等常用协议 三次握手协议 四次关闭 流量控制和拥塞控制 OSI七层模型 tcp粘包和拆包 http/1.0 http/1.1 http/2 之间的区别 Java RMI Socket HttpClient cookie与session cookie被禁用，如何实现session 用Java写一个简单的静态文件的HTTP服务器 实现客户端缓存功能，支持返回304 实现可并发下载一个文件 使用线程池处理客户端请求 使用nio处理客户端请求 支持简单的rewrite规则 上述功能在实现的时候需要满足“开闭原则” 了解nginx和apache服务器特性并搭建一个对应的服务器 用Java实现FTP、SMTP协议 进程间通讯的方式 什么是CDN？如果实现 什么是DNS 反向代理 框架知识 Servlet线程安全问题 Servlet中的filter和listener Hibernate的缓存机制 Hibernate的懒加载 Spring Bean的初始化 Spring的AOP原理 自己实现Spring的IOC Spring MVC Spring Boot2.0 Spring Boot的starter原理，自己实现一个starter Spring Security 应用服务器 JBoss tomcat jetty Weblogic 工具 git&amp;svn maven&amp;gradle 高级 新技术 Java8 lambda表达式 Stream API Java9 Jigsaw Jshell Reactive Streams Java10 局部变量类型推断 G1的并行Full GC ThreadLocal握手机制 响应式编程 Spring Boot 2.0 线上问题分析 dump获取 线程Dump 内存Dump gc dump分析 分析死锁 分析内存泄漏 自己编写各种outofmemory,stackoverflow程序 HeapOutOfMemory、 Young OutOfMemory、MethodArea OutOfMemory、ConstantPool OutOfMemory、DirectMemory OutOfMemory、Stack OutOfMemory Stack OverFlow 常见问题解决思路 内存溢出 线程死锁 类加载冲突 使用工具尝试解决问题，并总结 当一个Java程序响应很慢时如何查找问题 当一个Java程序频繁FullGC时如何解决问题 如何查看垃圾回收日志 当一个Java应用发生OutOfMemory时如何解决 如何判断是否出现死锁 如何判断是否存在内存泄漏 性能优化 使用单例 使用Future模式 使用线程池 选择就绪 减少上下文切换 减小锁粒度 数据压缩 结果缓存 编译原理知识 编译与反编译 Java代码的编译与反编译 Java的反编译工具 词法分析，语法分析（LL算法，递归下降算法，LR算法），语义分析，运行时环境，中间代码，代码生成，代码优化 操作系统知识 Linux的常用命令 进程同步 缓冲区溢出 分段和分页 虚拟内存与主存 数据库知识 MySql执行引擎 数据库建模三范式 Mysql执行计划 如何查看执行计划 如何根据执行计划进行sql优化 SQL优化 事务 事务的隔离级别 事务能不能实现锁的功能 数据库锁 行锁 表锁 使用数据库实现乐观锁 数据库主备搭建 binlog 内存数据库 常用的nosql数据库 redis memcached 使用数据库锁、NoSql实现分布式锁 性能调优 数据结构和算法知识 简单的数据结构 栈 队列 链表 数组 哈希表 树 二叉树 字典树 平衡树 排序树 B树 B+树 R树 多路树 红黑树 排序算法 各种排序算法和时间复杂度 深度优先和广度优先搜索 全排列 贪心算法 KMP算法 hash算法 一致性hash算法 海量数据处理 大数据知识 Zookeeper Solr，Lucene，ElasticSearch Storm，流式计算，了解Spark，S4 Hadoop，离线计算 分布式日志收集flume，kafka，logstash 数据挖掘，mahout 网络安全 什么是XSS 什么是CSRF 什么是注入攻击 什么是文件上传漏洞 加密与解密 什么是DOS攻击和DDOS攻击 SSL，TLS，HTTPS 如何通过Hash碰撞进行DOS攻击 用openssl签一个证书部署到apache或nginx 架构 分布式 分布式事务 rpc 分布式数据库 分布式文件系统 分布式缓存 微服务 SOA 康威定律 ServiceMesh Docker &amp; Kubernets Spring Boot Spring Cloud 高并发 分库分表 CDN技术 消息队列 ActiveMQ 监控 监控什么 CPU 内存 磁盘IO 网络IO 服务监控 监控手段 进程监控 语义监控 机器资源监控 数据波动 监控数据采集 日志 埋点 Dapper 负载均衡 DNS CDN 数据一致性 扩展 云计算 IaaS SaaS PaaS 虚拟化技术 Serverlsess openstack 搜索引擎 Solr Lucene Nutch Elasticsearch 权限管理-必须的 Shiro 区块链 基础 哈希算法 Merkle树 公钥密码算法 共识算法 Raft协议 Paxos 算法与 Raft 算法 拜占庭问题与算法 消息认证码与数字签名 应用 比特币 以太坊 超级账本 人工智能 基础 数学基础 机器学习 人工神经网络 深度学习 应用场景 框架 TensorFlow DeepLearning4J 其他语言 Groovy Python Go NodeJs Swift Rust 书籍推荐 《深入理解Java虚拟机》 《Effective Java》 《深入分析Java Web技术内幕》 《大型网站技术架构》 《代码整洁之道》 《Head First设计模式》 《maven实战》 《区块链原理、设计与应用》 《Java并发编程实战》 《鸟哥的Linux私房菜》 《从Paxos到Zookeeper》 《架构即未来》 【1】简书主页·share猿【2】掘金主页·share猿【3】JavaGuide·Snailclimb 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"java","slug":"java","permalink":"https://lywlefan.github.io/tags/java/"},{"name":"指导思想","slug":"指导思想","permalink":"https://lywlefan.github.io/tags/指导思想/"},{"name":"java基础","slug":"java基础","permalink":"https://lywlefan.github.io/tags/java基础/"}]},{"title":"微服务架构的理论基础 - 康威定律","date":"2019-06-04T16:00:00.000Z","path":"2019/06/05/指导思想/java/微服务架构的理论基础 - 康威定律/","text":"概述&emsp;&emsp;关于微服务的介绍，可以参考微服务那点事。 &emsp;&emsp;微服务是最近非常火热的新概念，大家都在追，也都觉得很对，但是似乎没有很充足的理论基础说明这是正确的，给人的感觉是 不明觉厉 。前段时间看了Mike Amundsen 《远距离条件下的康威定律——分布式世界中实现团队构建》（是Design RESTful API的作者）在InfoQ上的一个分享，觉得很有帮助，结合自己的一些思考，整理了该演讲的内容。 &emsp;&emsp;可能出乎很多人意料之外的一个事实是，微服务很多核心理念其实在半个世纪前的一篇文章中就被阐述过了，而且这篇文章中的很多论点在软件开发飞速发展的这半个世纪中竟然一再被验证，这就是康威定律（Conway’s Law）。 &emsp;&emsp;在康威的这篇文章中，最有名的一句话就是： Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations. - Melvin Conway(1967) &emsp;&emsp;中文直译大概的意思就是：设计系统的组织，其产生的设计等同于组织之内、组织之间的沟通结构。看看下面的图片（来源于互联网，侵删），再想想Apple的产品、微软的产品设计，就能形象生动的理解这句话。 &emsp;&emsp;用通俗的说法就是：组织形式等同系统设计。 &emsp;&emsp;这里的系统按原作者的意思并不局限于软件系统。据说这篇文章最初投的哈佛商业评论，结果程序员屌丝的文章不入商业人士的法眼，无情被拒，康威就投到了一个编程相关的杂志，所以被误解为是针对软件开发的。最初这篇文章显然不敢自称定律（law），只是描述了作者自己的发现和总结。后来，在Brooks Law著名的人月神话中，引用这个论点，并将其“吹捧”成了现在我们熟知“康威定律”。 康威定律详细介绍&emsp;&emsp;Mike从他的角度归纳这篇论文中的其他一些核心观点，如下： 第一定律：Communication dictates design（组织沟通方式会通过系统设计表达出来） 第二定律：There is never enough time to do something right, but there is always enough time to do it over（时间再多一件事情也不可能做的完美，但总有时间做完一件事情） 第三定律：There is a homomorphism from the linear graph of a system to the linear graph of its design organization（线型系统和线型组织架构间有潜在的异质同态特性） 第四定律： The structures of large systems tend to disintegrate during development, qualitatively more so than with small systems（大的系统组织总是比小系统更倾向于分解） 一.人是复杂社会动物&emsp;&emsp;第一定律：Communication dictates design（组织沟通方式会通过系统设计表达出来） &emsp;&emsp;组织的沟通和系统设计之间的紧密联系，在很多别的领域有类似的阐述。对于复杂的系统，聊设计就离不开聊人与人的沟通，解决好人与人的沟通问题，才能有一个好的系统设计。相信几乎每个程序员都读过的《人月神话》（1975年，感觉都是老古董了，经典的就是经得起时间考验）里面许多观点都和这句话有异曲同工之妙。 &emsp;&emsp;比如《人月神话》中最著名的一句话就是 Adding manpower to a late software project makes it later –Fred Brooks, (1975) &emsp;&emsp;Boss们都听到了吗？为了赶进度加程序员就像用水去灭油锅里的火一样（无奈大家还是前赴后继）。 &emsp;&emsp;为什么？人月神话也给出了很简洁的答案：沟通成本 = n(n-1)/2，沟通成本随着项目或者组织的人员增加呈指数级增长。是的，项目管理这个算法的复杂度是O(n^2)。举个例子 5个人的项目组，需要沟通的渠道是 5*(5–1)/2 = 10 15个人的项目组，需要沟通的渠道是15*(15–1)/2 = 105 50个人的项目组，需要沟通的渠道是50*(50–1)/2 = 1,225 150个人的项目组，需要沟通的渠道是150*(150–1)/2 = 11,175 &emsp;&emsp;所以知道为什么互联网创业公司都这么小了吧，必须小啊，不然等CEO和所有人讲一遍创业的想法后，风投的钱都烧完了。 &emsp;&emsp;Mike还举了一个非常有意思的理论，叫“Dunbar Number”，这是一个叫Dunbar（废话）生物学家在1992年最早提出来的。最初，他发现灵长类的大脑容量和其对应的族群大小有一定关联，进而推断出人类的大脑能维系的关系的一些有趣估计。举例来说 亲密（intimate）朋友: 5 信任（trusted）朋友: 15 酒肉（close）朋友: 35 照面（casual）朋友: 150 &emsp;&emsp;是不是和上面的沟通成本的数字很貌似有关联？是的，我们的大脑智力只能支持我们维系这么多的关系。（大家都知道这不是程序猿擅长的领域，在开发团队里，这个值应该更小，估计和猿差不多 -_-凸 ） &emsp;&emsp;沟通的问题，会带来系统设计的问题，进而影响整个系统的开发效率和最终产品结果。 二.一口气吃不成胖子，先搞定能搞定的&emsp;&emsp;第二定律：There is never enough time to do something right, but there is always enough time to do it over（时间再多一件事情也不可能做的完美，但总有时间做完一件事情） Eric Hollnagel是敏捷开发社区的泰斗之一，在他《Efficiency-Effectiveness Trade Offs》 一书中解释了类似的论点。 &emsp;&emsp;系统越做越复杂，功能越来越多，外部市场的竞争越来越剧烈，投资人的期待越来越高。但人的智力是有上限的，即使再牛逼的人，融到钱再多也不一定招到足够多合适的人。对于一个巨复杂的系统，我们永远无法考虑周全。Eric认为，这个时候最好的解决办法竟然是——“破罐子破摔”。 &emsp;&emsp;其实我们在日常开发中也经常碰到。产品经理的需求太复杂了？适当忽略一些细节，先抓主线。产品经理的需求太多了？放弃一些功能。 &emsp;&emsp;据说Eric被一家航空公司请去做安全咨询顾问，复杂保证飞机飞行系统的稳定性和安全性。Eric认为做到安全有两种方式： 常规的安全指的是尽可能多的发现并消除错误的部分，达到绝对安全，这是理想。 另一种则是弹性安全，即使发生错误，只要及时恢复，也能正常工作，这是现实。 &emsp;&emsp;对于飞机这样的复杂系统，再牛逼的人也无法考虑到漏洞的方方面面，所以Eric建议放弃打造完美系统的想法，而是通过不断的试飞，发现问题，确保问题发生时，系统能自动复原即可，而不追求飞行系统的绝对正确和安全。 &emsp;&emsp;下面的图很好的解释了这个过程： &emsp;&emsp;听着很耳熟不是吗？这不就是 持续集成 和敏捷开发吗？的确就是。 &emsp;&emsp;另一方面，这和互联网公司维护的分布式系统的弹性设计也是一个道理。对于一个分布式系统，我们几乎永远不可能找到并修复所有的bug，单元测试覆盖1000%也没有用，错误流淌在分布式系统的血液里。解决方法不是消灭这些问题，而是容忍这些问题，在问题发生时，能自动回复，微服务组成的系统，每一个微服务都可能挂掉，这是常态，我们只有有足够的冗余和备份即可。即所谓的 弹性设计（Resilience） 或者叫高可用设计（High Availability）。 三.种瓜得瓜，做独立自治的字系统减少沟通成本&emsp;&emsp;第三定律：There is a homomorphism from the linear graph of a system to the linear graph of its design organization（线型系统和线型组织架构间有潜在的异质同态特性） &emsp;&emsp;这是康威第一定律组织和设计间内在关系的一个具体应用。更直白的说，你想要什么样的系统，就搭建什么样的团队。如果你的团队分成前端团队，Java后台开发团队，DBA团队，运维团队，你的系统就会长成下面的样子： &emsp;&emsp;相反，如果你的系统是按照业务边界划分的，大家按照一个业务目标去把自己的模块做出小系统，小产品的话，你的大系统就会长成下面的样子，即微服务的架构 &emsp;&emsp;微服务的理念团队间应该是 inter-operate, not integrate 。inter-operate是定义好系统的边界和接口，在一个团队内全栈，让团队自治，原因就是因为如果团队按照这样的方式组建，将沟通的成本维持在系统内部，每个子系统就会更加内聚，彼此的依赖耦合能变弱，跨系统的沟通成本也就能降低。 四.合久必分，分而治之&emsp;&emsp;第四定律： The structures of large systems tend to disintegrate during development, qualitatively more so than with small systems（大的系统组织总是比小系统更倾向于分解） &emsp;&emsp;前面说了，人是复杂的社会动物，人与人的通过非常复杂。但是当我们面对复杂系统时，又往往只能通过增加人力来解决。这时，我们的组织一般是如何解决这个沟通问题的呢？Divide and conquer,分而治之。大家看看自己的公司的组织，是不是一个一线经理一般都是管理15个人以下的？二线经理再管理更少的一线？三线再管理更少的，以此类推。（这里完全没有暗示开发经理比程序猿更难管理） &emsp;&emsp;所以，一个大的组织因为沟通成本/管理问题，总为被拆分成一个个小团队。 创业的想法太好了，反正风投钱多，多招点程序猿 人多管不过来啊，找几个经理帮我管，我管经理 最后， 康威定律 告诉我们组织沟通的方式会在系统设计上有所表达，每个经理都被赋予一定的职责去做大系统的某一小部分，他们和大系统便有了沟通的边界，所以大的系统也会因此被拆分成一个个小团队负责的小系统（微服务是一种好的模式） 康威定律如何解释微服务的合理性&emsp;&emsp;了解了康威定律是什么，再来看看他如何在半个世纪前就奠定了微服务架构的理论基础。 人与人的沟通是非常复杂的，一个人的沟通精力是有限的，所以当问题太复杂需要很多人解决的时候，我们需要做拆分组织来达成对沟通效率的管理 组织内人与人的沟通方式决定了他们参与的系统设计，管理者可以通过不同的拆分方式带来不同的团队间沟通方式，从而影响系统设计 如果子系统是内聚的，和外部的沟通边界是明确的，能降低沟通成本，对应的设计也会更合理高效 复杂的系统需要通过容错弹性的方式持续优化，不要指望一个大而全的设计或架构，好的架构和设计都是慢慢迭代出来的 &emsp;&emsp;带来的具体的实践建议是： 我们要用一切手段提升沟通效率，比如slack，github，wiki。能2个人讲清楚的事情，就不要拉更多人，每个人每个系统都有明确的分工，出了问题知道马上找谁，避免踢皮球的问题。 通过MVP的方式来设计系统，通过不断的迭代来验证优化，系统应该是弹性设计的。 你想要什么样的系统设计，就架构什么样的团队，能扁平化就扁平化。最好按业务来划分团队，这样能让团队自然的自治内聚，明确的业务边界会减少和外部的沟通成本，每个小团队都对自己的模块的整个生命周期负责，没有边界不清，没有无效的扯皮，inter-operate, not integrate。 做小而美的团队，人多会带来沟通的成本，让效率下降。亚马逊的Bezos有个逗趣的比喻，如果2个披萨不够一个团队吃的，那么这个团队就太大了。事实上一般一个互联网公司小产品的团队差不多就是7，8人左右（包含前后端测试交互用研等，可能身兼数职）。 &emsp;&emsp; 再对应下衡量微服务的标准，我们很容易会发现他们之间的密切关系： 分布式服务组成的系统 按照业务而不是技术来划分组织 做有生命的产品而不是项目 Smart endpoints and dumb pipes（我的理解是强服务个体和弱通信） 自动化运维（DevOps） 容错 快速演化 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"java","slug":"java","permalink":"https://lywlefan.github.io/tags/java/"},{"name":"指导思想","slug":"指导思想","permalink":"https://lywlefan.github.io/tags/指导思想/"},{"name":"微服务","slug":"微服务","permalink":"https://lywlefan.github.io/tags/微服务/"}]},{"title":"成事-冯唐","date":"2019-05-29T16:00:00.000Z","path":"2019/05/30/读书/归档/2019/5月/成事-冯唐/","text":"能治国能安民，灭吴霸越，堪称一代名相。知进退懂经营，三致千金，不愧千秋商圣。 读书笔记 战略上蔑视敌人，战术上重视敌人 有操守而无官气，多条理而少大言 人才，朴实、不贪是核心。有了核心，再有长处，可以用；没有核心，有长处也不能用。 第一要锻炼心志，早起、打坐；第二要去除妄念，别多想、别怕死——做个好领导不容易。团队成员的生老病死也要照顾。 有两件事物我愈是思考愈觉神奇，心中也愈充满敬畏，那就是头顶上的星空与内心的道德准则。 手上有刀，心里有佛。脚下有闹市，心里有山水。 上班埋头做事，下班埋头文艺；开会杀伐决断，然后去博物馆看美好书画、美好器物，养眼养心。 做事，争先，不顾身；修行，避让，不争抢。 首先，敬畏内心；其次，尊重团队；再次，害怕舆论 做大事，有担当，就靠聪明和强悍。别人做一，你做百；别人做十，你做千；只要功夫下到，笨人也会变聪明，软蛋也会变强者。 别人拼命吹牛，你拼命读书。别人拼命喝酒，你拼命读书。别人拼命做官，你拼命读书。 运筹帷幄是无形之功，公司管理运行架构是无形之功，风险管控是无形之功，人才选用育留是无形之功，文化建设是无形之功，舆情管理是无形之功，行政是无形之功，后勤保障是无形之功……一个团队，做指挥的人，做幕后的人，做的就是无形之功。 强悍，要建立在聪明的基础上。没有聪明，所谓“强悍”，就是蛮横，就是瞎胡闹。“明”字自己想不出，要认对人，让明白人替你想，然后，笃信之，这是“明”的一个变种。 虚心，首先是“有一心”，有主见，有方向，有坚守；其次，“无成心”，不固执，没有成见。 做事，不是埋头就做，而是先要有事情的全局、了解组成事情的各个环节。“大处着眼，小处着手”，小处着手之前，最好能大处着眼。 埋头做事，不问前程，成功在老天，享受在后人。 见识要多（见识多也没捷径：万卷书，万里路，多干事，多见有见识的人）； 要反复多次地想，要谨慎小心地给出意见； 对牵涉的各方利益，心里要权衡，要有公平心，要有主次、取舍等判断。 三个角度努力 一、千山鸟飞绝，万径人踪灭，一切都是浮云，到底皆为涅槃，佛教四圣谛之寂静涅槃要长记于心。 二、领会那些成事之外、做事之余的小快乐：东郊时雨，初雪在庙，和妙人分一瓶酒，闭门读一本书。 三、孔丘说：天下有道，丘不与易也。要意识到，每个猛人有每个猛人的苦。作为另一个猛人，守住自己的志向、吃自己的苦，不必羡慕别人。 吾屡教家人崇俭习劳，盖艰苦则筋骨渐强，娇养则精力愈弱也。 现在流行“女孩子要贵养”，纯属胡扯。中国的女性地位本来就低，男女性别不平等，工作机会和上升空间不平等，女孩子再“贵养”，像养宠物，进入社会如何竞争？ 认命，不是投降；认命，是知道自己能做什么，然后，努力去做，是谓“安命”。 听话，出活 做事越多，成事越多，噪音越多。和噪音，不要讲理，要讲不理——去你的，你能你上。 成事的人往往敏感。成事之后，有闲话，不要想，不要想，不要想，做自己，做自己，做自己。 往死里练他们，能练出来就出来了，练不出来就淘汰。剩下的，都是好手。非常残酷，非常有效。成人的世界，万事皆难，除了长肉，哪有什么是容易的？ 不求胜过别人，只求胜过自己。 在商学院千百次写商业计划书，不如你在现实中写一个商业计划书，然后忽悠一些人信你了、投你了，然后你败了，所有人都恨你、都鄙视你；然后你又写了一个商业计划书，你又忽悠了一些人信你了、投你了，然后你又败了。这种痛，是那么痛；这种修行，才是真实的修行。 乃知自己全无本领，凡事都见得人家有几分是处”——认清自己，用好他人。 第一，知道自己“无本领”，才需要用人； 第二，知道他人的长处，才能用好人； 第三，恰当地表现出自己的“无本领”（办事圆融），才能让他人为自己所用。 己欲立而立人，己欲达而达人，成大事者让他人成大事 真正长见识、添阅历的时候，一定不是顺风顺水、躺着都挣钱的时候，一定是惨败、跌到谷底、破鼓众人敲、破墙众人推的时候。 “悔字诀”，上面已经说过，认清自己的长处和短处，用好周围跟你干的兄弟。 不惯着，多磨炼 不惯着。不惯着自己，不惯着团队，不惯着孩子，不惯着父母。越惯着，人性的恶越显现，越坚忍耐烦、劳怨不避，人性的善越显现。 一、俭朴生活，过中等偏下的生活，从心底里，以智慧和气质为顶级美好之物，以立功和立言为顶级追求之物，爱智慧多过爱宝石，爱买书多过爱买包包。 二、如果做不到，至少做到量入为出，轻奢而止。 三、尽量少雇人。越多助理，越多人事，越多闲话，越多麻烦，既然有了滴滴，就少养司机，既然有了外卖，就少养厨师——归根结底，还是人生三个基本原则：第一，自己的事情自己做；第二，不给别人添没必要的麻烦；第三，自己根据自己喜好和特殊情况自己定。 老洛克菲勒不是总这么谦逊，他说过：“我不喜欢钱，我喜欢的是赚钱。 他还说过一句修炼到顶尖的成事人才有自信说的话：“即使把我的衣服脱光，再放到渺无人烟的沙漠中，只要有一个商队经过，我又会成为百万富翁。” 没有天赋，想再多也没用，天花板在那儿摆着。但没有天赋，不意味着没有成果，有一个好习惯，坚持做下去，就会见效。 字因人传，买的人能从曾国藩亲手书写的笔触里、文字里汲取精神力量，书法本身的美就退居第二位了。 能够顶到自己的天花板，也不是件容易事 此处要敬畏：天赋还是硬硬地在那里，天赋还是比后天努力更重要。 如何判断是否在某个方面有天赋？ 一、你偷偷摸摸想去做，“虽千万人吾往矣”，别人怎么拦着不让你做都没有用。 二、你做的时候有快感，做完之后有满足感。 三、你做出来的东西有自己的风格，有相当多的人愿意自掏腰包买。 脸面，不是别人给的，是自己给自己的。 凡文有气则有势，有识则有度，有情则有韵，有趣则有味。 识，有天生成分，但是多读书、多行路，能后天修修。情，爱天地自然，爱人，内心偶尔或者经常肿胀。趣，好玩，角度刁蛮，不是古板的爱，而是俏皮的爱、曲折的爱、隐约的爱。 内举不避亲，如果还需要再推荐两本：一、老洛克菲勒写给小洛克菲勒的三十八封信。二、冯唐的《三十六大》。 职场中，这种人挺多见：什么都会，一无所长；说起来头头是道，做起来一塌糊涂。 这段话是说学书法的笨功夫，单日临，双日摹，遇困顿，熬过去。 不只是书法——对普通人来说，学任何技能，做任何事，都是如此。曾国藩教子，字字真切，把儿子当成普通人教育，不是当成小天才宠溺。 我们周围所见的绝大多数小孩儿和晚辈（包括自己的孩子和同族后辈）都是凡人、俗人、庸才。所以，笨功夫才是真功夫。 第一句：怕什么，就做什么。第二句：事情能做成，要么是因为有利益，要么是因为被强迫。所谓无为而成，无心而成，都是瞎扯。 判断一个事儿能否成，三原则：一、让不让干？二、会不会干？三、想不想干？ 成事的人，以平常心看待嫉妒和贪心，别苛责自己，以平衡心处之，不要让底线失守，不过分，不害人。 附作《忮求诗二首》录左。 不忮善莫大于恕，德莫凶于妒。妒者妾妇行，琐琐奚比数。己拙忌人能，己塞忌人遇。己若无事功，忌人得成务。己若无党援，忌人得多助。势位苟相敌，畏逼又相恶。己无好闻望，忌人文名著。己无贤子孙，忌人后嗣裕。争名日夜奔，争利东西骛。但期一身荣，不惜他人污。闻灾或欣幸，闻祸或悦豫。问渠何以然，不自知其故。尔室神来格，高明鬼所顾。天道常好还，嫉人还自误。 幽明丛诟忌，乖气相回互。重者灾汝躬，轻亦减汝祚。我今告后生，悚然大觉悟。终身让人道，曾不失寸步。终身祝人善，曾不损尺布。消除嫉妒心，普天零甘露。家家获吉祥，我亦无恐怖。不求知足天地宽，贪得宇宙隘。岂无过人姿，多欲为患害。在约每思丰，居困常求泰。富求千乘车，贵求万钉带。未得求速偿，既得求勿坏。芬馨比椒兰，磐固方泰岱。求荣不知厌，志亢神愈忲。岁燠有时寒，月明有时晦，时来多善缘，运去生灾怪。诸福不可期，百殃纷来会。片言动招尤，举足便有碍。戚戚抱殷忧，精爽日凋瘵。 矫首望八荒，乾坤一何大！安荣无遽欣，患难无遽憝，君看十人中，八九无倚赖。人穷多过我，我穷犹可耐。而况处夷涂，奚事生嗟忾？于世少取求，俯仰有余快。俟命堪终古，曾不愿乎外日课四条 日课四条一曰慎独则心安 二曰主敬则身强 敬事，认真做事。小处着手，小处不小，如临深渊，如履薄冰。 如果认真地做每一件自己决定要做的事，如果诚恳地对每一个自己遇见的人， 时间长了，就是一个成事的人，就是一个身强的人。 三曰求仁则人悦 四曰习劳则神钦 日记 精神足，注意力集中，做事情专注。专注之后，如果累了，不要勉强，给精神留点余地，明天再干。 一日事一日毕，不能拖。拖延症是病，要治。叉手立办，不占内存，不耗脑子，睡得更香。 天天待在个人的舒适区域，强不起来。自强，就是自找不舒服。一直自找不舒服，直到再也找不到不舒服，就是一个能成事的猛人。 第一步，承认自己的不足；第二步，改掉它，不可惜。 不为圣贤，便为禽兽；莫问收获，但问耕耘。 实事求是。在你乱七八糟的时候，在你不知道方向的时候，实事求是，懂就是懂，不懂就是不懂。德不配位是常见的大忌。你想想，你的本事和你得到的是否匹配？如果不匹配，你还坚持，劈你的雷也在坚持要劈你的路上了。 天道恶巧，天道恶盈，天道恶贰。贰者，多猜疑也，不忠诚也，无恒心也。老天爷不喜欢三种东西：巧、盈、二。取巧、自满、不定。什么是二：猜疑心、不忠心、无恒心。想讨好老天者，请读《不二》。想过好一生，也不复杂，不做老天不喜欢的事，不取巧、不自满、不犹豫，不二。 天下无易境，天下无难境；终身有乐处，终身有忧处。 取人为善，与人为善；乐以终身，忧以终身。 天下断无易处之境遇，人间哪有空闲的光阴？ 第一，没有舒适区域，大家都不容易。诗和远方在天外。 第二，时间不是用来挥霍的，是用来干活的。 做事求回报，肯定要失望。 天下事未有不从艰苦中得来而可久可大者也。 容易的事，都是小事。大事、长远的规划，都难做。难做的大事，艰难地慢慢做，一定有可以做成的那一天。不难，不做，永远不成。 用兵最戒骄气惰气，作人之道，亦惟骄惰二字误事最甚。 说到底，还是事功说话、作品说话。牛吹到天上，认识所有人，你的事功在哪里？你的作品在哪里？你自己的落脚点在哪里？ 与人为善、取人为善之道，如大河水盛足以浸灌小河，小河水盛亦足以浸灌大河，无论为上为下，为师为弟，为长为幼，彼此以善相浸灌，则日见其益而不自知矣。 与人打交道，不管给予，还是获取，要始终秉承一个善意、好心。但是，口花花的所谓“为你好”，不是“善”，切记。要有行动，要有给予，给钱、给资源、给时间，是真正的给予，反之亦然，“彼此以善相浸灌”。 我有几个老哥，每几个月，我烦了的时候，总是找他们去喝酒。我去了他们就开心，我喝嗨了他们就全劝我早些走，去成就那些我想成就的事儿。十几年下来，我有一天忽然问自己，他们为什么事开心？他们要成就什么？我竟然一无所知。 天下凡物加倍磨治，皆能变换本质，别生精彩，况人之于学乎！ 朽木，因为艺术，也能成梵高。姑且言之，姑且信之。 见识越多，越能知道自己的小，越能把自己放到合适的位置。曾国藩的伟大在于越干越觉得自己渺小，更多成事的人是越干越觉得自己无所不能。 个人永远渺小，个人永远是过客，成事的人最多是个协调者。 带团队的智慧。 第一，把我的知识、技能多教给几个人；第二，用他人的长处补充我的不足。 百种弊病，皆从懒生。懒则弛缓，弛缓则治人不严，而趣功不敏，一处迟则百处懈也。 带团队不能懒，一懒生百病——第一，纪律松懈；第二，管理不严格；第三，临战、做事迟钝，没有战斗力；第四，一处迟钝，拖累整个项目组。 不能痛哭长夜的人，不足以语人生。我看见，不能早起的人，不足以托重任。 再有，不能控制自己时间的人，答应之后无故爽约的人，绝对不是能帮你成事的人，从你人生中删除吧。 勤劳而后憩息，一乐也。至淡以消忮心，二乐也。读书声出金石，三乐也。 曾国藩的欢喜三境界：累死，能酣睡；看开，能笑忘；高声朗读，声若金石。 病房、山房、书房，都是心房，去待待，去打开，那些房间能打开多大，你的心胸就有多大。 我也常常担心，骂我的人是不是太多了？但是，我按曾国藩说的再认真检点一下我自己：你是不是在不懂装懂？是不是在无病呻吟？是不是在欺世盗名？ 难，不意味着不做，所以要天天讲、月月讲，尽力去做。 屡败屡战和屡战屡败不一样。一个是还有胜算，甚至一定能胜，一个是一定败，一定再败。 成事的人，暂时没了成事的环境，并不意味着放任自己，而是坚持锻炼，保持体重，保持体能，拼命读书、思考。 既然做事，就有掣肘、不顺心。握越大权，做越大事，更是如此。“借人之拂逆，以磨砺我之德性”，都是修行。 英雄不是脚踏祥云，而是劳心劳力。 每日须以精心果力独造幽奥，直凑单微，以求进境。一日无进境，则日日渐退矣。 关于人性，关于集体人性，关于中国历史智慧，有些见识，要日日修，日日挖掘。总觉得没真明白，总觉得自己偷懒了。 于清早单开本日应了之事，本日必了之。 自己给自己买个本子，每天早上列出每天必干的三件事，每天上床前检查，至少干完第一件。 更多的现世人，哪怕吃一个饭、开一个会，都不能不时常看他的手机，似乎有天大的事儿找他。 文集 独也者，君子与小人共焉者也。小人以其为独，而生一念之妄，积妄生肆，而欺人之事成。君子懔其为独而生一念之诚，积诚为慎，而自慊之功密。彼小人者，一善当前，幸人之莫我察也，则趋焉而不决。一不善当前，幸人之莫或伺也，则去之而不力。幽独之中，情伪斯出，所谓欺也。惟夫君子者，惧一善之不力，则冥冥者有堕行，一不善之不去，则涓涓者无已时。屋漏而懔如帝天，方寸而坚如金石，独知之地，慎之又慎。——《慎独论 不要和很多人的集体人性抗衡，不要和人类共同的弱点死磕，基本都会输。集体人性担心彼此的降维攻击，都会在制衡状态下呈现人性之恶 风俗之厚薄奚自乎？自乎一二人心之所向而已。民之生，庸弱者戢戢皆是也，有一二贤且智者，则众人君之而受命焉；尤智者，所君尤众焉。此一二人者之心向义，则众人与之赴义，一二人者之心向利，则众人与之赴利。众人所趋，势之所归，虽有大力莫之敢逆。故曰挠万物者莫疾乎风。风俗之于人之心，始乎微，而终乎不可御者也。先王之治天下，使贤者皆当路在势，其风民也皆以义，故道一而俗同。世教既衰，所谓一二人者不尽在位，彼其心之所向，势不能不腾为口说而播为声气。而众人者，势不能不听命而蒸为习尚。（启超按：“势不能不”四字极见得到，此深于社会学者之言也。）于是乎徒党蔚起，而一时之人才出焉。有以仁义倡者，其徒党 亦死仁义而不顾；有以功利倡者，其徒党亦死功利而不返。水流湿，火就燥，无感不讐，所从来久矣。今之君子之在势者，辄曰天下无才。彼自尸于高明之地，不克以己之所向转移习俗，而陶铸一世之人，而翻谢曰无才，谓之不诬可乎？十室之邑，有好义之士，其智足以移十人者，必能拔十人中之尤者而材之。其智足以移百人者，必能拔百人中之尤者而材之。然则转移习俗，而陶铸一世之人，非特处高明之地者然也，凡一命以上，皆与有责焉者也。有国家者得吾说而存之，则将慎择与共天位之人。士大夫得吾说而存之，则将惴惴乎谨其心之所向，恐一不当而坏风俗，而贼人才。循是为之，数十年之后，万一有收其效者乎？非所逆睹已。（启超按：此篇公之少作也。深明社会变迁之原理，我国数千年来不多见之名文也。公于 穷时、达时皆能以心力转移风气，亦可谓不负其言矣。）——《原才》 又有多少人能简单、坦诚、阳光地和僚友们掰扯是非、毁誉和成败？掰扯之后，反复掰扯之后，又有几个人能简单、坦诚、阳光地接受和改善？ 学贵初有决定不移之志，中有勇猛精进之心，末有坚贞永固之力。——《国朝先正事略序》 先立志，再用心，最后坚持住。不做到中国第一、世界前列，怎么好意思收兵？ 易做的事，都是小事；易读的书，都是简单清浅的书。不要走捷径，捷径都是通向邪路最快的路。 走远路，下笨功夫，一点一滴进步。全力争取名实相符，尽量不要德不配位。 在现世，难。现世的常规是能捞一笔是一笔，能骗一时是一时，能忽悠一拨儿是一拨儿，成名要趁早。 君子做官路子多，都是从保持独立、不求人（不依附大官）开始；小人做官路子也多，都是从求人（依附大官）开始 天可补，海可填，南山可移，日月既往不可复追。其过如驷，其去如矢，虽有大智神勇莫可谁何。光阴之迁流如此，其可畏也，人固可自暇逸哉？——《朱玉声寿序》 兵[插图][插图]一个，将[插图][插图]一窝。 不干事、不成事的风气稳定，老的能人都走光了，新来的能干的也一个个被整走。 大到一个社会，小到一个团队，才华卓异的人少见，蠢笨的人也少见，大多数是普通人（中材）。普通人，要有精英引导、教育、带动。 坚守常识，超越人性，就是精英。 贫富太过悬殊的结果，精英、群众，都是死，虽然死法不同。 即使在乱世，即使在末世，有些鸟生下来就不是为了躲枪子儿的，有些人活着，就是为了成事的。这是人世轮回、不至于万劫不复的根本。 做事在人，成事在天。先做再说，于心无憾。至于闲话，算个屁。 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"曾国藩","slug":"曾国藩","permalink":"https://lywlefan.github.io/tags/曾国藩/"},{"name":"解读","slug":"解读","permalink":"https://lywlefan.github.io/tags/解读/"}]},{"title":"常用工具收集","date":"2019-05-27T16:00:00.000Z","path":"2019/05/28/工具/常用工具收集/","text":"工欲善其事，必先利器！ 常用工具总结办公效率提升的工具 好用的markdown编辑器:Ulysses 支持系统:mac 非常好用的markdown编辑器:inspire 支持系统:windows Alfred:解放双手的神器 支持系统: mac Wox:解放双手的神器 支持系统:windows 离线文档工具 dash 系统:mac Velocity 系统:windows 日常小工具 LICEcap(比较好用的生成gif的小工具) CheatSheet:CheatSheet可不仅仅是把快捷键集中在一个表单上按住command键两秒钟，CheatSheet就会自动弹出来，告诉你当前程序的快捷键都有哪些。 支持系统:mac 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"工具","slug":"工具","permalink":"https://lywlefan.github.io/tags/工具/"},{"name":"收藏","slug":"收藏","permalink":"https://lywlefan.github.io/tags/收藏/"}]},{"title":"名言收录","date":"2019-05-26T16:00:00.000Z","path":"2019/05/27/名言收录/","text":"好记性不如烂笔头! 技术总是短期被高估，但长期被低估。 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"collection","slug":"collection","permalink":"https://lywlefan.github.io/tags/collection/"}]},{"title":"我的文章收藏夹","date":"2019-05-26T16:00:00.000Z","path":"2019/05/27/自律给我自由,自律让我成长/","text":"好记性不如烂笔头! 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"自我承诺","slug":"自我承诺","permalink":"https://lywlefan.github.io/tags/自我承诺/"}]},{"title":"我的文章收藏夹","date":"2019-05-23T16:00:00.000Z","path":"2019/05/24/文章收藏/","text":"好记性不如烂笔头! 1.技术栈WEB开发前端后端java 基础 springboot 监控 grafana python 基础 Python - 100天从新手到大师·骆昊 1.2.高级技术1.2.1.深度学习 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"collection","slug":"collection","permalink":"https://lywlefan.github.io/tags/collection/"}]},{"title":"我的网址收藏夹","date":"2019-05-22T16:00:00.000Z","path":"2019/05/23/网址收藏/","text":"目标刻在岩石上，方法写在沙滩上. 1.技术栈1.1.WEB开发1.1.1.前端1.1.2.后端 程序员DD 周立|Spring Cloud 泥瓦匠BYSocket的博客 KL博客 Edison Xu’s Blog 梁桂钊的博客 城南往事 Any-Video 钿畑的博客 chenssy 徐靖峰|个人博客 猿天地 crossoverjie 芋道源码 Pure White 小柒 汤雪华的博客 kafka核心技术讲解作者·huxihx 黄小斜 黄小斜github 1.1.3.项目管理 张逸的博客(ThoughtWorks架构师) 1.2.高级技术1.2.1.深度学习 神经网络与深度学习·邱锡鹏 2.运营3.管理4.博客 技匠社 少数派 李学凯 4.1.新闻咨询4.1.1.本地新闻咨询 华商网 西安晚报 三秦都市晚报 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"collection","slug":"collection","permalink":"https://lywlefan.github.io/tags/collection/"}]},{"title":"5月22日日报","date":"2019-05-21T16:00:00.000Z","path":"2019/05/22/开源项目学习/WxJava/WxJava项目介绍/","text":"【1】简书主页·share猿【2】掘金主页·share猿【3】WxJava ·班纳睿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"开源项目","slug":"开源项目","permalink":"https://lywlefan.github.io/tags/开源项目/"},{"name":"微信sdk","slug":"微信sdk","permalink":"https://lywlefan.github.io/tags/微信sdk/"},{"name":"java","slug":"java","permalink":"https://lywlefan.github.io/tags/java/"}]},{"title":"UNIX环境高级编程","date":"2019-05-21T16:00:00.000Z","path":"2019/05/22/读书/归档/2019/5月/UNIX环境高级编程/","text":"多读书，多看报，少吃零食，少睡觉！ 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"读书","slug":"读书","permalink":"https://lywlefan.github.io/tags/读书/"},{"name":"技术","slug":"技术","permalink":"https://lywlefan.github.io/tags/技术/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://lywlefan.github.io/tags/计算机基础/"},{"name":"操作系统","slug":"操作系统","permalink":"https://lywlefan.github.io/tags/操作系统/"},{"name":"UNIX","slug":"UNIX","permalink":"https://lywlefan.github.io/tags/UNIX/"}]},{"title":"下一个倒下的会不会是华为(田涛、吴春波)","date":"2019-05-21T16:00:00.000Z","path":"2019/05/22/读书/归档/2019/5月/下一个倒下的会不会是华为-田涛、吴春波/","text":"多读书，多看报，少吃零食，少睡觉！ 人物记录任正飞 著作 《我的父亲母亲》 《北国之春》 笔记摘抄引子华为管理哲学&emsp;&emsp;任正非说:“我们没有任何背景，也没有任何资源，我们除了拥有我们自己，其实一无所有。”“一切进步都掌握在自己手中，不在别人。” &emsp;&emsp;以客户为中心，以奋斗者为本，长期坚持艰苦奋斗。 G:华为掌门人的哲学用实际行动植根在了每个华为人的心中，从全民持股到耗散机制，这个集体有着共同的目标，而任就是点亮远处灯塔的那个人。他们只做好自己，学习别人的优点，反思别人的缺点，坦然面对一切，居安思危，砥砺前行！正如作者在文中说：如同铀原子在中子轰击下产生的核能量一样，你身上的小小原子核，在价值观的驱使下，发生了巨大的原子能。 华为初步形成了一个稳定与动态相融合的“金字塔”&emsp;&emsp;最高层是组织的思想领袖群体，次高层是一批企业战略家和技术领袖，第三层是数百位各个功能体系的指挥员，他们必须具备战略思维，同时又调兵遣将、决策局部战役的统帅力；第四层是数千位经营、管理与研发方面的中基层管理者、技术领头人；“金字塔”的基座是10多万普通的知识员工，他们代表着华为这架商业战车真正战斗力与竞争力。 是什么让华为快速发展？&emsp;&emsp;是一种哲学思维，它植根于广大骨干心中。这就是“以客户为中心，以奋斗者为本，长期艰苦奋斗”的文化。这并不是什么背景，更不是什么上帝。 六个字 开放 妥协 灰度 自我批判&emsp;&emsp;变化是永恒的，所以观念也要随之改变，思考一刻也不能停息。 不只任正非孤独，华为也是&emsp;&emsp;华为没有成功，只是在成长。 孤独，学会欣赏孤独&emsp;&emsp;他没有娱乐、体育的任何一项爱好，唯一的嗜好就是阅读和思考，他也没有政界、商界的朋友，可以说他从学校到部队到华为，几乎没有朋友。但他善于交流，从国内到国际，从经济、政治乃至外交，无一不侃侃而谈。但这一切也脱不开对华为的思考。 &emsp;&emsp;实践是痛苦的。为了推动、驱使或者牵引10多万知识分子到全世界攻城略地、开疆拓土，不仅需要领袖们“竭智”——绞尽脑汁去思考，也需要老大们“竭力”——冲锋在前。 第一章：常识·真理：以客户为中心客户：华为存在的唯一理由&emsp;&emsp;华为的明天在哪里？出路在哪里？ 阿尔卡特的困惑和迷茫让我不仅问自己，我的明天在哪里？出路在哪里？华为高举“以客户为中心”的旗帜，客户是华为存在的唯一理由，他是一切企业存在的唯一理由。我存在的意义是为这个世界创造更大的价值，修身，齐家，奉国！我的方向在哪里？我该如何走，我内心是迷茫的！我想创造更大的价值，但是感觉自己无能无力，只能把手头的事情做好。而你又能做什么？假如给你一个创造巨大价值的机会，你能否把我住？能否胜任？扪心自问，我还需要不断去历练，不断去打磨！每一天都是新的开始！加油！ 华为四大战略内容&emsp;&emsp;为客户服务是华为存在的唯一理由；客户需求是华为发展的原动力。 眼睛盯着客户，屁股对着老板 &emsp;&emsp;在2010年的一次会议上，任正非进一步指出：在华为，坚决提拔那些眼睛盯着客户，屁股对着老板的员工；坚决淘汰那些眼睛盯着老板，屁股对着客户的干部。前者是公司价值的创造者，后者是牟取个人私利的奴才。各级干部要有境界，下属屁股对着你，自己可能不舒服，但必须要善待他们。 被扭曲的常识 &emsp;&emsp;让客户自觉掏腰包，让更多客户掏腰包，让客户长期掏腰包，谁就能变得更伟大。 &emsp;&emsp;百年西方管理学的核心思想，绕来绕去还是离不开一个根本：如何围绕消费者的需求，为公司定位，为管理者定位，为公司产品定位。 围绕消费者的需求，字字珠玑，找到消费者就能找到市场，找到市场就能做服务，做好服务，做精服务，不断思考，不断反思，客户是上帝！ &emsp;&emsp;管理大师德鲁克把企业定义为：创造客户。 偏离客户，谁来养活我们 &emsp;&emsp;2001年7月，公司内刊《华为人》报上，有一篇文章题目为“为客户服务是华为存在的理由”，任正非在审稿时，将其改为“为客户服务是华为存在的唯一理由”，他认为：华为命中注定是为客户而存在的，出来客户，华为没有存在的任何理由，所以是唯一理由。 &emsp;&emsp;钱钟书说：“真理都是赤裸裸的。”华为高管们则说：“不要把华为文化复杂化，不要把华为文化细枝末节化。” “百年帝国”的衰落 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"读书","slug":"读书","permalink":"https://lywlefan.github.io/tags/读书/"},{"name":"科技历","slug":"科技历","permalink":"https://lywlefan.github.io/tags/科技历/"},{"name":"管理","slug":"管理","permalink":"https://lywlefan.github.io/tags/管理/"},{"name":"励志","slug":"励志","permalink":"https://lywlefan.github.io/tags/励志/"}]},{"title":"数化万物-大数据重点战略实验室","date":"2019-05-17T16:00:00.000Z","path":"2019/05/18/读书/归档/2019/5月/数化万物-大数据重点战略实验室/","text":"数化万物，智在融合。 关键词专业名词 数据采集 数据存储 数据分析 数据流通 大数据交易 工业大数据 云密码 量子保密通信：利用量子力学基本原理和”一次一密”加密体制来实现信息安全传递的一种全新的保密通信方法。 新学到的 澎湃社 《刷新：重新发现商业与未来》 读书笔记数化万物，智在融合国家发展和改革委员会副主任林念提出中国发展数字产业化的重点 一是增强数字技术的创新能力。 二是加速数字产业化和产业数字化。 三是着力推进“互联网+政务服务” 四是着力拓展数字经济的国际合作空间。 五是着力强化数字经济法治体系建设。 中国科学院院士-梅宏提出构建大数据体系关键点 一是数据资产地位的确立 二是建立数据的管理体制和机制 三是促进数据的共享和开放 四是保障数据安全与隐私保护 如何使人工智能变成人工智能产业？- 张䥽（po） 数据 人工智能算法 计算机资源 应用场景 &emsp;&emsp;有了大数据不一定能创造价值，因为我们面临诸多的挑战：一是数据质量问题，二是数据处理理论和方法，三是计算速度慢能耗大等问题。 加拿大新经济学家唐·塔普斯科特&emsp;&emsp;代表互联网的第二个发展阶段的区块链、分布式账本技术在保障数据与网络安全方面发挥着重要的作用。任何有价资产都可以通过区块链以安全、私密的方式进行交易，区块链技术是经济的操作系统，也是一个平台，可以革新企业和公司的模式。经济要实现从高速增长走向高质量发展，依靠的将是区块链技术。 加快大数据创新应用，推动经济社会高质量发展（王晨）2017年12月习近平总书记指出&emsp;&emsp;大数据是信息化发展的新阶段。随着信息技术和人类生产生活交汇和融合，互联网快速普及，全球数据呈现爆发增长、海量集聚的特点，对经济发展、社会治理、国家管理、人民生活都产生了重大影响。 &emsp;&emsp;审时度势、精心谋划、超前布局、力争主动，深入了解大数据发展现状和趋势及其对经济社会发展的影响，加快完善数字基础设施，推进数据资源整合和开发共享，构建以数据为关键要素，以创新为主要引领和支撑的数字经济。 大数据核心&emsp;&emsp;用数据说话，用数据决策，用数据管理，用数据创新。 &emsp;&emsp;让百姓少跑腿，数据多跑路。 谱写新时代大数据融合发展的新篇章-孙志刚&emsp;&emsp;数据连接万物、变革万物，融合基于智慧、创造智慧。融合是新时代大数据发展的最大特征和价值所在，为发展理念落地生根提供了无限可能，必将打开人们认识世界、改造世界的新大门，对社会生产方式、生活方式和社会治理模式都将产生重大而深远的影响。 &emsp;&emsp;大力开展“千企引进”、“千企改造”，“万企融合”。 &emsp;&emsp;我们在实践中深刻体会到：第一，融合是大势所趋，只有融合才能让数据释放价值，爆发力量，只有融合才能实现以信息化培育新动能、用新动能推动新发展；第二，融合并非高不可攀，融合是方向、是出路，各地区、各部门，各行业、各企业都可以在与大数据融合中找到转型升级的路径、拓展创新发展空间；第三，融合是共同追求，需要大家各施所长、各尽所能，关键在政府引领，基础在企业参与，重点在软件开发应用，导向在解决问题，目的在惠及人民；第四，融合是科技进步的主题，万物皆可数字化，数字化为融合发展创造了无限的机会，融合是展示智慧的空间，融合过程将催生无限的创新。 加快培育壮大数字经济，以新动能推动新发展-林念修5个着力 着力增强数字技术创新能力。 着力加速数字产业化和产业数字化。 三是着力推进“互联网+政务服务”。 四是着力推展数字经济国际合作空间。 五是着力强化数字经济法治体系建设。 扎实推进大数据战略，促进大数据产业繁荣发展- 陈肇雄&emsp;&emsp;数据已经成为继土地、劳动力、资本、技术之后最活跃的关键生产要素。 &emsp;&emsp;构筑软件定义、平台支撑、数据驱动、智能引领的发展新形态。 要求 突破核心技术，增强创新能力。 深化融合应用，助力提质增效。 加强数据治理，确保有序安全。 坚持开放发展，实现合作共赢。 新量子革命-潘建伟&emsp;&emsp;从某种意义上说，正是因为量子科学才催生了现代信息技术发展，比如说原子弹研究过程中，催生了现代意义上的电子计算机。在物理学家把数据传往全世界各地的时候，发展了互联网的概念。通过用原子钟来检验相对论，最后发展成为目前GPS导航技术。 随着技术的发展我们目前遇到两个问题 第一，数据以及互联网的安全性是非常重要的。 第二，随着大数据和人工智能的发展，我们对计算能力的需求日益增加。 &emsp;&emsp;AlphaGo跟人类下一盘围棋所用的电是十吨煤。 &emsp;&emsp;我们目前发展计算能力的传统手段就是把计算机集成度提高，生产更好的软件。但是，目前摩尔定律（单位面积集成电路上可容纳的半导体晶体管数目每18个月就会增加一倍）已经面临终结，不到10年左右的时间，这个规律就会停止，会达到原子的尺寸。 量子科技 经典比特 量子比特 量子纠缠 量子通讯加密 爱因斯坦：诡异的互动 光量子计算 为了一个更美好的AI时代-李彦宏简单搜索app 人工智能 永远无广告 AI产品所遵循的原则 第一，AI的最高原则是安全可靠 第二，不仅要大公司具备AI能力，小公司也要具备AI能力。 第三，AI做出来的东西不是简单模仿人，人喜欢什么就给他什么。 第四，劳动不再成为谋生的手段，而是变成人的一种需求。 &emsp;&emsp;AI的使命不是替代人，而是让技术忠诚于人类，服务于人类，让人类生活过的更美好。 让人工智能创造价值-张䥽（po）关键词 北京深醒科技有限公司 把人工智能变为产业、创造价值，取决于四个因素 数据 人工智能算法 计算资源 应用场景 &emsp;&emsp;计算机对付不了突发事件 贯彻落实健康中国战略，释放“大数据+大健康”发展红利-王世杰关键词 大扶贫 大数据 大生态 要做身体健康的民族 云上贵州 从数据时代走向数权时代- 连玉明&emsp;&emsp;我们把调整数权权属、数权权利、数据利用和数据保护的法律制度称之为数权法。 物联网发展面临的诸多挑战- 尹浩物联网面临的挑战 万物互联的实现 物联网信息安全 物联网从万物互联走向万物智连 物联网接入挑战 广域接入（如wifi） 海基 空基 天基 &emsp;&emsp;国际上通过一个互联网标准，在低功率、广连接上做了大量的工作，，60%的数据大小是100K以下，这块是全球的部署。 我国物联网在产业发展上面临很多深层次的瓶颈问题 产业竞争力不强，芯片、传感器、操作系统等核心基础能力依然薄弱，高端产品研发能力较为低下； 产业链的协同能力不强缺少上下游的资源，鼓励打造引领物联网产业发展的龙头企业； 三是标准体系问题，刚才说NBRT很好，是因为其形成了国际的标准； 四是物联网的发展有待进一步深化，要把智慧服务产业、网络信息产业、智能制造业，在“物联网+”时代和物联网进入智联网时代当中，以体制改革推动它们形成协同创新体系，让环成链。 四大融合 网络融合 数据融合 服务融合 与我们拥抱信息能力融合 赋能万物，连接未来-贺东东（树根互联技术有限公司）关键词 三一重工工业互联网实践 工业互联网 工业互联网解决基本问题 解决万物互联的问题 中国需要什么样的工业互联网平台 要工业和互联网深度融合。 &emsp;&emsp;工业互联网在美国是由通用电气公司做的，德国是由西门子公司做的，也就是说有工业背景的公司加上互联网就形成了一个工业互联网先驱领跑姿态。 一定要适合本土的需求。 现在是“变道超车”的时代。 一定要创造价值。 基于可信计算的区块链安全-沈昌祥区块链在养老产品登记领域的应用-姚余栋&emsp;&emsp;生于互联网，死于区块链。 COSMOPLAT:新动能的传播机-海尔互联网的探索与实践(陈录城)&emsp;&emsp;COSMOPLAT平台满足用户个性化需求、越来越高端化。 对原有工业的颠覆从三个方面入手 由原有产品生命周期变成用户生命周期。 全流程 全球资源共创共赢的生态。 &emsp;&emsp;什么是大规模定制模式？让用户和工厂零接触，实现用户直达工厂，工厂直达用户。 用户企业融为一体有三个颠覆点 研发体系颠覆 制造体系颠覆 营销体系颠覆 平台服务的三种场景 模式转型。 产业资源配置。 提质增效。 ####互联网主力军征战脱贫攻坚主战场-刘文奎 建档立卡 公益 美丽乡村项目 电商扶贫 留守儿童关爱项目 网络扶贫，传统企业赢在精准-石东伟 利用大数据技术控制繁育、产奶饲养等模块工作 智能喂养 扶贫给人以鱼，脱贫授人以渔，而致富是造鱼塘-马云&emsp;&emsp;贫困不是农民不努力，而是农业文明和商业文明没有完美的结合。 &emsp;&emsp;贫困县贫困不是贫困县不努力，而是发展模式没跟上。 &emsp;&emsp;在过去，联产承包责任制解决了土地上种出来东西属于谁的问题，大力激发了农民生成的积极性，而今天大数据、互联网要解决土地上种出来的东西卖给谁的问题。 &emsp;&emsp;要实现“农村现代化”，就一定要把农村乡镇现代化做起来，而不是把城镇农业化，所以这方面我们一定要高度重视。 &emsp;&emsp;大公司的大不是利润大、收入大、市场份额大，而是责任大、担当大，人们希望你能担当更多的责任，希望你能做更多的事情。 探索数字新生态-马化腾一横一纵一新 数字化的广度 &emsp;&emsp;腾讯关注数字经济的几个方面归纳为“五个生”——民生服务、生活消费、生命健康、生产制造、生态环保。 数字化的深度 数字精度 &emsp;&emsp;区块链解决了处方不篡改的难题。 &emsp;&emsp;数字的广度、深度和精度是密不可分的，流动的数据、开放的网络和智能的系统是数字新生态必不可少的部分。广度让我们每个人都受益，深度可以助力创新，精度则可以提高生活品质。一句话，数字化将创新地提高每个人的生活品质。 定义未来，超越竞争-廖建文&emsp;&emsp;今天的数字经济已经到了深水区，今天进入到了智能商业时代。 未来可以看到什么 第一，整个行业正在从“平台竞争”走向“供应链竞争”。 第二，整个竞争从“中心化”变成未来的“分布式”。 &emsp;&emsp;今天的数字化粒度，尤其是走到未来物联网、区块链之后，颗粒度会变得更细。 &emsp;&emsp;消费互联网和产业互联网的融合将会成为下一个数字经济发展的重要方向。 &emsp;&emsp;要生产什么？生产多少？生产到哪里去？这意味着下一个时代toB服务的兴起。 &emsp;&emsp;京东未来的第三条曲线就是布局为toB企业端服务的业务。 &emsp;&emsp;从”产品经营“走向”用户经营“。用户的经营代表了硬件化、社群化、内容化。所有行业都有一个共同的目标，就是如何更加深入地去连接用户，占有用户的时间，不管是社交也好，还是内容也好。 第三，从”帝国“到”生态“。 &emsp;&emsp;在智能商业中，数字协同、网络雄变的及其重要，任何一个企业不可能拥有一个全景的消费数据，我们需要社交数据，消费数据、娱乐数据等等。走到下一个时代，通过数据协同才能真正打破过去那个时代的”数据孤岛“，更重要的是我们要重新去理解什么是竞争。 &emsp;&emsp;在下半场我们思考的问题应当是如何去给消费者更好的选择、更多的选择，而不是更少的选择，我认为这是我们真正应该去做的生态。 懂得大数据，用好大数据，助力深化公共资源交易改革发展-杨洁&emsp;&emsp;建设现代化经济体系离不开大数据发展和应用，要加快形成以创新为主要引擎和支撑的数字经济。 &emsp;&emsp;李克强总理多次部署，要求推动数字经济、平台经济发展，以新产业蓬勃发展、新动能持续壮大、新人才不断涌现为经济转型做有力支撑。 &emsp;&emsp;人在干，数在算，云在转。hexo 读书感悟 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"科技","slug":"科技","permalink":"https://lywlefan.github.io/tags/科技/"},{"name":"大数据","slug":"大数据","permalink":"https://lywlefan.github.io/tags/大数据/"},{"name":"数字经济","slug":"数字经济","permalink":"https://lywlefan.github.io/tags/数字经济/"}]},{"title":"一代商圣范蠡-姜正成","date":"2019-05-17T16:00:00.000Z","path":"2019/05/18/读书/归档/2019/5月/一代商圣范蠡-姜正成/","text":"能治国能安民，灭吴霸越，堪称一代名相。知进退懂经营，三致千金，不愧千秋商圣。 名言摘录范蠡给文种的临别书信&emsp;&emsp;飞鸟尽，良弓藏；狡兔死，走狗烹；敌国灭，谋臣亡。越王为人长颈鸟喙，可与共患难，不可与共乐。子何不去？ 人生三不朽&emsp;&emsp;立德、立功、立言，取其一容易，得其三更难，而范蠡三者全取。范蠡有为政之德，为商之德，富而好行其德，有十年声息十年教训兴越之功，有父子戮力治产积居、赀（zi）累巨万经商之功，又有《致富奇书》《范蠡兵法》《养鱼经》《陶朱公商训》著书立说之言，三者兼得，可谓德炳炳，功赫赫，言昭昭，为世人尊为商圣，万古流芳。 经济循环理论 六岁穰（rang）六岁旱，十二岁一大饥。 经商致富十二条&emsp;&emsp;人无信不立。 &emsp;&emsp;勤快节俭，谨慎负责，规矩方正，价格讲明，不负于人，富行其德。 &emsp;&emsp;能接纳，礼文接待，交关者众，能整顿，货物整齐，夺人心目。能倡率，躬行以律，亲感而生。 人谋用人要正，忠奸定兴废。 大事要慎，妄托受大害。 待人忌躁，暴躁交易少。 处事宜静，浮躁误事多。 言行宜和，和气能生财。 做事宜勤，懒惰百事废。 事谋用度宜俭，奢华财源败。 做工宜精，粗糙出劣品。 期货要准，马虎失信用。 交易要速，拖延失良机。 进货要严，滥入货价减。 出纳要谨，潦草出差错。 物谋优劣要清，混淆损耗大。 存物要整，散漫难查点。 价格要明，含糊多争执。 赊欠要审，滥出亏血本。 账目要清，糊涂弊端生。 查账要勤，懈怠滞本金。 经商之道&emsp;&emsp;一是对百姓只取十一利；遣物如遣兵。 陶朱公商训生意要勤快，切勿懒惰，懒惰则百事废。 接纳要温和，切勿躁暴，躁暴则交易少。 价格要订明，切勿含糊，含糊则争执多。 账目要稽查，切勿懈怠，懈怠则资本滞。 货物要整理，切勿散漫，散漫则查点难。 出纳要谨慎，切勿大意，大意则错漏多。 期限要约定，切勿延迟，延迟则信用失。 临事要尽责，切勿放任，放任则受害大 用度要节俭，切勿奢侈，奢侈则钱财竭 买卖要随时，切勿拖延，拖延则机会失。 赊欠要识人，切勿滥出，滥出则血本亏。 优劣要分清，切勿混淆，混淆则耗用大。 用人要方正，切勿歪斜，歪斜则托付难。 货物要面验，切勿滥入，滥入则质价低。 钱账要清楚，切勿糊涂，糊涂则弊端生。 主心要镇定，切勿妄动，妄动则误事多。 工作要细心，切勿粗鲁，粗鲁则出劣品。 说话要规矩，切勿浮躁，浮躁则失事多。 囤积货物，垄断奇居，把握时机，聚散适宜。 “天、地、人、神、鬼“。 天为先天之智，经商之本; 地为后天修为，靠诚信立身; 人为仁义，懂取舍，讲究“君子爱财，取之有道； 神为勇强，遇事果敢，敢闯敢干; 鬼为心机，手法活络，能“翻手为云，覆手为雨”。 范蠡经商十二则一是能识人。知人善恶，账目不负。 二是能接纳。礼文相待，交往者众。 三是能安业。厌故喜新，商贾大病。 四是能整顿。货物整齐，夺人心目。 五是能敏捷。犹豫不决，终归无成。 六是能讨账。勤谨不怠，取行自多。 七是能用人。因才四用，任事有赖。 八是能辩论。生财有道，阐发愚蒙。 九是能办货。置货不苛，蚀本便经。 十是能知机。 售贮随时,可称名哲。 十一是能倡率。 躬行必律,亲感自生。 十二是能运数。 多寡宽紧,酌中而行。 范蠡理财十二戒第一戒勿卑陋:应纳无文,交关不至: 第二戒勿亿柔:胸无果敢,经营不振; 第三戒勿虚华:用度无节,破败之端; 第四戒勿强辩:暴以待人,祸患难免; 第五戒勿懒惰:取讨不利,账目无有; 第六戒勿轻出:货物轻出,血本必亏; 第七戒勿争取:货重争趋,需防跌价; 第八戒勿昧时:依时贮发,各有常道; 第九戒勿固执: 拘执不通,便成枯木; 第十戒勿贪赊:贪赊多估,承卖莫续; 第十一戒勿薄蓄:货贱贮积,恢复必速; 第十二戒勿痴货:优劣不分,贻害匪浅。 范蠡经商理财十二法第一条生意要渤紧, 懒惰则百事废; 第二条接纳要温种, 躁暴则交易少; 第三条议价要订明,含糊则争执多; 第四条账目要稽查,懒怠则资本滞; 第五条货物要整理，散漫则必废残; 第六条出纳要谨慎,大意则错漏多; 第七条期银要约定,延迟则信用失; 第八条临事要责任,放弃则受害大; 第九条用度要节俭,奢侈则用途竭; 第十条买卖要随时,挨延则机宜失; 第十一条赊欠要识人，滥出则血本亏; 第十二条优劣要分清，苟且则必糊涂。 思考感悟以治大国之法，治理金口小家&emsp;&emsp;商圣让偏远的海滨金口繁荣起来靠的是什么？范蠡充分利用本地的优势资源盐和劳动力，充分发挥本地特色，让大家看不到价值的东西有了价值，当自己富有依旧不忘造福乡里，取之于民，用之于民，把金口的经济贸易充分调动了起来。 名词解释 鸱(chi)夷子皮:范蠡给自己起的经商的名字。著名政治家、军事家、经济学家、道家代表作品：《计然篇》、《陶朱公生意经》《卢氏本草经》 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"历史","slug":"历史","permalink":"https://lywlefan.github.io/tags/历史/"},{"name":"传记","slug":"传记","permalink":"https://lywlefan.github.io/tags/传记/"}]},{"title":"idea常用快捷键总结","date":"2019-05-16T16:00:00.000Z","path":"2019/05/17/工具/开发工具/idea常用快捷键总结/","text":"工欲善其事，必先利器！ 必需会的快捷键 提出选中内容为局部变量:Ctrl+Alt+V 选中代码的情况下,包裹代码(try):Ctrl+alt+T 删除类中无用的import包:Ctrl + Alt + O 格式化代码:Ctrl+Alt+L 界面相关快捷键 快速切换方案:Ctrl+~ 展开/折叠项目侧边栏:Alt+1 打开设置界面:Ctrl + Alt + S 扩展成一个窗口：shift+ctrl+f12 代码提示相关快捷键 代码提示:Ctrl+空格 代码插入:Alt+enter 光标控制相关快捷键 光标定位到上个浏览处:Ctrl(shift)+alt+left 光标定位到下一个浏览出:Ctrl(shift)+Alt+right 光标移动到下一个方法开始处:alt+down 光标移动到上一个方法开始处:alt+up 光标移动到前一个单词处:Ctrl+left 光标移动到后一个单词处:Ctrl+right 光标在代码块之间移动:Ctrl+[/] 快速定位到下一个错误和警告处:F2(加Shift键，定位到上一个错误处) 光标跳出括号(单引号等其他的类似):shift+相应符号 选中相关的快捷键 连续选中文件中相同的内容:Alt+j 按语法选中代码:Ctrl+W (连续按会有其他效果，加Shift键，产生反向选中效果) 新建相关快捷键 新建类文件:Alt+insert(光标放到文件夹) 文件切换 查看最近打开的文件:Ctrl+E 切换最近文件:Ctrl+Tab 编辑窗口的切换:Alt+left/right 查找相关快捷键 当前文件查找:Ctrl+F 当前文件替换:Ctrl+R 当前项目查找:Ctrl+shift+F 当前项目替换:Ctrl+Shift+R 查找文件:Ctrl+shift+N 查找类文件:ctrl+shift+alt+n 全局查找:shift+shift 删除和插入相关快捷键 删除当前行:Ctrl+Y 按单个单词删除:Ctrl+Backspace 复制光标所在的行:Ctrl+D 向下插入一行:shift+enter 向上插入一行:alt+shift+enter 当前行向上移动:ctrl+shift+up/down 大小写转换快捷键 大小写转换快捷键:Ctrl+shift+U 版本控制相关的快捷键 提交到本地仓库备注的快捷键:Ctrl+k 提交到本地仓库:Ctrl+Alt+K push的快捷键:Ctrl+shift+K（窗口处理的时候ctrl+enter可以快速提交） pull的快捷键:Ctrl+T 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"开发","slug":"开发","permalink":"https://lywlefan.github.io/tags/开发/"},{"name":"idea","slug":"idea","permalink":"https://lywlefan.github.io/tags/idea/"},{"name":"快捷键","slug":"快捷键","permalink":"https://lywlefan.github.io/tags/快捷键/"}]},{"title":"RestTemplate常见问题的解决办法.md","date":"2019-05-14T16:00:00.000Z","path":"2019/05/15/spring/spring-base/RestTemplate常见问题的解决办法/","text":"问题汇总 用restTemplate请求域名或着ip一直报No instances available的错 restTemplate的post请求报415错 问题处理用restTemplate请求域名或着ip一直报No instances available的错 错误描述 123java.lang.IllegalStateException: No instances available for www.baidu.comat org.springframework.cloud.netflix.ribbon.RibbonLoadBalancerClient.execute(RibbonLoadBalancerClient.java:79) ~[spring-cloud-netflix-core-1.1.0.RELEASE.jar:1.1.0.RELEASE] at org.springframework.cloud.client.loadbalancer.LoadBalancerInterceptor.intercept(LoadBalancerInterceptor.java:46) ~[spring-cloud-commons-1.1.0.RELEASE.jar:1.1.0.RELEASE] at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:86) ~[spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE] at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:70) ~[spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE] at ..... &emsp;&emsp;查看错误的跟踪链发现,自动注入的restTemplate中加入了cloud.netflix*包下面的interceptor, &emsp;&emsp;所以默认会通过RibbonLoadBalancerClient去查找注册中心的instances, &emsp;&emsp;如上面的代码，www.baidu.com肯定不存在，所以就报错了。 错误解决 &emsp;&emsp;重新实例化一个RestTemplate。 123456789101112131415@Configurationpublic class MyConfiguration &#123; @LoadBalanced @Bean RestTemplate loadBalanced() &#123; return new RestTemplate(); &#125; @Primary @Bean RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; restTemplate的post请求报415错 错误描述 &emsp;&emsp;报错415 问具体解决 1234567HttpHeaders headers = new HttpHeaders();MediaType type = MediaType.parseMediaType(\"application/json;\");headers.setContentType(type);headers.add(\"Accept\", MediaType.APPLICATION_JSON.toString());JSONObject jsonObj = JSON.parseObject(JSON.toJSONString(payParams));HttpEntity&lt;String&gt; formEntity = new HttpEntity&lt;String&gt;(jsonObj.toString(), headers);restTemplate.postForObject(bestPayProperties.getBestPayUrl(),formEntity,String.class); 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"spring","slug":"spring","permalink":"https://lywlefan.github.io/tags/spring/"},{"name":"RestTemplate","slug":"RestTemplate","permalink":"https://lywlefan.github.io/tags/RestTemplate/"}]},{"title":"JAR包如何取工程外部文件","date":"2019-05-14T16:00:00.000Z","path":"2019/05/15/spring/spring-base/JAR包如何取工程外部文件/","text":"问题起源&emsp;&emsp;在开发支付stater的过程中会用到证书，而证书我们一般配置在工程项目中，那么我们自己开发的stater如何才能取到工程项目中的证书文件那？？？ 问题深究分解问题&emsp;&emsp;要想解决这个问题，我们要明确 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"spring","slug":"spring","permalink":"https://lywlefan.github.io/tags/spring/"},{"name":"疑难杂症","slug":"疑难杂症","permalink":"https://lywlefan.github.io/tags/疑难杂症/"}]},{"title":"不用spring如何实例化一个bean","date":"2019-05-13T16:00:00.000Z","path":"2019/05/14/spring/spring-base/不用spring如何实例化一个bean/","text":"问题源起&emsp;&emsp;为什么写这么一篇文章那？主要还是源自最近在写支付的starter的过程中遇到的一个问题，我们知道在支付的过程中需要去配置一些相关的参数，因为是starter我们一般是通过配置文件的方式进行配置，引用我们stater的工程会通过yml文件中配置的属性把这些值给我们。 &emsp;&emsp;那么我想在stater里面取到这些值该如何去做那？？我直接new一个配置类对象但是却取不到，因此我们就在思考spring到底是如何实例化bean的？？他对bean做了什么？？如果不用spring的注解我们又该如何去实例化我们的bean那？带着这些问题我开始了我的解惑之旅。。。 问题深究提出问题，分解问题12345678910111213141516@AllArgsConstructor@RestController@RequestMapping(\"/api/v1/app/\")public class AppController extends BaseController &#123; @Autowired AppBannerService appBannerService; @RequestMapping(value = \"index\", method = RequestMethod.POST) public Result index(HttpServletRequest request,@RequestBody @Valid AppBannerAreaCode appBannerAreaCode) &#123; Map&lt;String,Object&gt; appMessage=new HashMap&lt;&gt;(); String appId=CommonUtils.getAppIdFromHeader(request); List&lt;AppBanner&gt; banners=appBannerService.getBannersByAppIdAndCode(appId,appBannerAreaCode.getProvinceCode()); return new Result(banners); &#125;&#125; &emsp;&emsp;上面的controller是我用日常开发常用的，AppBannerService是我们定义的业务接口，接口有实现类，我们只需要简单的注解就可以直接调用接口的方法了。 spring如何实例化bean？？ spring实例化方式有那些？？ 容器是如何实例化的？？ 我们假如不用这个注解如何去调这个接口那？？&emsp;&emsp;接下来我们就围绕以上两个问题进行展开。 解决各个问题spring实例化方式有那些？？&emsp;&emsp;软件开发到最后的最高境界就是制定标准，然后严格安装标准去开发和迭代。我个人认为spring也是如此，spring给自己定义了标准的四种实例化方式，我们在日常开发中就可以通过这四种实例化方式进行实例化，下面让我们一起细究一下这四种实例化方式： setter方法实例化 主类 1234567891011121314151617181920212223242526public interface IUserDao &#123; void addUser(); void delUser(); void updateUser(); &#125; public class UserDaoImpl implements IUserDao &#123; public void addUser() &#123; System.out.println(\"addUser方法被调用了\"); &#125; public void delUser() &#123; System.out.println(\"delUser方法被调用了\"); &#125; public void updateUser() &#123; System.out.println(\"updateUser方法被调用了\"); &#125; &#125; public class UserAction &#123; private IUserDao dao; //dao是一个依赖对象,要由springg进行管理,要生成 get set 方法 public void execute()&#123; dao.addUser(); dao.updateUser(); dao.delUser(); &#125; &#125; 配置文件 12345//配置文件&lt;bean name=\"userAction_name\" class=\"cat.action.UserAction\" &gt;&lt;property name=\"dao\" ref=\"userDao_name\" /&gt; //引用的是下面的名称&lt;/bean&gt; &lt;bean name=\"userDao_name\" class=\"cat.dao.UserDaoImpl\" /&gt; 测试 1234 //测试ClassPathXmlApplicationContext ctx=new ClassPathXmlApplicationContext(\"beans.xml\");UserAction action=(UserAction)ctx.getBean(\"userAction_name\");action.execute(); 构造函数 主类 123456789101112131415161718192021222324public class UserAction &#123; //public UserAction()&#123;&#125; 可以保保留一个无参的构造函数 //这是几个依赖对象,不用生成get set方法了 private UserInfo user; private String school; private IUserDao dao; //希望Spring 由构造函数注入依赖对象 public UserAction(IUserDao dao,UserInfo user,String school)&#123; this.dao=dao; this.school=school; this.user=user; &#125; public void execute()&#123; dao.addUser(); dao.updateUser(); dao.delUser(); System.out.println(user); System.out.println(school);&#125; 配置文件 123456789101112131415161718192021222324//配置文件&lt;bean name=\"userInfo_name\" class=\"cat.beans.UserInfo\" &gt; &lt;property name=\"id\" value=\"1\" /&gt; &lt;property name=\"userName\" value=\"周周\" /&gt; &lt;property name=\"password\" value=\"123\" /&gt; &lt;property name=\"note\" value=\"这是备注\" /&gt;&lt;/bean&gt; &lt;bean name=\"userAction_name\" class=\"cat.action.UserAction\" &gt; &lt;constructor-arg ref=\"userDao_name\" /&gt; &lt;constructor-arg ref=\"userInfo_name\" /&gt; &lt;constructor-arg value=\"哈尔滨师范大学\" /&gt;&lt;/bean&gt; /*也可以指定 索引和 type 属性 , 索引和type 都可以不指定&lt;bean name=\"userAction_name\" class=\"cat.action.UserAction\" &gt;&lt;constructor-arg index=\"0\" ref=\"userDao_name\" type=\"cat.dao.IUserDao\" /&gt; 如果是接口,就不能指定是实现类的类型&lt;constructor-arg index=\"1\" ref=\"userInfo_name\" type=\"cat.beans.UserInfo\" /&gt;&lt;constructor-arg index=\"2\" value=\"哈尔滨师范大学\" /&gt;&lt;/bean&gt;*/ &lt;bean name=\"userDao_name\" class=\"cat.dao.UserDaoImpl\" /&gt; 测试 1234//测试ClassPathXmlApplicationContext ctx=new ClassPathXmlApplicationContext(\"beans.xml\");UserAction action=(UserAction)ctx.getBean(\"userAction_name\");action.execute(); 静态工厂方式 主类 123456789101112131415161718192021//工厂,用来生成dao的实现类public class UserDaoFactory &#123;public static IUserDao createUserDaoInstance()&#123; return new UserDaoOracleImpl(); &#125;&#125; public class UserAction &#123; private IUserDao dao;//使用工厂方式注值,也要生成set方法 public void execute()&#123; dao.addUser(); dao.updateUser(); dao.delUser();&#125; public void setDao(IUserDao dao) &#123; this.dao = dao;&#125; &#125; 配置文件 123456//配置文件 &lt;bean name=\"userAction_name\" class=\"cat.action.UserAction\" &gt;&lt;property name=\"dao\" ref=\"userDao_name\" /&gt;&lt;/bean&gt; &lt;bean name=\"userDao_name\" class=\"cat.dao.UserDaoFactory\" factory-method=\"createUserDaoInstance\" /&gt; 测试 1234//测试ClassPathXmlApplicationContext ctx=new ClassPathXmlApplicationContext(\"beans.xml\");UserAction action=(UserAction)ctx.getBean(\"userAction_name\");action.execute(); 实例工厂 主类 1234567//工厂 =&gt;public class UserDaoFactory &#123;//这个方法不是静态的public IUserDao createUserDaoInstance()&#123; return new UserDaoOracleImpl(); &#125;&#125; 配置文件 1234567//配置文件 &lt;bean name=\"userAction_name\" class=\"cat.action.UserAction\" &gt;&lt;property name=\"dao\" ref=\"userDao_name\" /&gt;&lt;/bean&gt; &lt;bean name=\"userDaoFactory_name\" class=\"cat.dao.UserDaoFactory\" /&gt;&lt;bean name=\"userDao_name\" factory-bean=\"userDaoFactory_name\" factory-method=\"createUserDaoInstance\" /&gt; 测试 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"spring","slug":"spring","permalink":"https://lywlefan.github.io/tags/spring/"},{"name":"spring-base","slug":"spring-base","permalink":"https://lywlefan.github.io/tags/spring-base/"}]},{"title":"如何写一个stater","date":"2019-05-12T16:00:00.000Z","path":"2019/05/13/spring/spring-boot/如何写一个stater/","text":"目标刻在岩石上，方法写在沙滩上. 命名规范&emsp;&emsp;不要使用spring-boot开头的，以避免将来spring-boot官方使用你的starter而重名。 正例：xxxx-spring-boot-starter 反例：spring-boot-starter-xxxx 定功能&emsp;&emsp;你所定义的starter需要有自己的独特功能，比如spring-boot-starter-web 提供的springmvc相关的自动装配，内嵌tomcat以及相关依赖，那们你自己定义的starter也是需要界定好自己的功能。举个列子，比如要写一个支付的stater： 支付 支付通知 支付查询 退款 退款查询 退款通知 项目依赖 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"spring","slug":"spring","permalink":"https://lywlefan.github.io/tags/spring/"},{"name":"spring-boot","slug":"spring-boot","permalink":"https://lywlefan.github.io/tags/spring-boot/"}]},{"title":"如何快速寻找到一个问题的答案","date":"2019-04-30T16:00:00.000Z","path":"2019/05/01/方法论/如何快速寻找到一个问题的答案/","text":"目标刻在岩石上，方法写在沙滩上。 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"方法","slug":"方法","permalink":"https://lywlefan.github.io/tags/方法/"}]},{"title":"spring的核心jar","date":"2018-05-29T16:00:00.000Z","path":"2018/05/30/spring/spring的核心jar/","text":"&emsp;&emsp;实践一门技术的最好方式就是深入理解它的思想，然后造一个出来！ Spring AOP：Spring的面向切面编程，提供AOP（面向切面编程）的实现 Spring Aspects：Spring提供的对AspectJ框架的整合 Spring Beans：Spring IOC的基础实现，包含访问配置文件、创建和管理bean等。 Spring Context：在基础IOC功能上提供扩展服务，此外还提供许多企业级服务的支持，有邮件服务、任务调度、JNDI定位，EJB集成、远程访问、缓存以及多种视图层框架的支持。 Spring Context Support：Spring context的扩展支持，用于MVC方面。 Spring Core：Spring的核心工具包 Spring expression：Spring表达式语言 Spring Framework Bom： Spring Instrument：Spring对服务器的代理接口 Spring Instrument Tomcat：Spring对tomcat连接池的集成 Spring JDBC：对JDBC 的简单封装 Spring JMS：为简化jms api的使用而做的简单封装 Spring Messaging： Spring orm：整合第三方的orm实现，如hibernate，ibatis，jdo以及spring 的jpa实现 Spring oxm：Spring对于object/xml映射的支持，可以让JAVA与XML之间来回切换 Spring test：对JUNIT等测试框架的简单封装 Spring tx：为JDBC、Hibernate、JDO、JPA等提供的一致的声明式和编程式事务管理。 Spring web：包含Web应用开发时，用到Spring框架时所需的核心类，包括自动载入WebApplicationContext特性的类、Struts与JSF集成类、文件上传的支持类、Filter类和大量工具辅助类。 Spring webmvc：包含SpringMVC框架相关的所有类。包含国际化、标签、Theme、视图展现的FreeMarker、JasperReports、Tiles、Velocity、XSLT相关类。当然，如果你的应用使用了独立的MVC框架，则无需这个JAR文件里的任何类。 Spring webmvc portlet：Spring MVC的增强 【1】简书主页·share猿 【2】掘金主页·share猿 — 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"spring源码","slug":"spring源码","permalink":"https://lywlefan.github.io/tags/spring源码/"},{"name":"总汇","slug":"总汇","permalink":"https://lywlefan.github.io/tags/总汇/"}]},{"title":"Spring Boot配置FastJson报错","date":"2018-05-29T16:00:00.000Z","path":"2018/05/30/bug收集桶/java/Lombok初次使用启动项目报错解决/","text":"错误描述123456789101112131415161718192021222324252627282930313233343536373839404142434445464748org.springframework.web.util.NestedServletException: Request processing failed; nested exception is java.lang.IllegalArgumentException: Content-Type cannot contain wildcard type '*' at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1013) ~[spring-webmvc-5.1.6.RELEASE.jar:5.1.6.RELEASE] at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:908) ~[spring-webmvc-5.1.6.RELEASE.jar:5.1.6.RELEASE] at javax.servlet.http.HttpServlet.service(HttpServlet.java:665) ~[javax.servlet-api-4.0.1.jar:4.0.1] at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:882) ~[spring-webmvc-5.1.6.RELEASE.jar:5.1.6.RELEASE] at javax.servlet.http.HttpServlet.service(HttpServlet.java:750) ~[javax.servlet-api-4.0.1.jar:4.0.1] at io.undertow.servlet.handlers.ServletHandler.handleRequest(ServletHandler.java:74) ~[undertow-servlet-2.0.19.Final.jar:2.0.19.Final] at io.undertow.servlet.handlers.FilterHandler.handleRequest(FilterHandler.java:81) ~[undertow-servlet-2.0.19.Final.jar:2.0.19.Final] at io.undertow.servlet.handlers.security.ServletSecurityRoleHandler.handleRequest(ServletSecurityRoleHandler.java:62) ~[undertow-servlet-2.0.19.Final.jar:2.0.19.Final] at io.undertow.servlet.handlers.ServletChain$1.handleRequest(ServletChain.java:68) ~[undertow-servlet-2.0.19.Final.jar:2.0.19.Final] at io.undertow.servlet.handlers.ServletDispatchingHandler.handleRequest(ServletDispatchingHandler.java:36) ~[undertow-servlet-2.0.19.Final.jar:2.0.19.Final] at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43) ~[undertow-core-2.0.19.Final.jar:2.0.19.Final] at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43) ~[undertow-core-2.0.19.Final.jar:2.0.19.Final] at io.undertow.servlet.handlers.ServletInitialHandler.dispatchRequest(ServletInitialHandler.java:274) [undertow-servlet-2.0.19.Final.jar:2.0.19.Final] at io.undertow.servlet.handlers.ServletInitialHandler.dispatchToPath(ServletInitialHandler.java:209) [undertow-servlet-2.0.19.Final.jar:2.0.19.Final] at io.undertow.servlet.spec.RequestDispatcherImpl.error(RequestDispatcherImpl.java:502) ~[undertow-servlet-2.0.19.Final.jar:2.0.19.Final] at io.undertow.servlet.spec.RequestDispatcherImpl.error(RequestDispatcherImpl.java:428) ~[undertow-servlet-2.0.19.Final.jar:2.0.19.Final] at io.undertow.servlet.handlers.ServletInitialHandler.handleFirstRequest(ServletInitialHandler.java:331) [undertow-servlet-2.0.19.Final.jar:2.0.19.Final] at io.undertow.servlet.handlers.ServletInitialHandler.access$100(ServletInitialHandler.java:81) [undertow-servlet-2.0.19.Final.jar:2.0.19.Final] at io.undertow.servlet.handlers.ServletInitialHandler$2.call(ServletInitialHandler.java:138) [undertow-servlet-2.0.19.Final.jar:2.0.19.Final] at io.undertow.servlet.handlers.ServletInitialHandler$2.call(ServletInitialHandler.java:135) [undertow-servlet-2.0.19.Final.jar:2.0.19.Final] at io.undertow.servlet.core.ServletRequestContextThreadSetupAction$1.call(ServletRequestContextThreadSetupAction.java:48) [undertow-servlet-2.0.19.Final.jar:2.0.19.Final] at io.undertow.servlet.core.ContextClassLoaderSetupAction$1.call(ContextClassLoaderSetupAction.java:43) [undertow-servlet-2.0.19.Final.jar:2.0.19.Final] at io.undertow.servlet.handlers.ServletInitialHandler.dispatchRequest(ServletInitialHandler.java:272) [undertow-servlet-2.0.19.Final.jar:2.0.19.Final] at io.undertow.servlet.handlers.ServletInitialHandler.access$000(ServletInitialHandler.java:81) [undertow-servlet-2.0.19.Final.jar:2.0.19.Final] at io.undertow.servlet.handlers.ServletInitialHandler$1.handleRequest(ServletInitialHandler.java:104) [undertow-servlet-2.0.19.Final.jar:2.0.19.Final] at io.undertow.server.Connectors.executeRootHandler(Connectors.java:364) [undertow-core-2.0.19.Final.jar:2.0.19.Final] at io.undertow.server.HttpServerExchange$1.run(HttpServerExchange.java:830) [undertow-core-2.0.19.Final.jar:2.0.19.Final] at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_181] at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_181] at java.lang.Thread.run(Thread.java:748) [na:1.8.0_181]Caused by: java.lang.IllegalArgumentException: Content-Type cannot contain wildcard type '*' at org.springframework.util.Assert.isTrue(Assert.java:118) ~[spring-core-5.1.6.RELEASE.jar:5.1.6.RELEASE] at org.springframework.http.HttpHeaders.setContentType(HttpHeaders.java:915) ~[spring-web-5.1.6.RELEASE.jar:5.1.6.RELEASE] at org.springframework.http.converter.AbstractHttpMessageConverter.addDefaultHeaders(AbstractHttpMessageConverter.java:256) ~[spring-web-5.1.6.RELEASE.jar:5.1.6.RELEASE] at org.springframework.http.converter.AbstractHttpMessageConverter.write(AbstractHttpMessageConverter.java:211) ~[spring-web-5.1.6.RELEASE.jar:5.1.6.RELEASE] at com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter.write(FastJsonHttpMessageConverter.java:184) ~[fastjson-1.2.49.jar:na] at org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor.writeWithMessageConverters(AbstractMessageConverterMethodProcessor.java:290) ~[spring-webmvc-5.1.6.RELEASE.jar:5.1.6.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.HttpEntityMethodProcessor.handleReturnValue(HttpEntityMethodProcessor.java:223) ~[spring-webmvc-5.1.6.RELEASE.jar:5.1.6.RELEASE] at org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite.handleReturnValue(HandlerMethodReturnValueHandlerComposite.java:82) ~[spring-web-5.1.6.RELEASE.jar:5.1.6.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:119) ~[spring-webmvc-5.1.6.RELEASE.jar:5.1.6.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:892) ~[spring-webmvc-5.1.6.RELEASE.jar:5.1.6.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797) ~[spring-webmvc-5.1.6.RELEASE.jar:5.1.6.RELEASE] at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.1.6.RELEASE.jar:5.1.6.RELEASE] at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1038) ~[spring-webmvc-5.1.6.RELEASE.jar:5.1.6.RELEASE] at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942) ~[spring-webmvc-5.1.6.RELEASE.jar:5.1.6.RELEASE] at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1005) ~[spring-webmvc-5.1.6.RELEASE.jar:5.1.6.RELEASE] ... 29 common frames omitted 错误分析错误解决 【1】简书主页·share猿 【2】掘金主页·share猿 — 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"spring相关的bug","slug":"spring相关的bug","permalink":"https://lywlefan.github.io/tags/spring相关的bug/"}]},{"title":"MySQL优化总结","date":"2018-05-26T16:00:00.000Z","path":"2018/05/27/数据库/MySQL优化总结/","text":"&emsp;&emsp;实践一门技术的最好方式就是深入理解它的思想，然后造一个出来！ 数据库设计 适当冗余 冗余长时间不变更的字段 冗余数据增量较小的表的字段,衡量好得失 适当建立索引 可是天下没有免费的午餐，查询速度的提高是以插入、更新、删除的速度为代价的，这些写操作，增加了大量的I/O。 一个表的索引所占空间比数据所占空间还大的情况经常发生. 我们建立一个索引，必须保证这个索引不会“亏本”,一般需要遵守这样的规则： 索引的字段必须是经常作为查询条件的字段 如果索引多个字段，第一个字段要是经常作为查询条件的。如果只有第二个字段作为查询条件，这个索引不会起到作用; 索引的字段必须有足够的区分度; Mysql 对于长字段支持前缀索引(所谓的前缀索引就是某些字段只过长,可以取部分值进行检索); 对表进行水平划分 记录数太多了,上千万条 可以取一个维度对表进行拆分,比如地域/月份 对表进行垂直划分 记录不多,但是字段很长的情况 选择适当的字段类型，特别是主键 保小不保大，能用占用字节小的字段就不用大字段(比如主键，我们强烈建议用自增类型) 值得一提的是，datetime和timestamp，datetime占用8个字节，而timestamp占用4个字节 文件、图片等大文件用文件系统存储，不用数据库外键表示清楚，方便建立索引&emsp;&emsp;我们都知道，在powerdesigner里为两个实体建立关系，生成物理模型时会自动给外键建立索引。所以我们不要怕建立关系把线拉乱，建立个ShortCut就好了。 掌握表的写入时机 同样是写入一个表，先写和后写对后续的操作会产生很大影响 宁可集中批量操作，避免频繁读写&emsp;&emsp;系统里包含了积分部分，学生和老师通过系统做了操作都可以获得积分，而且积分规则很复杂，限制每类操作获得积分不同，每人每天每类积分都有上限。比如登录，一次登录就可以获得1分，但是不管你登录多少次，一天只能累积一个登录积分。这个还是简单的，有的积分很变态，比如老师积分中有一类是看老师判作业的情况，规则是：老师判了作业，发现学生有错的，学生改过了，老师再判，如果这时候学生都对了，就给老师加分，如果学生还是错的，那就接着改，知道学生都改对了，老师都判完了，才能给老师加分。如果用程序来处理，很可能每个功能都会额外的写一堆代码来处理这个鸡肋似的积分。不仅编程的同事干活找不到重点，还平白给数据库带来了很大的压力。经过和需求人员的讨论，确定积分没有必要实时累积，于是我们采取后台脚本批量处理的方式。夜深人静的时候，让机器自己玩去吧。 选择合适的引擎&emsp;&emsp;Mysql提供了很多种引擎，我们用的最多的是myisam，innodb，memory这三类。官方手册上说道myisqm比innodb的读速度要快，大概是3倍。不过书不能尽信啊，《OreIlly.High.Performance.Mysql》这本书里提到了myisam和innodb的比较，在测试中myisam的表现还不及innodb。至于memory，哈哈，还是比较好用的。在批处理种作临时表是个不错的选择(如果内存够大)。在我的一个批处理中，速度比近乎1：10。 Sql语句优化 Sql语句优化工具 慢日志 &emsp;&emsp;配置很简单，参数文件里配置： 12slow_query_log=d:/slow.txtlong_query_time = 2 &amp;emsp;&amp;emsp;慢日志文件可能会很大，让人去看是很难受的事。这时候我们可以通过mysql自带的工具来分析。 【1】简书主页·share猿 【2】掘金主页·share猿 【3】MySQL优化总结·周长亮 — 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"数据库","slug":"数据库","permalink":"https://lywlefan.github.io/tags/数据库/"},{"name":"优化","slug":"优化","permalink":"https://lywlefan.github.io/tags/优化/"}]},{"title":"Slack","date":"2011-12-31T16:00:00.000Z","path":"2012/01/01/工具/团队协作工具/Slack/","text":"工欲善其事，必先利器！ 【1】简书主页·share猿【2】掘金主页·share猿 扫描以下公众号关注小猿↓↓↓↓↓↓↓↓ 更多资讯请在简书、微博、今日头条、掘金、CSDN都可以通过搜索“Share猿”找到小猿哦！！！","tags":[{"name":"协作","slug":"协作","permalink":"https://lywlefan.github.io/tags/协作/"},{"name":"开发","slug":"开发","permalink":"https://lywlefan.github.io/tags/开发/"}]}]