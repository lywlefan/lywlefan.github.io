<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>share猿</title>
  
  <subtitle>https://lywlefan.github.io/</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lywlefan.github.io/"/>
  <updated>2019-07-26T06:33:37.301Z</updated>
  <id>https://lywlefan.github.io/</id>
  
  <author>
    <name>share猿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从受欢迎到被需要-萌姐</title>
    <link href="https://lywlefan.github.io/2019/07/26/%E8%AF%BB%E4%B9%A6/%E5%BD%92%E6%A1%A3/2019/7%E6%9C%88/%E4%BB%8E%E5%8F%97%E6%AC%A2%E8%BF%8E%E5%88%B0%E8%A2%AB%E9%9C%80%E8%A6%81-%E8%90%8C%E5%A7%90/"/>
    <id>https://lywlefan.github.io/2019/07/26/读书/归档/2019/7月/从受欢迎到被需要-萌姐/</id>
    <published>2019-07-25T16:00:00.000Z</published>
    <updated>2019-07-26T06:33:37.301Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><h2 id="核心观点"><a href="#核心观点" class="headerlink" title="核心观点"></a>核心观点</h2><h2 id="语句摘录"><a href="#语句摘录" class="headerlink" title="语句摘录"></a>语句摘录</h2><h2 id="相互学习"><a href="#相互学习" class="headerlink" title="相互学习"></a>相互学习</h2><h2 id="实践行动"><a href="#实践行动" class="headerlink" title="实践行动"></a>实践行动</h2><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a><br><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;思维导图&quot;&gt;&lt;a href=&quot;#思维导图&quot; class=&quot;headerlink&quot; title=&quot;思维导图&quot;&gt;&lt;/a&gt;思维导图&lt;/h2&gt;&lt;h2 id=&quot;核心观点&quot;&gt;&lt;a href=&quot;#核心观点&quot; class=&quot;headerlink&quot; title=&quot;核心观点&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="读书" scheme="https://lywlefan.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="7月" scheme="https://lywlefan.github.io/tags/7%E6%9C%88/"/>
    
      <category term="2019" scheme="https://lywlefan.github.io/tags/2019/"/>
    
      <category term="萌姐" scheme="https://lywlefan.github.io/tags/%E8%90%8C%E5%A7%90/"/>
    
  </entry>
  
  <entry>
    <title>MPP(大规模并行处理)简介</title>
    <link href="https://lywlefan.github.io/2019/07/19/%E6%95%B0%E6%8D%AE%E5%BA%93/MBPP%E6%95%B0%E6%8D%AE%E5%BA%93/MPP(%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86)%E7%AE%80%E4%BB%8B/"/>
    <id>https://lywlefan.github.io/2019/07/19/数据库/MBPP数据库/MPP(大规模并行处理)简介/</id>
    <published>2019-07-18T16:00:00.000Z</published>
    <updated>2019-07-19T09:15:28.267Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&emsp;&emsp;实践一门技术的最好方式就是深入理解它的思想，然后造一个出来！</p></blockquote><h3 id="1、-什么是MPP？"><a href="#1、-什么是MPP？" class="headerlink" title="1、 什么是MPP？"></a>1、 什么是MPP？</h3><p>MPP (Massively Parallel Processing)，即大规模并行处理，在数据库非共享集群中，每个节点都有独立的磁盘存储系统和内存系统，业务数据根据数据库模型和应用特点划分到各个节点上，每台数据节点通过专用网络或者商业通用网络互相连接，彼此协同计算，作为整体提供数据库服务。非共享数据库集群有完全的可伸缩性、高可用、高性能、优秀的性价比、资源共享等优势。</p><p>简单来说，MPP是将任务并行的分散到多个服务器和节点上，在每个节点上计算完成后，将各自部分的结果汇总在一起得到最终的结果(与Hadoop相似)。</p><h3 id="2、MPP-大规模并行处理-架构"><a href="#2、MPP-大规模并行处理-架构" class="headerlink" title="2、MPP(大规模并行处理)架构"></a>2、MPP(大规模并行处理)架构</h3><p><img src="https://img-blog.csdn.net/20180607153205548?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTg5MDgz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt>                                         (MPP架构)</p><h3 id="3、-MPP架构特征"><a href="#3、-MPP架构特征" class="headerlink" title="3、 MPP架构特征"></a>3、 MPP架构特征</h3><p>● 任务并行执行;</p><p>● 数据分布式存储(本地化);</p><p>● 分布式计算;</p><p>● 私有资源;</p><p>● 横向扩展;</p><p>● Shared Nothing架构。</p><h3 id="4、-MPP服务器架构"><a href="#4、-MPP服务器架构" class="headerlink" title="4、 MPP服务器架构"></a>4、 MPP服务器架构</h3><p>它由多个SMP服务器通过一定的节点互联网络进行连接，协同工作，完成相同的任务，从用户的角度来看是一个服务器系统。其基本特征是由多个SMP服务器(每个SMP服务器称节点)通过节点互联网络连接而成，每个节点只访问自己的本地资源(内存、存储等)，是一种完全无共享(Share Nothing)结构，因而扩展能力最好，理论上其扩展无限制。</p><h3 id="5、MPPDB"><a href="#5、MPPDB" class="headerlink" title="5、MPPDB"></a>5、MPPDB</h3><p>MPPDB是一款 Shared Nothing 架构的分布式并行结构化数据库集群，具备高性能、高可用、高扩展特性，可以为超大规模数据管理提供高性价比的通用计算平台，并广泛地用于支撑各类数据仓库系统、BI 系统和决策支持系统</p><h3 id="6、MPPDB架构"><a href="#6、MPPDB架构" class="headerlink" title="6、MPPDB架构"></a>6、MPPDB架构</h3><p>MPP 采用完全并行的MPP + Shared Nothing 的分布式扁平架构，这种架构中的每一个节点（node）都是独立的、自给的、节点之间对等，而且整个系统中不存在单点瓶颈，具有非常强的扩展性。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20180607153236902?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTg5MDgz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="7、-MPPDB特征"><a href="#7、-MPPDB特征" class="headerlink" title="7、 MPPDB特征"></a>7、 MPPDB特征</h3><p>MPP 具备以下技术特征：</p><p>1) 低硬件成本：完全使用 x86 架构的 PC Server，不需要昂贵的 Unix 服务器和磁盘阵列；</p><p>2) 集群架构与部署：完全并行的 MPP + Shared Nothing 的分布式架构，采用 Non-Master 部署，节点对等的扁平结构；</p><p>3) 海量数据分布压缩存储：可处理 PB 级别以上的结构化数据，采用 hash分布、random 存储策略进行数据存储；同时采用先进的压缩算法，减少存储数据所需的空间，可以将所用空间减少 1~20 倍，并相应地提高 I/O 性能；</p><p>4) 数据加载高效性：基于策略的数据加载模式，集群整体加载速度可达2TB/h；</p><p>5) 高扩展、高可靠：支持集群节点的扩容和缩容，支持全量、增量的备份/恢复;</p><p>6) 高可用、易维护：数据通过副本提供冗余保护，自动故障探测和管理，自动同步元数据和业务数据。提供图形化工具，以简化管理员对数据库的管理工作；</p><p>7) 高并发：读写不互斥，支持数据的边加载边查询，单个节点并发能力大于 300 用户；</p><p>8) 行列混合存储：提供行列混合存储方案，从而提高了列存数据库特殊查询场景的查询响应耗时；</p><p>9) 标准化：支持SQL92 标准，支持 C API、ODBC、JDBC、ADO.NET 等接口规范。</p><h3 id="8、-常见MPPDB"><a href="#8、-常见MPPDB" class="headerlink" title="8、 常见MPPDB"></a>8、 常见MPPDB</h3><p>● GREENPLUM(EMC)</p><p>● Asterdata(Teradata)</p><p>● Nettezza(IBM)</p><p>● Vertica(HP)</p><p>● GBase 8a MPP cluster(南大通用)</p><h3 id="9、-MPPDB、Hadoop与传统数据库技术对比与适用场景"><a href="#9、-MPPDB、Hadoop与传统数据库技术对比与适用场景" class="headerlink" title="9、 MPPDB、Hadoop与传统数据库技术对比与适用场景"></a>9、 MPPDB、Hadoop与传统数据库技术对比与适用场景</h3><p>MPPDB与Hadoop都是将运算分布到节点中独立运算后进行结果合并(分布式计算)，但由于依据的理论和采用的技术路线不同而有各自的优缺点和适用范围。两种技术以及传统数据库技术的对比如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/19/5d3189cc48dc124520.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>综合而言，Hadoop和MPP两种技术的特定和适用场景为：</p><p>● Hadoop在处理非结构化和半结构化数据上具备优势，尤其适合海量数据批处理等应用要求。</p><p>● MPP适合替代现有关系数据机构下的大数据处理，具有较高的效率。</p><p>MPP适合多维度数据自助分析、数据集市等；Hadoop适合海量数据存储查询、批量数据ETL、非机构化数据分析(日志分析、文本分析)等。</p><p>由上述对比可预见未来大数据存储与处理趋势：MPPDB+Hadoop混搭使用，用MPP处理PB级别的、高质量的结构化数据，同时为应用提供丰富的SQL和事物支持能力；用Hadoop实现半结构化、非结构化数据处理。这样可以同时满足结构化、半结构化和非结构化数据的高效处理需求。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20180607153301340?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTg5MDgz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt title>                </div>                <div class="image-caption"></div>            </figure><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a>﻿<br><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a>﻿﻿</p></blockquote><p>—﻿</p><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong>﻿</p><p><img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>﻿﻿</p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;实践一门技术的最好方式就是深入理解它的思想，然后造一个出来！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1、-什么是MPP？&quot;&gt;&lt;a href=&quot;#1、-什么是MPP？&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="数据库" scheme="https://lywlefan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://lywlefan.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MBPP" scheme="https://lywlefan.github.io/tags/MBPP/"/>
    
  </entry>
  
  <entry>
    <title>理财书籍收集</title>
    <link href="https://lywlefan.github.io/2019/07/18/%E8%AF%BB%E4%B9%A6/%E4%B9%A6%E5%8D%95/%E7%90%86%E8%B4%A2%E4%B9%A6%E7%B1%8D%E6%94%B6%E9%9B%86/%E7%90%86%E8%B4%A2%E4%B9%A6%E7%B1%8D%E6%94%B6%E9%9B%86/"/>
    <id>https://lywlefan.github.io/2019/07/18/读书/书单/理财书籍收集/理财书籍收集/</id>
    <published>2019-07-17T16:00:00.000Z</published>
    <updated>2019-07-18T03:35:38.802Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>多读书，多看报，少吃零食，少睡觉！</p></blockquote><h2 id="理财书籍汇集"><a href="#理财书籍汇集" class="headerlink" title="理财书籍汇集"></a>理财书籍汇集</h2><h3 id="未读"><a href="#未读" class="headerlink" title="未读"></a>未读</h3><ul><li><p>《谁动了我的奶酪》 </p></li><li><p>《小狗钱钱》</p></li><li><p>《富爸爸，穷爸爸》，《财务自由之路》和《投资指南》 </p></li><li><p>《一分钟百万富翁》 </p></li><li><p>《怎样启迪你头脑中的金融意识》 </p></li><li><p>《财源滚滚》</p></li><li><p>《钻石就在你家后院》</p></li><li><p>《我的百万富翁兄弟》</p></li></ul><h3 id="已读"><a href="#已读" class="headerlink" title="已读"></a>已读</h3><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a><br><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;多读书，多看报，少吃零食，少睡觉！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;理财书籍汇集&quot;&gt;&lt;a href=&quot;#理财书籍汇集&quot; class=&quot;headerlink&quot; title=&quot;理财书籍汇集&quot;&gt;&lt;/a&gt;理财书籍汇集&lt;/h2&gt;&lt;h3 i
      
    
    </summary>
    
      <category term="读书" scheme="https://lywlefan.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="读书" scheme="https://lywlefan.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="收集" scheme="https://lywlefan.github.io/tags/%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>财务词汇</title>
    <link href="https://lywlefan.github.io/2019/07/11/%E8%AF%8D%E6%B1%87/%E8%BD%AF%E4%BB%B6/%E7%A0%94%E5%8F%91%E8%8B%B1%E6%96%87%E8%AF%8D%E6%B1%87%E6%94%B6%E9%9B%86/"/>
    <id>https://lywlefan.github.io/2019/07/11/词汇/软件/研发英文词汇收集/</id>
    <published>2019-07-10T16:00:00.000Z</published>
    <updated>2019-07-26T03:56:20.320Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>先有词汇量,然后再能好好说话,好好做事。</p></blockquote><h2 id="java相关词汇"><a href="#java相关词汇" class="headerlink" title="java相关词汇"></a>java相关词汇</h2><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><h4 id="关系型"><a href="#关系型" class="headerlink" title="关系型"></a>关系型</h4><h4 id="非关系型"><a href="#非关系型" class="headerlink" title="非关系型"></a>非关系型</h4><h5 id="newSql"><a href="#newSql" class="headerlink" title="newSql"></a>newSql</h5><h6 id="redis相关词汇"><a href="#redis相关词汇" class="headerlink" title="redis相关词汇"></a>redis相关词汇</h6><ul><li><p>内存数据库:in-memory data structure store</p></li><li><p>消息代理:message broker</p></li></ul><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a><br><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;先有词汇量,然后再能好好说话,好好做事。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;java相关词汇&quot;&gt;&lt;a href=&quot;#java相关词汇&quot; class=&quot;headerlink&quot; title=&quot;java相关词汇&quot;&gt;&lt;/a&gt;java相关词
      
    
    </summary>
    
      <category term="软件" scheme="https://lywlefan.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="词汇" scheme="https://lywlefan.github.io/tags/%E8%AF%8D%E6%B1%87/"/>
    
      <category term="专业英文词汇" scheme="https://lywlefan.github.io/tags/%E4%B8%93%E4%B8%9A%E8%8B%B1%E6%96%87%E8%AF%8D%E6%B1%87/"/>
    
  </entry>
  
  <entry>
    <title>财务词汇</title>
    <link href="https://lywlefan.github.io/2019/07/11/%E8%AF%8D%E6%B1%87/%E8%B4%A2%E5%8A%A1/%E8%B4%A2%E5%8A%A1%E8%AF%8D%E6%B1%87/"/>
    <id>https://lywlefan.github.io/2019/07/11/词汇/财务/财务词汇/</id>
    <published>2019-07-10T16:00:00.000Z</published>
    <updated>2019-07-19T09:50:08.629Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>先有词汇量,然后再能好好说话,好好做事。</p></blockquote><ul><li><p>重要</p></li><li><p>不重要</p></li><li><p>理解</p></li><li><p>未理解</p></li></ul><h2 id="2019年"><a href="#2019年" class="headerlink" title="2019年"></a>2019年</h2><h3 id="7月份词汇"><a href="#7月份词汇" class="headerlink" title="7月份词汇"></a>7月份词汇</h3><h4 id="重要理解词汇"><a href="#重要理解词汇" class="headerlink" title="重要理解词汇"></a>重要理解词汇</h4><ul><li>资产</li></ul><blockquote><p>G:如何获得资产？<br>a.加杠杆购买资产，产生源源不断的现金流<br>b.花时间创造资产</p></blockquote><ul><li><p>负债</p></li><li><p>现值</p></li></ul><p>是在给定的利率水平下，未来的资金折现到现在时刻的价值。</p><ul><li><p>现金流</p><ul><li><p>经营性现金流</p></li><li><p>投资性现金流</p></li><li><p>融资性现金流</p></li></ul></li><li><p>资产负债表</p></li><li><p>损益表</p></li><li><p>所有者权益变动表</p></li><li><p>财务报表附注</p></li><li><p>审查报表</p></li><li><p>预算盈余</p></li><li><p>净现值法（NPV）</p><ul><li><p>净现值</p><p>未来资金流现值与未来资金流出现值差额。</p></li></ul></li><li><p>折现率</p></li></ul><p>折现率是指将未来有限期预期收益折算成现值的比率。</p><ul><li>内部收益率（IRR）</li></ul><h4 id="不重要理解词汇"><a href="#不重要理解词汇" class="headerlink" title="不重要理解词汇"></a>不重要理解词汇</h4><ul><li><p>直线法折旧</p></li><li><p>双倍余额递减法折旧（年折旧率=2÷预计的折旧年限×100％）</p></li></ul><h4 id="重要不理解词汇"><a href="#重要不理解词汇" class="headerlink" title="重要不理解词汇"></a>重要不理解词汇</h4><h4 id="不重要不理解词汇"><a href="#不重要不理解词汇" class="headerlink" title="不重要不理解词汇"></a>不重要不理解词汇</h4><ul><li><p>借款人</p></li><li><p>信贷人员</p></li><li><p>银行流水</p></li></ul><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a><br><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;先有词汇量,然后再能好好说话,好好做事。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;重要&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不重要&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;理解&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;未理解&lt;/p&gt;
&lt;/li
      
    
    </summary>
    
      <category term="词汇" scheme="https://lywlefan.github.io/categories/%E8%AF%8D%E6%B1%87/"/>
    
    
      <category term="词汇" scheme="https://lywlefan.github.io/tags/%E8%AF%8D%E6%B1%87/"/>
    
      <category term="财务" scheme="https://lywlefan.github.io/tags/%E8%B4%A2%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>如果你不愿自己去学习和提升，生活会慢慢教会你！</title>
    <link href="https://lywlefan.github.io/2019/07/11/%E6%80%9D%E8%80%83/2019/7/%E5%A6%82%E6%9E%9C%E4%BD%A0%E4%B8%8D%E6%84%BF%E8%87%AA%E5%B7%B1%E5%8E%BB%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%8F%90%E5%8D%87%EF%BC%8C%E7%94%9F%E6%B4%BB%E4%BC%9A%E6%85%A2%E6%85%A2%E6%95%99%E4%BC%9A%E4%BD%A0%EF%BC%81/"/>
    <id>https://lywlefan.github.io/2019/07/11/思考/2019/7/如果你不愿自己去学习和提升，生活会慢慢教会你！/</id>
    <published>2019-07-10T16:00:00.000Z</published>
    <updated>2019-07-19T10:19:11.863Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在实践中思考感悟,在思考感悟后实践,一切伟大源于不断的思考和实践。</p></blockquote><h3 id="开篇语"><a href="#开篇语" class="headerlink" title="开篇语"></a>开篇语</h3><p>在这个偌大的世界里，我们的家教和我们的环境决定了我们的认知和格局,家庭出身我们没得选,更多的应该是感恩和爱,上天赐予我们亲爱的父母亲,他们默默无私不求回报,每每想起总让人热泪盈眶,这是世界上最伟大的爱,没有之一。</p><p>但是,成年后的我们的思维格局由我们自己决定,你愿不愿意正视自己,正视以前那个傻傻的自己,洗礼自己的一些思想,革新骨子里的各种观念。我相信,你会选择去改变,因为你有梦想。</p><p>上周听了一位财商老师的课,在课上有位50多岁的大叔问了怎么每年赚100万的问题。</p><p>老师说为什么要转一百万?</p><p>大叔说,我还有梦想,我现在每天摆地摊,我起早贪黑,我不怕苦不怕累。</p><p>老师沉默了许久,然后说我建议你不要有梦想,人生是短暂的,大半辈子已经过去了,你开开心心陪家人过完余生也是一种莫大的幸福,梦想这件事很痛,我怕你承受不起。</p><p>听到这里,我内心就像是被猛击了一下,趁着年轻放手去做自己喜欢的事,去追逐自己的梦想,做历练自己,有些事年轻的时候不学会,老了,没有力气了,生活会慢慢教你,会让你痛不欲生,因为这就是你年轻时的选择!</p><h4 id="是不是每次都说自己没钱-是不是想尽办法去赚钱到头却发现花的总比赚的多"><a href="#是不是每次都说自己没钱-是不是想尽办法去赚钱到头却发现花的总比赚的多" class="headerlink" title="是不是每次都说自己没钱,是不是想尽办法去赚钱到头却发现花的总比赚的多"></a>是不是每次都说自己没钱,是不是想尽办法去赚钱到头却发现花的总比赚的多</h4><p>一次无意的刷快手,听了零首付买房,花了298,抱着学习的态度去听了这堂财商课。虽然演讲的老师讲的有点浮夸,但他说的道理,说的思想却极大的震撼了我的内心,让我明白一个人穷不是没钱而是思想上的贫穷,见识上的贫穷,观念上的贫穷,知识上的贫穷。</p><p>时代的发展会把机会摆在每个人的面前,谁能抓住这些机会?谁能牢牢的握住它?谁能把这个机会发挥出巨大的价值?这跟什么有关系?</p><p>究其原因,我个人认为把握机会的前提是能看到机会,能理解这种机会,没有这种意识和格局,别人说你都听不懂,可能还会说人家是骗子,若干年过去后却发现自己是傻逼。</p><p>每一次革新中,都有巨大的机会存在,人口红利必然会导致房屋需求增加,城镇化发展会不断加速,谁能看到,在合适的时机把握机会,时代会把你推向浪潮之巅,抓不住又是为什么???</p><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a><br><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在实践中思考感悟,在思考感悟后实践,一切伟大源于不断的思考和实践。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;开篇语&quot;&gt;&lt;a href=&quot;#开篇语&quot; class=&quot;headerlink&quot; title=&quot;开篇语&quot;&gt;&lt;/a&gt;开篇语&lt;/h3&gt;&lt;
      
    
    </summary>
    
      <category term="思考" scheme="https://lywlefan.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
      <category term="思考" scheme="https://lywlefan.github.io/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="2019年" scheme="https://lywlefan.github.io/tags/2019%E5%B9%B4/"/>
    
      <category term="7月" scheme="https://lywlefan.github.io/tags/7%E6%9C%88/"/>
    
      <category term="生活" scheme="https://lywlefan.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>02.Java内存模型：看Java如何解决可见性和有序性问题</title>
    <link href="https://lywlefan.github.io/2019/07/03/%E9%AB%98%E5%B9%B6%E5%8F%91/%E4%B9%A6%E7%B1%8D/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98-%E7%8E%8B%E5%AE%9D%E4%BB%A4/02.Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%9A%E7%9C%8BJava%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98%20/"/>
    <id>https://lywlefan.github.io/2019/07/03/高并发/书籍/java并发编程实战-王宝令/02.Java内存模型：看Java如何解决可见性和有序性问题 /</id>
    <published>2019-07-02T16:00:00.000Z</published>
    <updated>2019-07-09T08:54:15.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h2><ul><li><p>java内存模型</p></li><li><p>volatile</p></li><li><p>Happens-Before规则</p></li></ul><h3 id="什么是java内存模型？"><a href="#什么是java内存模型？" class="headerlink" title="什么是java内存模型？"></a>什么是java内存模型？</h3><p>java内存模型说的直白一点就是java程序使用内存的规范，让java语言在各种系统和平台中能保持数据的一致性。</p><h4 id="Happens-Before规则（6项规则）"><a href="#Happens-Before规则（6项规则）" class="headerlink" title="Happens-Before规则（6项规则）"></a>Happens-Before规则（6项规则）</h4><p>前一个操作对后一个操作是可见的。假如有一个公有变量，a方法先引用然后b方法再引用，那么我们称a方法的操作对b方法可见。</p><h5 id="程序顺序性规则"><a href="#程序顺序性规则" class="headerlink" title="程序顺序性规则"></a>程序顺序性规则</h5><p>假如有一个公有变量，a方法先引用然后b方法再引用，那么我们称a方法的操作对b方法可见。</p><h5 id="volatile变量规则"><a href="#volatile变量规则" class="headerlink" title="volatile变量规则"></a>volatile变量规则</h5><p>volatile变量的写操作对volatile变量读操作可见。说白了读之前，我要知道是谁写的，不然我不读。</p><h5 id="传递性"><a href="#传递性" class="headerlink" title="传递性"></a>传递性</h5><p>如果A对B可见，B对C可见，那么A对C可见。</p><h5 id="管程中锁的规则"><a href="#管程中锁的规则" class="headerlink" title="管程中锁的规则"></a>管程中锁的规则</h5><p>管程是一种通用的同步原语，在java中指的是synchronized,synchronized是java里对管程的实现。</p><p>对变量进行加锁，执行完再继续。</p><h5 id="线程smart-规则"><a href="#线程smart-规则" class="headerlink" title="线程smart()规则"></a>线程smart()规则</h5><p>它是指主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作。</p><blockquote><p>G:说白了就是主线程要优于子线程。</p></blockquote><h5 id="线程join-规则"><a href="#线程join-规则" class="headerlink" title="线程join()规则"></a>线程join()规则</h5><h3 id="关键词解析"><a href="#关键词解析" class="headerlink" title="关键词解析"></a>关键词解析</h3><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>这个关键词可以禁用cpu缓存。禁用了cpu缓存，那么我们的变量只能从内存中进行读写。</p><h4 id="Happens-Before规则"><a href="#Happens-Before规则" class="headerlink" title="Happens-Before规则"></a>Happens-Before规则</h4><p>Happens-Before规则说白了就是定义java内存模型的一种约束或者规则。</p><blockquote><p>推荐书单</p></blockquote><p>-《Java并发编程实战》作者阵容可谓大师云集，也包括Doug Lea</p><p>-《Java并发编程的艺术》讲解并发包内部实现原理，能读明白，内功大增</p><p>-《图解Java多线程设计模式》并发编程设计模式方面的经典书籍</p><p>-《操作系统：精髓与设计原理》经典操作系统教材</p><ul><li><p><a href="http://ifeve.com" target="_blank" rel="noopener">http://ifeve.com</a> 国内专业并发编程网站</p></li><li><p><a href="http://www.cs.umd.edu/~pugh/java/memoryModel/" target="_blank" rel="noopener">http://www.cs.umd.edu/~pugh/java/memoryModel/</a> 很多并发编程的早期资料都在这里</p></li></ul><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a></p></blockquote><blockquote><p><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;阅读笔记&quot;&gt;&lt;a href=&quot;#阅读笔记&quot; class=&quot;headerlink&quot; title=&quot;阅读笔记&quot;&gt;&lt;/a&gt;阅读笔记&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;java内存模型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;volatile&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;H
      
    
    </summary>
    
      <category term="高并发" scheme="https://lywlefan.github.io/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://lywlefan.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="读书笔记" scheme="https://lywlefan.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java并发编程实战-王宝令" scheme="https://lywlefan.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98-%E7%8E%8B%E5%AE%9D%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>学习攻略.如何才能学好并发编程？</title>
    <link href="https://lywlefan.github.io/2019/07/02/%E9%AB%98%E5%B9%B6%E5%8F%91/%E4%B9%A6%E7%B1%8D/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98-%E7%8E%8B%E5%AE%9D%E4%BB%A4/%E5%AD%A6%E4%B9%A0%E6%94%BB%E7%95%A5.%E5%A6%82%E4%BD%95%E6%89%8D%E8%83%BD%E5%AD%A6%E5%A5%BD%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9F/"/>
    <id>https://lywlefan.github.io/2019/07/02/高并发/书籍/java并发编程实战-王宝令/学习攻略.如何才能学好并发编程？/</id>
    <published>2019-07-01T16:00:00.000Z</published>
    <updated>2019-07-02T09:23:11.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h2><p>并发是一门独立学科也是一门综合科学，从两个方面突破并发编程：</p><ul><li><p>跳出来，看全景</p></li><li><p>钻进去，看本质</p></li></ul><h3 id="跳出来，看全景"><a href="#跳出来，看全景" class="headerlink" title="跳出来，看全景"></a>跳出来，看全景</h3><p>学习最忌讳的就是“盲人摸象”，只看到局部，没有全局。从单一知识点跳出来，高屋建瓴看并发编程，首要之事就是建立一张全景图。</p><h4 id="并发核心问题"><a href="#并发核心问题" class="headerlink" title="并发核心问题"></a>并发核心问题</h4><h5 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h5><p>像做项目的分工一样，不同的工作分给不同的人，实现工作效率最大化。</p><p>在学习抽象的东西的时候要多与现实生活中的场景进行类比。</p><p>Java SDK 并发包里的 Executor、Fork/Join、Future本质上都是一种分工的方式。</p><p>并发编程领域还总结了一些设计模式，基本上都是和分工方法相关的，例如生产者 - 消费者、Message、Worker Thread 模式等。</p><h5 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h5><p>同步就相当于项目中的沟通协调，什么时间干什么工作。</p><p>放到软件程序中就是一个线程执行完，通知下一个线程执行而已。例如，用 Future 可以发起一个异步调用，当主线程通过 get() 方法取结果时，主线程就会等待，当异步执行的结果返回时，get() 方法就自动返回了，这就解决了我们主从线程的协作。</p><p>Java SDK 里提供的 CountDownLatch、CyclicBarrierr、Phaser、Exchanger 也都是用来解决线程协作问题的。</p><p>还有很多场景，是需要你自己来处理线程之间的协作。</p><p>在java并发编程领域，解决协作问题的核心就是<strong>管程</strong>，上面提到的所有线程协作技术底层都是利用管程解决的。管程是一种解决并发问题的通用模型，除了能解决线程协助问题，还能解决下面我们将要介绍的互斥问题。可以这么说，<strong>管程是解决并发问题的万能钥匙</strong>。</p><p>关键是理解管程模型，学好它就可以解决所有问题。</p><p>其次是了解java JDK并发包提供的几个线程协作的工具类场景，用好它们可以妥妥地提高你的工作效率。</p><h5 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h5><p>分工/同步主要强调性能，但是并发程序里还有一部分是关于正确性，用专业术语叫“线程安全”。</p><ul><li><p>可见性问题</p></li><li><p>有序性问题</p></li><li><p>原子性问题</p></li></ul><p>为了解决以上三个问题，java语言引入了内存模型，内存模型提供了一系列的规则，利用这些规则，我们可以避免以上问题。</p><p><strong>所谓互斥，指的是同一时刻，只允许一个线程访问共享变量。</strong></p><p>实现互斥的核心技术是锁，java语言里synchronized、SDK里各种Lock都能解决互斥问题。</p><p>虽说锁解决了安全性问题，但同时也带来了性能问题，那如何保证安全性的同时又尽量提高性能那？分场景优化：</p><ul><li><p>Java SDK 里提供的 ReadWriteLock、StampedLock 就可以优化读多写少场景下锁的性能。</p></li><li><p>还可以使用无锁的数据结构，例如 Java SDK 里提供的原子类都是基于无锁技术实现的。</p></li></ul><p>除此之外，还有一些其他的方案，原理是不共享变量或者变量只允许许读。这方面，Java 提供了Thread Local 和 final 关键字，还有一种 Copy-on-write 的模式。</p><p>使用锁除了要注意性能问题外，还需要注意死锁问题。</p><p>这部分内容比较复杂，往往还是跨领域的，例如要理解可见性，就需要了解一些 CPU 和缓存的知识；</p><p>很多无锁算法的实现往往也需要理解 CPU 缓存。</p><p>这部分内容的学习，需要博览群书，在大脑里建立起 CPU、内存、I/O 执行的模拟器。</p><p>全景图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/3084894-e4dba3439c48d077.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="钻进去，看本质"><a href="#钻进去，看本质" class="headerlink" title="钻进去，看本质"></a>钻进去，看本质</h3><p>深入理解，找到本质。</p><p>多分析这些概念和结论是怎么来的？？</p><p>它们是用来解决什么问题的？</p><p>知其然知其所以然。</p><p>工程上解决问题，一定要有理论做基础。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>推荐书单</p></blockquote><p>-《Java并发编程实战》作者阵容可谓大师云集，也包括Doug Lea</p><p>-《Java并发编程的艺术》讲解并发包内部实现原理，能读明白，内功大增</p><p>-《图解Java多线程设计模式》并发编程设计模式方面的经典书籍</p><p>-《操作系统：精髓与设计原理》经典操作系统教材</p><ul><li><p><a href="http://ifeve.com" target="_blank" rel="noopener">http://ifeve.com</a> 国内专业并发编程网站</p></li><li><p><a href="http://www.cs.umd.edu/~pugh/java/memoryModel/" target="_blank" rel="noopener">http://www.cs.umd.edu/~pugh/java/memoryModel/</a> 很多并发编程的早期资料都在这里</p></li></ul><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a></p></blockquote><blockquote><p><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;阅读笔记&quot;&gt;&lt;a href=&quot;#阅读笔记&quot; class=&quot;headerlink&quot; title=&quot;阅读笔记&quot;&gt;&lt;/a&gt;阅读笔记&lt;/h2&gt;&lt;p&gt;并发是一门独立学科也是一门综合科学，从两个方面突破并发编程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;跳出来，看全景&lt;/p&gt;
&lt;/l
      
    
    </summary>
    
      <category term="高并发" scheme="https://lywlefan.github.io/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://lywlefan.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="读书笔记" scheme="https://lywlefan.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java并发编程实战-王宝令" scheme="https://lywlefan.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98-%E7%8E%8B%E5%AE%9D%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>01.可见性、原子性和有序性问题：并发编程Bug的源头</title>
    <link href="https://lywlefan.github.io/2019/07/02/%E9%AB%98%E5%B9%B6%E5%8F%91/%E4%B9%A6%E7%B1%8D/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98-%E7%8E%8B%E5%AE%9D%E4%BB%A4/01.%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8BBug%E7%9A%84%E6%BA%90%E5%A4%B4%20/"/>
    <id>https://lywlefan.github.io/2019/07/02/高并发/书籍/java并发编程实战-王宝令/01.可见性、原子性和有序性问题：并发编程Bug的源头 /</id>
    <published>2019-07-01T16:00:00.000Z</published>
    <updated>2019-07-09T07:47:35.382Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h2><ul><li><p>可见性</p></li><li><p>原子性</p></li><li><p>有序性</p></li></ul><h3 id="并发幕后的故事"><a href="#并发幕后的故事" class="headerlink" title="并发幕后的故事"></a>并发幕后的故事</h3><p>这些年，我们的 CPU、内存、I/O 设备都在不断迭代，不断朝着更快的方向努力。但是，在这个快速发展的过程中，<strong>有一个核心矛盾一直存在，就是这三者的速度差异</strong>。</p><p>CPU和内存速度差异可以形象描述:CPU是天上一天，内存是地上一年。内存和I/O设备速度差异就更大了，内存是天山一天，I/O设备是地上十年。</p><p>大部分程序是需要访问内存，有些还要访问I/O,所以单方面提高CPU性能是无效的。</p><p>为了合理利用CPU高性能，平衡三者的速度差异，计算机体系/操作系统/编译程序都做了很大的贡献，主要体现在以下几点：</p><ul><li><p>CPU增加了缓存，以均衡速度差异</p></li><li><p>操作系统增加了进程/线程，以分时复用CPU，进而均衡CPU与I/O设备的速度差异；</p></li><li><p>编译程序优化指令执行次序，使得缓存能够更加合理的利用。</p></li></ul><h3 id="源头之一：缓存导致的可见性问题"><a href="#源头之一：缓存导致的可见性问题" class="headerlink" title="源头之一：缓存导致的可见性问题"></a>源头之一：缓存导致的可见性问题</h3><h4 id="单核时代"><a href="#单核时代" class="headerlink" title="单核时代"></a>单核时代</h4><p>单核时代，所有线程在一颗CPU上执行，CPU缓存与内存的数据一致性容易解决。</p><p>一个线程对CPU的操作，其他线程都是可见的。</p><p>如下图所示，线程A和线程B都是操作同一个CPU里面的缓存，线程A操作CPU变量V之后，线程B再访问就一定可以得到最新值：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/3084894-daaffaf66a9ac336.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>一个线程对共享变量的修改，另外一个线程立刻看到，我们称为<strong>可见性</strong>。</p><h4 id="多核时代"><a href="#多核时代" class="headerlink" title="多核时代"></a>多核时代</h4><p>多核时代，每颗 CPU 都有自己的缓存，这时 CPU 缓存与内存的数据一致性就没那么容易解决了。</p><p>当多个线程在不同的 CPU 上执行时，这些线程操作的是不同的CPU。</p><p>线程 A 操作的是 CPU-1 上的缓存，而线程B操作的是 CPU-2 上的缓存，很明显，这个时候线程 A 对变量 V 的操作对于线程B 而言就不具备可见性了。这个就属于硬件程序员给软件程序员挖的“坑”。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/3084894-e90b1d6bad3f4d22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多核 CPU 的缓存与内存关系图" title>                </div>                <div class="image-caption">多核 CPU 的缓存与内存关系图</div>            </figure><p>下面我们再用一段代码来验证一下多核场景下的可见性问题。下面的代码，每执行一次 add10K() 方法，都会循环 10000 次 count+=1 操作。在 calc() 方法中我们创建了两个线程，每个线程调用一次 add10K() 方法，我们来想一想执行 calc() 方法得到的结果应该是多少呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add10K</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(idx++ &lt; <span class="number">10000</span>) &#123;</span><br><span class="line">      count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">    <span class="comment">// 创建两个线程，执行 add() 操作</span></span><br><span class="line">    Thread th1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      test.add10K();</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread th2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      test.add10K();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 启动两个线程</span></span><br><span class="line">    th1.start();</span><br><span class="line">    th2.start();</span><br><span class="line">    <span class="comment">// 等待两个线程执行结束</span></span><br><span class="line">    th1.join();</span><br><span class="line">    th2.join();</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直觉可能告诉你应该是20000，但实际结果确实10000到20000之间的随机数。为什么那？因为两个线程在两cpu的核之间不断切换才导致的。</p><blockquote><p>G:所谓可见性问题，说白了可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值同时可以操作这个值。</p></blockquote><h3 id="源头之二：线程切换带来的原子性问题"><a href="#源头之二：线程切换带来的原子性问题" class="headerlink" title="源头之二：线程切换带来的原子性问题"></a>源头之二：线程切换带来的原子性问题</h3><ul><li><p>关键词：</p><ul><li><p>线程切换</p></li><li><p>时间片</p></li><li><p>多进程</p></li><li><p>unix操作系统支持多进程分时复用而名噪天下</p></li><li><p>内存映射</p></li><li><p>一个进程创建的所有线程共享同一个内存空间</p></li><li><p>提到的“任务切换”都是指“线程切换”</p></li><li><p>高级语句里一条语句需要多条CPU指令来完成</p><p>  比如：count + =1，需要以下几个指令来完成</p><ul><li><p>指令一：把count从内存加载到cpu寄存器中</p></li><li><p>指令二：在寄存器执行+1操作</p></li><li><p>指令三：最后，将结果写入内存（缓存机制导致可能写入的是CPU缓存而不是内存）</p></li></ul></li></ul></li><li><p>重点语句</p><ul><li>我们把一个或多个操作在CPU执行的过程中不被中断的特性称为原子性。</li></ul></li></ul><h3 id="源头之三：编译优化带来的有序性问题"><a href="#源头之三：编译优化带来的有序性问题" class="headerlink" title="源头之三：编译优化带来的有序性问题"></a>源头之三：编译优化带来的有序性问题</h3><ul><li><p>关键词</p><p>  -</p></li><li><p>关键语句</p><ul><li>有序性：代码按先后顺序执行</li></ul></li><li><p>案例分析</p><ul><li><p>利用双重检查创建单例对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">          instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，假设有两个线程同时判断instance为null—&gt;此时A和B任意一个线程加锁成功（假设是A）,另外一个线程处于等待状态（假设是B）—&gt;线程A创建实例释放锁，然后唤醒B —&gt; B继续加锁，结果实力不为空，B不创建实例</p><p>以上逻辑看似无懈可击，但实际并不完美，问题出在哪里？？</p><p>出在new操作上</p><p>我们以为的new操作：</p><ul><li><p>1.分配一块内存M</p></li><li><p>2.在内存M上初始化Singleton对象</p></li><li><p>3.然后M的地址赋值给instance对象</p></li></ul><p>实际优化后如下：</p><ul><li><p>1.分配一块内存M</p></li><li><p>2.将M的地址赋值给instanc变量</p></li><li><p>3.最后在M上初始化Singleton对象</p></li></ul><p>优化后会导致什么问题那？假设A先执行getInstance()方法，当执行完指令2后恰好发生了线程切换，切换到线程B上；如果此时线程B也执行getInstance方法，那么线程B在执行第一个判断时会发现instance！=null，所以直接返回instance，而此时的instance是没有初始化过的，如果这个时候访问instance的成员变量就可能触发空指针异常。</p></li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>要想写好并发，就要知道并发问题出在哪里</p></li><li><p>只要我们能够深刻理解可见性/原子性/有序性在并发场景下的原理，很多并发bug都可以理解，可以诊断。</p></li><li><p>缓存导致可见性问题</p></li><li><p>线程切换带来的原子性问题</p></li><li><p>编译优化带来的有序性问题</p></li><li><p>在采用一项技术的时候一定要清楚它带来的问题是啥，以及如何规避</p></li></ul><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul><li>1.常听人说，在 32 位的机器上对 long 型变量进行加减操操作存在并发隐患，到底是不是这样呢？</li></ul><p>long类型64位，所以在32位的机器上，对long类型的数据操作通常需要多条指令组合出来，无法保证原子性，所以并发的时候会出问题        </p><blockquote><p>疑问：什么是32位机器？指的是啥？</p></blockquote><p>cpu运算的数据都是由内存提供的，内存与cpu的通信速度靠的是外部频率（所谓外频指的是cpu与外部组件进行数据传输/运算是的速度，倍频则是cpu内部用来加速工作性能的一个倍数，两者相乘才是cpu的频率），每次工作可以传输的数据量大小是由总线决定的。一般主板芯片组分为北桥与南桥，北桥的总线称为系统总线，因为是内存传输的主要信道，所以速度较快；南桥就是所谓的输入输出（I/O）总线，主要用于联系硬盘、usb、网卡等接口设备。</p><p>北桥所支持的频率我们称之为前端总线速度（Front Side Bus,FSB），而每次传输的位数则是总线宽度。所以总线频宽 = FSB x 总线宽度，也就是每秒钟可传送的最大数据量，目前常见的总线宽度有32为和64位。</p><p>例如前端总线的最高速度可达1600MHZ。我们看到内存和北桥的频宽为12.8GB/S，也就是1600MHZ x 64Bit =1600MHZ x 8Bytes = 12800MHZ = 12.8GB/S。</p><p>与总线宽度相似，cpu每次能处理的数据量称为字组大小，字组大小依据cpu的设计而有32位与64位。我们现在所称的计算机是32位或64位主要依据cpu解析的字组大小而来的！早期的32位cpu中，因为cpu每次能够解析的数据量有限，因此由内存传来的数据量就有所限制了。这也导致32位的cpu最多只能支持最大到4GB的内存。</p><blockquote><p>推荐书单</p></blockquote><p>-《Java并发编程实战》作者阵容可谓大师云集，也包括Doug Lea</p><p>-《Java并发编程的艺术》讲解并发包内部实现原理，能读明白，内功大增</p><p>-《图解Java多线程设计模式》并发编程设计模式方面的经典书籍</p><p>-《操作系统：精髓与设计原理》经典操作系统教材</p><ul><li><p><a href="http://ifeve.com" target="_blank" rel="noopener">http://ifeve.com</a> 国内专业并发编程网站</p></li><li><p><a href="http://www.cs.umd.edu/~pugh/java/memoryModel/" target="_blank" rel="noopener">http://www.cs.umd.edu/~pugh/java/memoryModel/</a> 很多并发编程的早期资料都在这里</p></li></ul><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a></p></blockquote><blockquote><p><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;阅读笔记&quot;&gt;&lt;a href=&quot;#阅读笔记&quot; class=&quot;headerlink&quot; title=&quot;阅读笔记&quot;&gt;&lt;/a&gt;阅读笔记&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可见性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;原子性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;有序性&lt;/p&gt;
&lt;/l
      
    
    </summary>
    
      <category term="高并发" scheme="https://lywlefan.github.io/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://lywlefan.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="读书笔记" scheme="https://lywlefan.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java并发编程实战-王宝令" scheme="https://lywlefan.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98-%E7%8E%8B%E5%AE%9D%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>12.客户端都有哪些不常见但是很高级的功能？</title>
    <link href="https://lywlefan.github.io/2019/07/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/kafka%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98-%E8%83%A1%E5%A4%95/12.%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%B8%B8%E8%A7%81%E4%BD%86%E6%98%AF%E5%BE%88%E9%AB%98%E7%BA%A7%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%9F/"/>
    <id>https://lywlefan.github.io/2019/07/02/中间件/kafka/读书笔记/kafka核心技术与实战-胡夕/12.客户端都有哪些不常见但是很高级的功能？/</id>
    <published>2019-07-01T16:00:00.000Z</published>
    <updated>2019-07-02T05:47:03.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h2><h3 id="kafka-拦截器"><a href="#kafka-拦截器" class="headerlink" title="kafka 拦截器"></a>kafka 拦截器</h3><p>拦截器的原理和spring的拦截器的原理类似，可以做消息处理前后多个点的动态植入不同的处理逻辑。比如消息发送前或者在消息消费后。</p><p>kafka拦截器分为生产者拦截器和消费者拦截器。</p><p>生产拦截器允许你在发送消息前以及消息提交后植入你的拦截器逻辑；</p><p>消费拦截器支持在消费消息前以及提交位移后编写特定逻辑。</p><p>两种拦截器都支持链的方式，kafka会按序执行拦截器逻辑。</p><p>###如何编写拦截器？</p><ul><li><p>生产者拦截器继承接口ProducerInterceptor</p><ul><li><p>onSend：消息调用前被调用</p></li><li><p>onAcknowledgement：消息提交成功或发送失败后被调用。这个方法要早于callback。这个方法和onSend不是在同一个线程里面调用，因此在两个方法调用过程中调用了某个共享变量，一定要保证线程安全。这个方法处在Producer发送的主路径中，所以我们不要放一些太重逻辑进去，负责你会发现Producer的TPS直线下降。</p></li></ul></li><li><p>消费者拦截器实现ConsumerInterceptor接口</p><ul><li><p>onConsume：在消息返回给Consumer 程序之前调用。也就是在消息开始处理前拦截一道。</p></li><li><p>onCommit：Consumer 在提交位移之后调用该方法。通常你可以在该方法做一些记账类的动作，比如：日志打印。</p></li></ul></li><li><p>注意的问题</p><ul><li>指定拦截器要指定它们全限定名，说的直白一点就是要把包名加上</li></ul></li></ul><h3 id="典型使用场景"><a href="#典型使用场景" class="headerlink" title="典型使用场景"></a>典型使用场景</h3><ul><li>客户端监控</li></ul><p>kafka默认提供的监控指标都是针对单个客户端或Broker的，你很难从具体消息维度去追踪群间消息的流转路径。同时如何监控一条消息从生产到最后消费的端到端延时也是很多kafka用户需要解决的问题。</p><p>从技术上讲，我们可以在客户端增加这样的逻辑，但是监控一般是不跟业务代码耦合的，因为耦合会影响业务代码性能。</p><p>基于以上的考虑，我们可以把监控的逻辑加到拦截器里面，这样做的好处可以实现可插拔，不耦合。    </p><ul><li>端到端性能检测</li></ul><p>同上。</p><ul><li>消息审计</li></ul><p>所谓消息审计就是可以随时查看消息的去向，什么时间发布的？被什么业务消费了？我们就可以借用kafka的拦截器实现这个场景。</p><h3 id="案例分享"><a href="#案例分享" class="headerlink" title="案例分享"></a>案例分享</h3><ul><li>处理端到端的延时</li></ul><p>统计Producer到Consumer消费时间总时长，我们消费拦截器就可以按如下来写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvgLatencyProducerInterceptor</span> <span class="keyword">implements</span> <span class="title">ProducerInterceptor</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Jedis jedis; <span class="comment">// 省略 Jedis 初始化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProducerRecord&lt;String, String&gt; <span class="title">onSend</span><span class="params">(ProducerRecord&lt;String, String&gt; record)</span> </span>&#123;</span><br><span class="line">        jedis.incr(<span class="string">"totalSentMessage"</span>);</span><br><span class="line">        <span class="keyword">return</span> record;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAcknowledgement</span><span class="params">(RecordMetadata metadata, Exception exception)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map&lt;java.lang.String, ?&gt; configs)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面是消费端代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvgLatencyConsumerInterceptor</span> <span class="keyword">implements</span> <span class="title">ConsumerInterceptor</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Jedis jedis; <span class="comment">// 省略 Jedis 初始化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConsumerRecords&lt;String, String&gt; <span class="title">onConsume</span><span class="params">(ConsumerRecords&lt;String, String&gt; records)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> lantency = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">            lantency += (System.currentTimeMillis() - record.timestamp());</span><br><span class="line">        &#125;</span><br><span class="line">        jedis.incrBy(<span class="string">"totalLatency"</span>, lantency);</span><br><span class="line">        <span class="keyword">long</span> totalLatency = Long.parseLong(jedis.get(<span class="string">"totalLatency"</span>));</span><br><span class="line">        <span class="keyword">long</span> totalSentMsgs = Long.parseLong(jedis.get(<span class="string">"totalSentMessage"</span>));</span><br><span class="line">        jedis.set(<span class="string">"avgLatency"</span>, String.valueOf(totalLatency / totalSentMsgs));</span><br><span class="line">        <span class="keyword">return</span> records;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCommit</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map&lt;String, ?&gt; configs)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里我们可以用redis记录消息消费的时间,到redis中我们就可以很好的进行统计了,可以很好的统计到从producer到consumer的时间了。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a></p></blockquote><blockquote><p><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;阅读笔记&quot;&gt;&lt;a href=&quot;#阅读笔记&quot; class=&quot;headerlink&quot; title=&quot;阅读笔记&quot;&gt;&lt;/a&gt;阅读笔记&lt;/h2&gt;&lt;h3 id=&quot;kafka-拦截器&quot;&gt;&lt;a href=&quot;#kafka-拦截器&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="中间件" scheme="https://lywlefan.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="读书笔记" scheme="https://lywlefan.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="kafka" scheme="https://lywlefan.github.io/tags/kafka/"/>
    
      <category term="kafka核心技术与实战-胡夕" scheme="https://lywlefan.github.io/tags/kafka%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98-%E8%83%A1%E5%A4%95/"/>
    
  </entry>
  
  <entry>
    <title>11.无消息丢失配置怎么实现？</title>
    <link href="https://lywlefan.github.io/2019/07/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/kafka%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98-%E8%83%A1%E5%A4%95/11.%E6%97%A0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E9%85%8D%E7%BD%AE%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F/"/>
    <id>https://lywlefan.github.io/2019/07/01/中间件/kafka/读书笔记/kafka核心技术与实战-胡夕/11.无消息丢失配置怎么实现？/</id>
    <published>2019-06-30T16:00:00.000Z</published>
    <updated>2019-07-01T07:43:27.779Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h2><ul><li><p>kafka中什么算消息丢失</p></li><li><p>什么情况下能保证kafka消息不丢失</p></li></ul><p>一句话概括,Kafka只对”已提交”的消息做有限度的持久化保证。</p><h3 id="什么是已提交的消息"><a href="#什么是已提交的消息" class="headerlink" title="什么是已提交的消息?"></a>什么是已提交的消息?</h3><p>当kafka的若干个Broker成功的接收到一条消息并写入到日志文件之后,它们就会告诉生产者程序这条消息已成功提交。此时,这条消息在kafka看来就正式变为”已提交”消息了。</p><p>为什么是若干个Broker?这取决于”已提交”的定义,你可以选择只有一个broker成功保存该消息就算已提交,也可以令所有broker都保存才算已提交.</p><h3 id="有限度的持久化保证"><a href="#有限度的持久化保证" class="headerlink" title="有限度的持久化保证"></a>有限度的持久化保证</h3><p>至少有一个Broker存活,只要这个条件成立,kafka就不会丢消息,但是一个都不会存活的情况是有可能出现的.</p><h4 id="消息丢失的案例"><a href="#消息丢失的案例" class="headerlink" title="消息丢失的案例"></a>消息丢失的案例</h4><p>复盘”kafka消息丢失”案例。</p><h5 id="生产者程序丢失数据"><a href="#生产者程序丢失数据" class="headerlink" title="生产者程序丢失数据"></a>生产者程序丢失数据</h5><p>kafka producer是异步发送消息的,所以说当我们调用完producer.send(msg)这个api后,他通过会立即返回,但是并不代表我们消息发送成功.</p><p>以上发送消息的方式是不靠谱的,建议不要这样去搞,因为这种方式以下原因可能造成消息发送失败:</p><ul><li><p>网络抖动</p></li><li><p>消息本身不合格,Broker不接受</p></li></ul><p>解决以上问题其实有比较好的办法,就是我们Producer永远使用带有回调通知的发送API,也就是说不要使用producer.send(msg),而要使用producer.send(msg,callback),callback会告诉你消息是否处理成功,然后你再根据具体情况进行相应的处理。</p><p>如果因为某些瞬间错误,可以让producer继续重试,总之发送消息失败的责任是producer而不是在broker,当然broker宕机断网除外。</p><h5 id="消费者程序丢失数据"><a href="#消费者程序丢失数据" class="headerlink" title="消费者程序丢失数据"></a>消费者程序丢失数据</h5><p>在kafka消费消息的时候有个”位移”的概念,我们可以把消费消息当做我们读书,而”位移”就相当于”书签”。</p><p>什么情况下消费者程序会存在丢数据的情况哪???</p><p>我们把上面的类比分成两个部分:1.读书 2.移动书签位置</p><p>加入我们先移动书签,再读书就有可能造成消费者丢数据的情况,比如:我们计划读书到100页,然后我们把书签放到100页,当我们读到96页的时候突然有急事出去了,下次继续读的时候就从100页开始了,中间的页我们就没读到。</p><p>针对以上情况,我们应该是先读书然后移动书签的位置。</p><blockquote><p>但是先读书再移动书签会不会造成消息重复消费的情况。</p></blockquote><p>还一种多线程消费的情况,以前我们是一个人读书,现在把一本书10章分给10个人一起读,然后大家读完宣布这本书读完。</p><p>以上这种情况有可能这种异常情况,有部分线程没有读完就更新了位移,这就导致部分消息没有消费,但是响应的确实已经消费了的情况。</p><p>解决以上问题的办法就是:多线程处理消费消息,Consumer程序不要开启自动提交位移,而是要应用程序手动提交位移。</p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul><li><p>使用掉回调的生产消息的方法</p></li><li><p>设置 acks = all。acks 是 Producer的一个参数，代表了你对“已提交”消息的定义。如果设置成 all，则表明所有副本 Broker都要接收到消息，该消息才算是“已提交”。这是最高等级的“已提交”定义。</p></li><li><p>设置 retries 为一个较大的值。这里的 retries 同样是 Producer 的参数，对应前面提到的 Producer 自动重试。当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了 retries &gt; 0 的 Producer 能够自动重试消息发送，避免消息丢失。</p></li><li><p>设置 unclean.leader.election.enable = false。这是 Broker 端的参数，它控制的是哪些 Broker有资格竞选分区的 Leader。如果一个 Broker 落后原先的 Leader 太多，那么它一旦成为新的 Leader，必然会造成消息的丢失。故一般都要将该参数设置成 false，即不允许这种情况的发生。</p></li><li><p>设置 replication.factor &gt;= 3。这也是 Broker 端的参数。其实这里想表述的是，最好将消息多保存几份，毕竟目前防止消息丢失的主要机制就是冗余。</p></li><li><p>设置 min.insync.replicas &gt; 1。这依然是 Broker 端参数，控制的是消息至少要被写入到多少个副本才算是“已提交”。设置成大于 1 可以提升消息持久性。在实际环境中千万不要使用默认值 1。</p></li><li><p>确保 replication.factor&gt; min.insync.replicas。如果两者相等，那么只要有一个副本挂机，整个分区就无法正常工作了。我们不仅要改善消息的持久性，防止数据丢失，还要在不降低可用性的基础上完成。推荐设置成 replication.factor = min.insync.replicas + 1。</p></li><li><p>确保消息消费完成再提交。Consumer 端有个参数 enable.auto.commit，最好把它设置成 false ，并采用手动提交位移的方式。 就像前面说的，这对于单 Consumer 多线程处理的场景而言是至关重要的。</p></li></ul><h3 id="开发讨论"><a href="#开发讨论" class="headerlink" title="开发讨论"></a>开发讨论</h3><p>特别隐秘丢消息的场景:</p><p>当增加主题分区后，在某段“不凑巧”的时间间隔后，Producer 先于 Consumer 感知到新增加的分区，而 Consumer 设置的是“从最新位移处”开始读取消息，因此在 Consumer 感知到新分区前，Producer 发送的这些消息就全部“丢失”了，或者说 Consumer 无法读取到这些消息。Kafka 设计上的一个小缺陷，你有什么解决的办法吗？</p><ul><li><p>cricket1981：consumer改用”从最早位置”读解决新加分区造成的问题</p></li><li><p>明翼：这个问题我想个办法就是程序停止再增加分区，如果不能停止那就找个通知机制了。请教一个问题min.insync.replicas这个参数如果设置成3，假设副本数设置为4，那岂不是只支持一台broker坏掉的情况？</p></li><li><p>作者：能想到的一个简单方法是让consumer端缓存订阅信息，如果发现新的订阅分区出现，手动调整位移到最开始处执行（比如consumer.seekToBeginning）</p></li></ul><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a></p></blockquote><blockquote><p><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;阅读笔记&quot;&gt;&lt;a href=&quot;#阅读笔记&quot; class=&quot;headerlink&quot; title=&quot;阅读笔记&quot;&gt;&lt;/a&gt;阅读笔记&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;kafka中什么算消息丢失&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;什么情况下能保证kafka消息不丢失&lt;/p&gt;
      
    
    </summary>
    
      <category term="中间件" scheme="https://lywlefan.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="读书笔记" scheme="https://lywlefan.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="kafka" scheme="https://lywlefan.github.io/tags/kafka/"/>
    
      <category term="kafka核心技术与实战-胡夕" scheme="https://lywlefan.github.io/tags/kafka%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98-%E8%83%A1%E5%A4%95/"/>
    
  </entry>
  
  <entry>
    <title>redis的FAQ</title>
    <link href="https://lywlefan.github.io/2019/06/28/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/FAQ/"/>
    <id>https://lywlefan.github.io/2019/06/28/中间件/redis/FAQ/</id>
    <published>2019-06-27T16:00:00.000Z</published>
    <updated>2019-07-27T10:22:47.106Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题整理"><a href="#问题整理" class="headerlink" title="问题整理"></a>问题整理</h3><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a></p></blockquote><blockquote><p><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><blockquote><p><a href="https://redis.io" target="_blank" rel="noopener">【3】redis官网</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题整理&quot;&gt;&lt;a href=&quot;#问题整理&quot; class=&quot;headerlink&quot; title=&quot;问题整理&quot;&gt;&lt;/a&gt;问题整理&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;参考文档&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquo
      
    
    </summary>
    
      <category term="中间件" scheme="https://lywlefan.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="redis" scheme="https://lywlefan.github.io/tags/redis/"/>
    
      <category term="学习笔记" scheme="https://lywlefan.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>01.初始redis</title>
    <link href="https://lywlefan.github.io/2019/06/28/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/01.%E5%88%9D%E5%A7%8Bredis/"/>
    <id>https://lywlefan.github.io/2019/06/28/中间件/redis/01.初始redis/</id>
    <published>2019-06-27T16:00:00.000Z</published>
    <updated>2019-07-27T10:22:47.209Z</updated>
    
    <content type="html"><![CDATA[<h3 id="redis是什么"><a href="#redis是什么" class="headerlink" title="redis是什么?"></a>redis是什么?</h3><p>redis是一个内存型数据(in-memory data structure store)。</p><h3 id="redis支持什么数据类型"><a href="#redis支持什么数据类型" class="headerlink" title="redis支持什么数据类型"></a>redis支持什么数据类型</h3><h4 id="字符类型-strings"><a href="#字符类型-strings" class="headerlink" title="字符类型(strings)"></a>字符类型(strings)</h4><h4 id="哈希类型-hashes"><a href="#哈希类型-hashes" class="headerlink" title="哈希类型(hashes)"></a>哈希类型(hashes)</h4><h4 id="list集合类型-lists"><a href="#list集合类型-lists" class="headerlink" title="list集合类型(lists)"></a>list集合类型(lists)</h4><h4 id="set集合类型-sets"><a href="#set集合类型-sets" class="headerlink" title="set集合类型(sets)"></a>set集合类型(sets)</h4><ul><li><p>不允许重复</p></li><li><p>无序</p></li></ul><h4 id="sorted-set集合类型-sorted-sets"><a href="#sorted-set集合类型-sorted-sets" class="headerlink" title="sorted set集合类型(sorted sets)"></a>sorted set集合类型(sorted sets)</h4><ul><li><p>不允许重复</p></li><li><p>有序(通过设置分数进行排序)</p></li></ul><h4 id="位图-bitmaps"><a href="#位图-bitmaps" class="headerlink" title="位图(bitmaps)"></a>位图(bitmaps)</h4><ul><li><p>按位进行标识</p></li><li><p>适合某个时间段状态只有两种的场景</p></li></ul><p>比如:签到,每天签到,状态就是签了或者没签</p><ul><li>占用内存小</li></ul><h4 id="hyperloglogs"><a href="#hyperloglogs" class="headerlink" title="hyperloglogs"></a>hyperloglogs</h4><h5 id="数据结构描述"><a href="#数据结构描述" class="headerlink" title="数据结构描述"></a>数据结构描述</h5><h5 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h5><ul><li><p>基数统计(不允许重复的数据)</p></li><li><p>占用12k空间</p></li></ul><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul><li>大数据量统计</li></ul><p>比如:高并发网站UV、PV等运营数据的统计。</p><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a></p></blockquote><blockquote><p><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><blockquote><p><a href="https://redis.io" target="_blank" rel="noopener">【3】redis官网</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;redis是什么&quot;&gt;&lt;a href=&quot;#redis是什么&quot; class=&quot;headerlink&quot; title=&quot;redis是什么?&quot;&gt;&lt;/a&gt;redis是什么?&lt;/h3&gt;&lt;p&gt;redis是一个内存型数据(in-memory data structure store
      
    
    </summary>
    
      <category term="中间件" scheme="https://lywlefan.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="redis" scheme="https://lywlefan.github.io/tags/redis/"/>
    
      <category term="学习笔记" scheme="https://lywlefan.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>redis的VERSION</title>
    <link href="https://lywlefan.github.io/2019/06/28/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/VERSION/"/>
    <id>https://lywlefan.github.io/2019/06/28/中间件/redis/VERSION/</id>
    <published>2019-06-27T16:00:00.000Z</published>
    <updated>2019-07-27T10:22:47.165Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题整理"><a href="#问题整理" class="headerlink" title="问题整理"></a>问题整理</h3><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a></p></blockquote><blockquote><p><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><blockquote><p><a href="https://redis.io" target="_blank" rel="noopener">【3】redis官网</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题整理&quot;&gt;&lt;a href=&quot;#问题整理&quot; class=&quot;headerlink&quot; title=&quot;问题整理&quot;&gt;&lt;/a&gt;问题整理&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;参考文档&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquo
      
    
    </summary>
    
      <category term="中间件" scheme="https://lywlefan.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="redis" scheme="https://lywlefan.github.io/tags/redis/"/>
    
      <category term="学习笔记" scheme="https://lywlefan.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>10.生产者压缩算法面面观</title>
    <link href="https://lywlefan.github.io/2019/06/28/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/kafka%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98-%E8%83%A1%E5%A4%95/10.%E7%94%9F%E4%BA%A7%E8%80%85%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%E9%9D%A2%E9%9D%A2%E8%A7%82/"/>
    <id>https://lywlefan.github.io/2019/06/28/中间件/kafka/读书笔记/kafka核心技术与实战-胡夕/10.生产者压缩算法面面观/</id>
    <published>2019-06-27T16:00:00.000Z</published>
    <updated>2019-06-28T10:22:40.122Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h2><ul><li><p>消息压缩</p></li><li><p>GZIP</p></li><li><p>Snappy</p></li><li><p>Zero Copy(零拷贝技术)</p></li><li><p>何时压缩</p></li></ul><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><h4 id="压缩算法笔记"><a href="#压缩算法笔记" class="headerlink" title="压缩算法笔记"></a>压缩算法笔记</h4><ul><li><p>GZIP</p></li><li><p>Snappy</p></li><li><p>LZ4</p></li><li><p>Zstandard(zstd):2.1.0开始，facebook开源的压缩算法，能够提高超高性能压缩比。</p></li></ul><h5 id="如何压缩"><a href="#如何压缩" class="headerlink" title="如何压缩"></a>如何压缩</h5><blockquote><p>v1（kafka 0.11.0之前）:message set, message ,v2（kafka 0.11.0以后）:record batch,record</p></blockquote><p>我看了三遍老师的课，得到了我要的答案：<br>1.如果生产者使用了压缩，broker为了crc校验，会启动解压，这个解压过程不可避免；<br>2.v2的broker为了低版本的消费者，会把消息再次解压并进行协议转换。</p><ul><li><p>CRC校验（每条消息执行CRC校验）</p></li><li><p>消息集合</p></li><li><p>消息</p></li><li><p>日志项</p></li></ul><h5 id="看一个压缩算法的指标"><a href="#看一个压缩算法的指标" class="headerlink" title="看一个压缩算法的指标"></a>看一个压缩算法的指标</h5><ul><li>压缩比</li></ul><p>原来占100份空间的东西压缩成20，那么压缩比就是5，显然压缩比越高越好。</p><ul><li>吞吐量(压缩/解压缩)</li></ul><p>每秒能压缩或者解压多少MB数据,同样吞吐量也是越高越好。</p><h5 id="facebook各个压缩算法性能测试"><a href="#facebook各个压缩算法性能测试" class="headerlink" title="facebook各个压缩算法性能测试"></a>facebook各个压缩算法性能测试</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/3084894-0842150408ba26c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png" title>                </div>                <div class="image-caption">1.png</div>            </figure><h5 id="如何选择压缩算法"><a href="#如何选择压缩算法" class="headerlink" title="如何选择压缩算法"></a>如何选择压缩算法</h5><ul><li><p>启用压缩的一个条件就是Producer程序运行机器上的CPU要充足。</p></li><li><p>带宽资源有限建议开启压缩(带宽比cpu和内存还要珍贵)</p></li><li><p>cpu资源富于，建议开启zstd压缩，这样能极大节省网络资源消耗。</p></li><li><p>规避意料之外的解压缩，比如：兼容老版本而引入解压缩</p></li><li><p>有条件尽量保证不要出现消息格式转换的情况</p></li></ul><h3 id="浓缩精华"><a href="#浓缩精华" class="headerlink" title="浓缩精华"></a>浓缩精华</h3><ul><li>Producer端压缩/Broker端保持/Consumer端解压</li></ul><h3 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h3><h4 id="producer和broker端的压缩算法尽量保持一致"><a href="#producer和broker端的压缩算法尽量保持一致" class="headerlink" title="producer和broker端的压缩算法尽量保持一致"></a>producer和broker端的压缩算法尽量保持一致</h4><h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><h4 id="京东小哥建议"><a href="#京东小哥建议" class="headerlink" title="京东小哥建议"></a>京东小哥建议</h4><blockquote><p>去掉因为做消息校验而引入解压缩,据他们称，去掉解压缩后，Broker端CPU使用率至少降低了50%。</p></blockquote><p>社区未采纳建议，原因是消息校验特别重要，不能盲目去掉。</p><h3 id="应用实践"><a href="#应用实践" class="headerlink" title="应用实践"></a>应用实践</h3><h4 id="实时日志收集系统"><a href="#实时日志收集系统" class="headerlink" title="实时日志收集系统"></a>实时日志收集系统</h4><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a></p></blockquote><blockquote><p><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;阅读笔记&quot;&gt;&lt;a href=&quot;#阅读笔记&quot; class=&quot;headerlink&quot; title=&quot;阅读笔记&quot;&gt;&lt;/a&gt;阅读笔记&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;消息压缩&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;GZIP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Snappy&lt;/p
      
    
    </summary>
    
      <category term="中间件" scheme="https://lywlefan.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="读书笔记" scheme="https://lywlefan.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="kafka" scheme="https://lywlefan.github.io/tags/kafka/"/>
    
      <category term="kafka核心技术与实战-胡夕" scheme="https://lywlefan.github.io/tags/kafka%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98-%E8%83%A1%E5%A4%95/"/>
    
  </entry>
  
  <entry>
    <title>09.生产者消息分区机制原理剖析</title>
    <link href="https://lywlefan.github.io/2019/06/28/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/kafka%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98-%E8%83%A1%E5%A4%95/09.%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E6%81%AF%E5%88%86%E5%8C%BA%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    <id>https://lywlefan.github.io/2019/06/28/中间件/kafka/读书笔记/kafka核心技术与实战-胡夕/09.生产者消息分区机制原理剖析/</id>
    <published>2019-06-27T16:00:00.000Z</published>
    <updated>2019-06-28T08:38:14.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h2><h3 id="生产者消息分区机制原理剖析"><a href="#生产者消息分区机制原理剖析" class="headerlink" title="生产者消息分区机制原理剖析"></a>生产者消息分区机制原理剖析</h3><ul><li><p>如何将大的数据均匀的分配到Kafka的各个Broker上？</p></li><li><p>为什么分区？</p></li></ul><h4 id="为什么分区？"><a href="#为什么分区？" class="headerlink" title="为什么分区？"></a>为什么分区？</h4><ul><li><p>三级结构：主题-分区-消息</p></li><li><p>主题下的每条消息只会保存在某一个分区中，而不会在多个分区中被保存多份</p></li></ul><blockquote><p>疑问:为什么kafka要这样设计？有什么好处？</p></blockquote><p><strong>回答</strong>:我们设想一个问题，我们在学校找一个学生，如果我们直接把学生集中在一起去找是不是很麻烦，很低效。换种方式，每50个学生一组，配置一个负责人，然后通知这些负责人去找某个同学，是不是很快就可以找到了，这也就是分区的意义所在。如果，我们把这种思想放到我们的系统中，就可以提高我们系统的负载均衡能力，实现了系统的高伸缩性(Scalability)</p><ul><li>不同的分区能够被放置到不同节点的机器上</li></ul><blockquote><p>疑问：同一个topic下不同的分区是保存到相同机器的不同磁盘上的吗？</p></blockquote><p><strong>回答</strong>:</p><p>在 MongoDB 和 Elasticsearch 中就叫分Shard，而在HBase中则叫Region,在Cassandra中又被称作vnode。</p><ul><li>实现业务级别的消息顺序的问题</li></ul><h5 id="都有哪些分区策略？"><a href="#都有哪些分区策略？" class="headerlink" title="都有哪些分区策略？"></a>都有哪些分区策略？</h5><p>所谓分区策略是决定生产者将消息发送到那个分区的算法。提供了默认的分区策略，同时支持自定义分区策略。</p><ul><li><p>自定义分区</p><ul><li><p>配置partitioner.class参数</p></li><li><p>实现Partitioner接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes, Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster)</span></span>;</span><br></pre></td></tr></table></figure><p>这里的topic、key、keyBytes、value和valueBytes都属于消息数据，cluster则是集群信息(比如当前Kafka集群有多少主题，多少Broker等)。</p></li></ul></li><li><p>策略</p><ul><li><p>轮询策略(Round-robin)</p><p>轮询是kafka默认的消息存储策略，新增的消息会依次进入1/2/3/4/….对应的分区。轮询策略有非常优秀的负载均衡表现，它总能保证消息最大限度地平均分配到所有分区上，故默认情况下它是最合理的分区策略，也是我们常用的分区策略之一。</p></li><li><p>随机策略(Randomness)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line"><span class="keyword">return</span> ThreadLocalRandom.current().nextInt(partitions.size());</span><br><span class="line">``` </span><br><span class="line">实现比较简单，先计算出该主题总的分区数，然后随机地返回一个小于它的正整数。</span><br><span class="line"></span><br><span class="line">该策略是kafka老版本的策略，追求数据均匀分布还是轮询策略比较好。</span><br><span class="line"></span><br><span class="line">- 按消息键保序策略</span><br><span class="line"></span><br><span class="line">    - 同一个消息key的消息进入同一个分区</span><br><span class="line">    </span><br><span class="line">    - 一个分区只能被同一个消费组（ConsumerGroup）内的一个消费者消费</span><br><span class="line">    </span><br><span class="line">    这里我们可以给我们的消息以时间的维度定义key，如此同一时间的消息就进入了同一个分区，同一个分区下的消息也有了顺序性。</span><br><span class="line">    </span><br><span class="line">    - 每个分区消息都是有顺序的</span><br><span class="line">    </span><br><span class="line">    - 代码实现</span><br><span class="line">    </span><br><span class="line">    ```java</span><br><span class="line">    List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line">    <span class="keyword">return</span> Math.abs(key.hashCode()) % partitions.size();</span><br></pre></td></tr></table></figure></li><li><p>其他分区策略(比如：基于地理位置的分区策略)</p><ul><li><p>场景</p><p>公司有两个机房，一个在广州，一个在北京，在每个机房里面抽取部分机器组成kafka集群。现在公司app搞活动，北京新注册的用户送北京烤鸭一只，广州注册的用户送一次大保健，我们如何用kafka实现这一需求？</p></li><li><p>解决方案一</p></li><li><p>解决方案二</p></li></ul></li></ul></li></ul><h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><h3 id="自己提问"><a href="#自己提问" class="headerlink" title="自己提问"></a>自己提问</h3><h4 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h4><blockquote><p>通过kafka创建一个topic，默认分几个区？</p></blockquote><p><strong>回答</strong>：创建topic的时候就需要指定需要创建的分区个数.</p><h4 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h4><blockquote><p>基于地理位置的分区策略可以通过按消息键保序策略实现，这样做有什么意义？</p></blockquote><h3 id="其他人的问题"><a href="#其他人的问题" class="headerlink" title="其他人的问题"></a>其他人的问题</h3><h4 id="问题1-1"><a href="#问题1-1" class="headerlink" title="问题1"></a>问题1</h4><blockquote><p>老师能不能有空能不能讲讲kafka和rocketMQ的对比, 我用下来感觉整体挺像的但是具体使用场景和性能优劣方面还是有点不知道该使用选择, 谢谢.</p></blockquote><p><strong>回答</strong>：在我看来RocketMQ与Kafka的主要区别 ：1. Kafka吞吐量大，多是面向大数据场景。RocketMQ吞吐量也很强， 不过它号称是金融业务级的消息中间件，也就是说可以用于实际的业务系统；2. RocketMQ毕竟是阿里出品，在国内技术支持力度要比Kafka强；3. Kafka现在主要发力Streaming，RocketMQ在流处理这块表现如何我不太清楚，至少streaming不是它现阶段的主要卖点。</p><h4 id="问题2-1"><a href="#问题2-1" class="headerlink" title="问题2"></a>问题2</h4><blockquote><p>kafka的主题只有一级、像mq可以进行主题分层：一级主题、二级主题。kafka为何这样设计？</p></blockquote><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a></p></blockquote><blockquote><p><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;阅读笔记&quot;&gt;&lt;a href=&quot;#阅读笔记&quot; class=&quot;headerlink&quot; title=&quot;阅读笔记&quot;&gt;&lt;/a&gt;阅读笔记&lt;/h2&gt;&lt;h3 id=&quot;生产者消息分区机制原理剖析&quot;&gt;&lt;a href=&quot;#生产者消息分区机制原理剖析&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="中间件" scheme="https://lywlefan.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="读书笔记" scheme="https://lywlefan.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="kafka" scheme="https://lywlefan.github.io/tags/kafka/"/>
    
      <category term="kafka核心技术与实战-胡夕" scheme="https://lywlefan.github.io/tags/kafka%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98-%E8%83%A1%E5%A4%95/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程：CountDownLatch、CyclicBarrier和Semaphore</title>
    <link href="https://lywlefan.github.io/2019/06/27/%E9%AB%98%E5%B9%B6%E5%8F%91/%E5%9F%BA%E7%A1%80/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9ACountDownLatch%E3%80%81CyclicBarrier%E5%92%8CSemaphore/"/>
    <id>https://lywlefan.github.io/2019/06/27/高并发/基础/Java并发编程：CountDownLatch、CyclicBarrier和Semaphore/</id>
    <published>2019-06-26T16:00:00.000Z</published>
    <updated>2019-06-27T09:31:40.159Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>面向对象的语言最好的学习方法就是在实际生活中找一个列子类比。</p></blockquote><ul><li><p>CountDownLatch(计数器)</p></li><li><p>CyclicBarrier(回环栅栏)</p></li><li><p>Semaphore(信号量)</p></li></ul><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>CountDownLatch类位于java.util.concurrent包下，利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。</p><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//count代表计数的个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;; </span><br><span class="line"><span class="comment">//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;; </span><br><span class="line"><span class="comment">//将count值减1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123; &#125;;</span><br></pre></td></tr></table></figure><h4 id="类比理解"><a href="#类比理解" class="headerlink" title="类比理解"></a>类比理解</h4><p>大家在考科目一的时候是如何考的？我们知道车管所的考试机器比考试人数要少很多，假如机器有50个，每次考官让50个人进去，然后再宣布考试开始，其他人继续等待。</p><p>CountDownLatch就可以实现这个效果，我们可以这样做：</p><ul><li><p>CountDownLatch latch=new CountDownLatch(50)</p></li><li><p>进入考场一个学员，我们就latch.countDown()减一</p></li><li><p>到latch为0的时候，考官宣布考试开始，如此而已</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </span><br><span class="line">         <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">          </span><br><span class="line">         <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"执行完毕"</span>);</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;;</span><br><span class="line">         &#125;.start();</span><br><span class="line">          </span><br><span class="line">         <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">                     Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                     System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"执行完毕"</span>);</span><br><span class="line">                     latch.countDown();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;;</span><br><span class="line">         &#125;.start();</span><br><span class="line">          </span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             System.out.println(<span class="string">"等待2个子线程执行完毕..."</span>);</span><br><span class="line">            latch.await();</span><br><span class="line">            System.out.println(<span class="string">"2个子线程已经执行完毕"</span>);</span><br><span class="line">            System.out.println(<span class="string">"继续执行主线程"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">线程Thread-<span class="number">0</span>正在执行</span><br><span class="line">线程Thread-<span class="number">1</span>正在执行</span><br><span class="line">等待<span class="number">2</span>个子线程执行完毕...</span><br><span class="line">线程Thread-<span class="number">0</span>执行完毕</span><br><span class="line">线程Thread-<span class="number">1</span>执行完毕</span><br><span class="line"><span class="number">2</span>个子线程已经执行完毕</span><br><span class="line">继续执行主线程</span><br></pre></td></tr></table></figure><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><h4 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h4><p>字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。我们暂且把这个状态就叫做barrier，当调用await()方法之后，线程就处于barrier了。</p><p>CyclicBarrier类位于java.util.concurrent包下，CyclicBarrier提供2个构造器：</p><h5 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数parties指让多少个线程或者任务等待至barrier状态；参数barrierAction为当这些线程都达到barrier状态时会执行的内容。</p><h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><p>然后CyclicBarrier中最重要的方法就是await方法，它有2个重载版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span><span class="keyword">throws</span> InterruptedException,BrokenBarrierException,TimeoutException </span>&#123; &#125;;</span><br></pre></td></tr></table></figure><p>第一个版本比较常用，用来挂起当前线程，直至所有线程都到达barrier状态再同时执行后续任务；</p><p>第二个版本是让这些线程等待至一定的时间，如果还有线程没有到达barrier状态就直接让到达barrier的线程执行后续任务。</p><h4 id="类比理解-1"><a href="#类比理解-1" class="headerlink" title="类比理解"></a>类比理解</h4><h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><p>假若有若干个线程都要进行写数据操作，并且只有所有线程都完成写数据操作之后，这些线程才能继续做后面的事情，此时就可以利用CyclicBarrier了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">4</span>;</span><br><span class="line">        CyclicBarrier barrier  = <span class="keyword">new</span> CyclicBarrier(N);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">            <span class="keyword">new</span> Writer(barrier).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Writer</span><span class="params">(CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"正在写入数据..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);      <span class="comment">//以睡眠来模拟写入数据操作</span></span><br><span class="line">                System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"写入数据完毕，等待其他线程写入完毕"</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(BrokenBarrierException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"所有线程写入完毕，继续处理其他任务..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">线程Thread-<span class="number">0</span>正在写入数据...</span><br><span class="line">线程Thread-<span class="number">3</span>正在写入数据...</span><br><span class="line">线程Thread-<span class="number">2</span>正在写入数据...</span><br><span class="line">线程Thread-<span class="number">1</span>正在写入数据...</span><br><span class="line">线程Thread-<span class="number">2</span>写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-<span class="number">0</span>写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-<span class="number">3</span>写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-<span class="number">1</span>写入数据完毕，等待其他线程写入完毕</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br></pre></td></tr></table></figure><p>从上面输出结果可以看出，每个写入线程执行完写数据操作之后，就在等待其他线程写入操作完毕。</p><p>当所有线程线程写入操作完毕之后，所有线程就继续进行后续的操作了。</p><h5 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h5><p>如果说想在所有线程写入操作完之后，进行额外的其他操作可以为CyclicBarrier提供Runnable参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">4</span>;</span><br><span class="line">        CyclicBarrier barrier  = <span class="keyword">new</span> CyclicBarrier(N,<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"当前线程"</span>+Thread.currentThread().getName());   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">            <span class="keyword">new</span> Writer(barrier).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Writer</span><span class="params">(CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"正在写入数据..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);      <span class="comment">//以睡眠来模拟写入数据操作</span></span><br><span class="line">                System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"写入数据完毕，等待其他线程写入完毕"</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(BrokenBarrierException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"所有线程写入完毕，继续处理其他任务..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">线程Thread-<span class="number">0</span>正在写入数据...</span><br><span class="line">线程Thread-<span class="number">1</span>正在写入数据...</span><br><span class="line">线程Thread-<span class="number">2</span>正在写入数据...</span><br><span class="line">线程Thread-<span class="number">3</span>正在写入数据...</span><br><span class="line">线程Thread-<span class="number">0</span>写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-<span class="number">1</span>写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-<span class="number">2</span>写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-<span class="number">3</span>写入数据完毕，等待其他线程写入完毕</span><br><span class="line">当前线程Thread-<span class="number">3</span></span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br></pre></td></tr></table></figure><p>从结果可以看出，当四个线程都到达barrier状态后，会从四个线程中选择一个线程去执行Runnable。</p><h5 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h5><p>下面看一下为await指定时间的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">4</span>;</span><br><span class="line">        CyclicBarrier barrier  = <span class="keyword">new</span> CyclicBarrier(N);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;N-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">new</span> Writer(barrier).start();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">new</span> Writer(barrier).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Writer</span><span class="params">(CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"正在写入数据..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);      <span class="comment">//以睡眠来模拟写入数据操作</span></span><br><span class="line">                System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"写入数据完毕，等待其他线程写入完毕"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await(<span class="number">2000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(BrokenBarrierException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"所有线程写入完毕，继续处理其他任务..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">线程Thread-<span class="number">0</span>正在写入数据...</span><br><span class="line">线程Thread-<span class="number">2</span>正在写入数据...</span><br><span class="line">线程Thread-<span class="number">1</span>正在写入数据...</span><br><span class="line">线程Thread-<span class="number">2</span>写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-<span class="number">0</span>写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-<span class="number">1</span>写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-<span class="number">3</span>正在写入数据...</span><br><span class="line">java.util.concurrent.TimeoutException</span><br><span class="line">Thread-<span class="number">1</span>所有线程写入完毕，继续处理其他任务...</span><br><span class="line">Thread-<span class="number">0</span>所有线程写入完毕，继续处理其他任务...</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(Unknown Source)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(Unknown Source)</span><br><span class="line">    at com.cxh.test1.Test$Writer.run(Test.java:<span class="number">58</span>)</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(Unknown Source)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(Unknown Source)</span><br><span class="line">    at com.cxh.test1.Test$Writer.run(Test.java:<span class="number">58</span>)</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(Unknown Source)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(Unknown Source)</span><br><span class="line">    at com.cxh.test1.Test$Writer.run(Test.java:<span class="number">58</span>)</span><br><span class="line">Thread-<span class="number">2</span>所有线程写入完毕，继续处理其他任务...</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">线程Thread-<span class="number">3</span>写入数据完毕，等待其他线程写入完毕</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(Unknown Source)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(Unknown Source)</span><br><span class="line">    at com.cxh.test1.Test$Writer.run(Test.java:<span class="number">58</span>)</span><br><span class="line">Thread-<span class="number">3</span>所有线程写入完毕，继续处理其他任务...</span><br></pre></td></tr></table></figure><p>上面的代码在main方法的for循环中，故意让最后一个线程启动延迟，因为在前面三个线程都达到barrier之后，等待了指定的时间发现第四个线程还没有达到barrier，就抛出异常并继续执行后面的任务。</p><h5 id="例5"><a href="#例5" class="headerlink" title="例5"></a>例5</h5><p>另外CyclicBarrier是可以重用的，看下面这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">4</span>;</span><br><span class="line">        CyclicBarrier barrier  = <span class="keyword">new</span> CyclicBarrier(N);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Writer(barrier).start();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">25000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">"CyclicBarrier重用"</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Writer(barrier).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Writer</span><span class="params">(CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"正在写入数据..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);      <span class="comment">//以睡眠来模拟写入数据操作</span></span><br><span class="line">                System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"写入数据完毕，等待其他线程写入完毕"</span>);</span><br><span class="line">             </span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(BrokenBarrierException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"所有线程写入完毕，继续处理其他任务..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">线程Thread-0正在写入数据...</span><br><span class="line">线程Thread-1正在写入数据...</span><br><span class="line">线程Thread-3正在写入数据...</span><br><span class="line">线程Thread-2正在写入数据...</span><br><span class="line">线程Thread-1写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-3写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-2写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-0写入数据完毕，等待其他线程写入完毕</span><br><span class="line">Thread-0所有线程写入完毕，继续处理其他任务...</span><br><span class="line">Thread-3所有线程写入完毕，继续处理其他任务...</span><br><span class="line">Thread-1所有线程写入完毕，继续处理其他任务...</span><br><span class="line">Thread-2所有线程写入完毕，继续处理其他任务...</span><br><span class="line">CyclicBarrier重用</span><br><span class="line">线程Thread-4正在写入数据...</span><br><span class="line">线程Thread-5正在写入数据...</span><br><span class="line">线程Thread-6正在写入数据...</span><br><span class="line">线程Thread-7正在写入数据...</span><br><span class="line">线程Thread-7写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-5写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-6写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-4写入数据完毕，等待其他线程写入完毕</span><br><span class="line">Thread-4所有线程写入完毕，继续处理其他任务...</span><br><span class="line">Thread-5所有线程写入完毕，继续处理其他任务...</span><br><span class="line">Thread-6所有线程写入完毕，继续处理其他任务...</span><br><span class="line">Thread-7所有线程写入完毕，继续处理其他任务...</span><br></pre></td></tr></table></figure><p>从执行结果可以看出，在初次的4个线程越过barrier状态后，又可以用来进行新一轮的使用。而CountDownLatch无法进行重复使用。</p><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>Semaphore翻译成字面意思为 信号量，Semaphore可以控同时访问的线程个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。</p><h4 id="基础-2"><a href="#基础-2" class="headerlink" title="基础"></a>基础</h4><p>Semaphore类位于java.util.concurrent包下，它提供了2个构造器：</p><h5 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;          <span class="comment">//参数permits表示许可数目，即同时可以允许多少线程进行访问</span></span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;    <span class="comment">//这个多了一个参数fair表示是否是公平的，即等待时间越久的越先获取许可</span></span><br><span class="line">    sync = (fair)? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h5><p>下面说一下Semaphore类中比较重要的几个方法，首先是acquire()、release()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  &#125;     <span class="comment">//获取一个许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;    <span class="comment">//获取permits个许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123; &#125;          <span class="comment">//释放一个许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123; &#125;    <span class="comment">//释放permits个许可</span></span><br></pre></td></tr></table></figure><p>acquire()用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许可。</p><p>release()用来释放许可。注意，在释放许可之前，必须先获获得许可。</p><p>这4个方法都会被阻塞，如果想立即得到执行结果，可以使用下面几个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span> </span>&#123; &#125;;    <span class="comment">//尝试获取一个许可，若获取成功，则立即返回true，若获取失败，则立即返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;;  <span class="comment">//尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123; &#125;; <span class="comment">//尝试获取permits个许可，若获取成功，则立即返回true，若获取失败，则立即返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;; <span class="comment">//尝试获取permits个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false</span></span><br></pre></td></tr></table></figure><p>另外还可以通过availablePermits()方法得到可用的许可数目。</p><h4 id="类比理解-2"><a href="#类比理解-2" class="headerlink" title="类比理解"></a>类比理解</h4><p>下面通过一个例子来看一下Semaphore的具体使用：</p><p>假若一个工厂有5台机器，但是有8个工人，一台机器同时只能被一个工人使用，只有使用完了，其他工人才能继续使用。那么我们就可以通过Semaphore来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">8</span>;            <span class="comment">//工人数</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>); <span class="comment">//机器数目</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">            <span class="keyword">new</span> Worker(i,semaphore).start();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(<span class="keyword">int</span> num,Semaphore semaphore)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">            <span class="keyword">this</span>.semaphore = semaphore;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(<span class="string">"工人"</span>+<span class="keyword">this</span>.num+<span class="string">"占用一个机器在生产..."</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">"工人"</span>+<span class="keyword">this</span>.num+<span class="string">"释放出机器"</span>);</span><br><span class="line">                semaphore.release();           </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">工人<span class="number">0</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">1</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">2</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">4</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">5</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">0</span>释放出机器</span><br><span class="line">工人<span class="number">2</span>释放出机器</span><br><span class="line">工人<span class="number">3</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">7</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">4</span>释放出机器</span><br><span class="line">工人<span class="number">5</span>释放出机器</span><br><span class="line">工人<span class="number">1</span>释放出机器</span><br><span class="line">工人<span class="number">6</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">3</span>释放出机器</span><br><span class="line">工人<span class="number">7</span>释放出机器</span><br><span class="line">工人<span class="number">6</span>释放出机器</span><br></pre></td></tr></table></figure><h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>下面对上面说的三个辅助类进行一个总结：</p><h4 id="1）CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同："><a href="#1）CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：" class="headerlink" title="1）CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同："></a>1）CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：</h4><ul><li><p>CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；</p></li><li><p>而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；</p></li><li><p>另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。</p></li></ul><h4 id="2）Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。"><a href="#2）Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。" class="headerlink" title="2）Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。"></a>2）Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。</h4><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a></p></blockquote><blockquote><p><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><blockquote><p><a href="https://code.google.com/archive/p/disruptor/wikis/BlogsAndArticles.wiki" target="_blank" rel="noopener">【3】disruptor官网</a></p></blockquote><blockquote><p><a href="https://zl198751.iteye.com/blog/1848575" target="_blank" rel="noopener">【4】JAVA CAS原理深度分析</a></p></blockquote><blockquote><p><a href="http://ifeve.com/disruptor/" target="_blank" rel="noopener">【5】并发框架Disruptor译文</a></p></blockquote><blockquote><p><a href="https://blog.52itstyle.vip/archives/2911/" target="_blank" rel="noopener">【6】从构建分布式秒杀系统聊聊Disruptor高性能队列</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;面向对象的语言最好的学习方法就是在实际生活中找一个列子类比。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;CountDownLatch(计数器)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CyclicBarrier(回环栅栏)&lt;/p&gt;
&lt;/
      
    
    </summary>
    
      <category term="高并发" scheme="https://lywlefan.github.io/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="基础" scheme="https://lywlefan.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发" scheme="https://lywlefan.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>架构导航</title>
    <link href="https://lywlefan.github.io/2019/06/26/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E5%AF%BC%E8%88%AA/"/>
    <id>https://lywlefan.github.io/2019/06/26/架构/架构导航/</id>
    <published>2019-06-25T16:00:00.000Z</published>
    <updated>2019-07-26T02:24:31.935Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>万丈高楼平地起的前提是地基好.</p></blockquote><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><h4 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h4><ul><li>Nginx</li><li>Kong</li><li>Zuul</li><li>GateWay</li></ul><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><ul><li>Redis</li><li>MemCached</li><li>OsCache</li><li>EhCache</li></ul><h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><ul><li>ElasticSearch</li><li>Solr</li></ul><h4 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h4><ul><li>Hystrix</li><li>resilience4j</li></ul><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><ul><li>DNS</li><li>F5</li><li>LVS</li><li>Nginx</li><li>OpenResty</li><li><p>HAproxy</p><h4 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h4></li><li><p>Eureka</p></li><li>Zookeeper</li><li>Redis</li><li>Etcd</li><li>Consul</li></ul><h4 id="认证鉴权"><a href="#认证鉴权" class="headerlink" title="认证鉴权"></a>认证鉴权</h4><ul><li>JWT</li></ul><h4 id="消费队列"><a href="#消费队列" class="headerlink" title="消费队列"></a>消费队列</h4><ul><li>RabbitMQ</li><li>ZeroMQ</li><li>Redis</li><li>ActiveMQ</li><li>Kafka</li></ul><h4 id="系统监控"><a href="#系统监控" class="headerlink" title="系统监控"></a>系统监控</h4><ul><li>Grafana</li><li>Prometheus</li><li>Influxdb</li><li>Telegraf</li><li>Lepus</li></ul><h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><ul><li>OSS</li><li>NFS</li><li>FastDFS</li><li>MogileFS</li></ul><h4 id="RPC框架"><a href="#RPC框架" class="headerlink" title="RPC框架"></a>RPC框架</h4><ul><li>Dubbo</li><li>Motan</li><li>Thrift</li><li>grpc</li></ul><h4 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h4><ul><li>Maven</li><li>Gradle</li></ul><h4 id="集成部署"><a href="#集成部署" class="headerlink" title="集成部署"></a>集成部署</h4><ul><li>Docker</li><li>Jenkins</li><li>Git</li><li>Maven</li></ul><h4 id="分布式配置"><a href="#分布式配置" class="headerlink" title="分布式配置"></a>分布式配置</h4><ul><li>Disconf</li><li>Apollo</li><li>Spring Cloud Config</li><li>Diamond</li></ul><h4 id="压测"><a href="#压测" class="headerlink" title="压测"></a>压测</h4><ul><li>LoadRunner</li><li>JMeter</li><li>AB</li><li>webbench</li></ul><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><ul><li>MySql</li><li>Redis</li><li>MongoDB</li><li>PostgreSQL</li><li>Memcache</li><li>HBase</li><li>MPP数据库(Greenplum、TiDB、Postgresql XC、HAWQ等)</li></ul><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><ul><li>专用网络VPC</li><li>弹性公网IP</li><li>CDN</li></ul><h4 id="数据库中间件"><a href="#数据库中间件" class="headerlink" title="数据库中间件"></a>数据库中间件</h4><ul><li>DRDS</li><li>Mycat</li><li>360 Atlas</li><li>Cobar (不维护了)</li></ul><h4 id="分布式框架"><a href="#分布式框架" class="headerlink" title="分布式框架"></a>分布式框架</h4><ul><li>Dubbo</li><li>Motan</li><li>Spring-Could</li></ul><h4 id="分布式任务"><a href="#分布式任务" class="headerlink" title="分布式任务"></a>分布式任务</h4><ul><li>XXL</li><li>JOB</li><li>Elastic-Job</li><li>Saturn</li><li>Quartz</li></ul><h4 id="分布式追踪"><a href="#分布式追踪" class="headerlink" title="分布式追踪"></a>分布式追踪</h4><ul><li>Pinpoint</li><li>CAT</li><li>zipkin</li></ul><h4 id="分布式日志"><a href="#分布式日志" class="headerlink" title="分布式日志"></a>分布式日志</h4><ul><li>elasticsearch</li><li>logstash</li><li>Kibana </li><li>redis</li><li>kafka</li></ul><h4 id="版本发布"><a href="#版本发布" class="headerlink" title="版本发布"></a>版本发布</h4><ul><li>蓝绿部署</li><li>A/B测试</li><li>灰度发布／金丝雀发布</li></ul><h3 id="持续交付"><a href="#持续交付" class="headerlink" title="持续交付"></a>持续交付</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog.52itstyle.vip/usr/uploads/2018/12/547524725.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="链路监控"><a href="#链路监控" class="headerlink" title="链路监控"></a>链路监控</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog.52itstyle.vip/usr/uploads/2018/12/930721230.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="监控架构"><a href="#监控架构" class="headerlink" title="监控架构"></a>监控架构</h3><h4 id="四层监控"><a href="#四层监控" class="headerlink" title="四层监控"></a>四层监控</h4><ul><li>前端监控：IP、PV、运营商、系统、性能、状态码</li><li>业务监控：登录、注册、下单、支付</li><li>应用层监控：service、sql、cache、相应时间</li><li>系统监控：物理机、虚拟机、容器，CPU、内存、IO、硬盘</li><li>基础监控：网络、交换机、路由器</li></ul><h4 id="监控分类"><a href="#监控分类" class="headerlink" title="监控分类"></a>监控分类</h4><ul><li>日志监控</li><li>调用链监控</li><li>告警系统</li><li>Metrics监控</li><li>监控检查</li></ul><p>Docker、Grafana、Prometheus、Telegraf、Influxdb、Lepus、Elasticsearch、Logstash、Kibana、kafka、node插件、dashboards仪表盘、钉钉、邮件、微信。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog.52itstyle.vip/usr/uploads/2017/11/3315159539.png" alt title>                </div>                <div class="image-caption"></div>            </figure><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog.52itstyle.vip/usr/uploads/2017/11/603463236.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="服务框架和治理"><a href="#服务框架和治理" class="headerlink" title="服务框架和治理"></a>服务框架和治理</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog.52itstyle.vip/usr/uploads/2018/12/1389990329.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="架构必备"><a href="#架构必备" class="headerlink" title="架构必备"></a>架构必备</h3><ul><li>负载均衡（负载均衡算法）</li><li>反向代理</li><li>服务隔离</li><li>服务限流</li><li>服务降级（自动优雅降级）</li><li>失效转移</li><li>超时重试（代理超时、容器超时、前端超时、中间件超时、数据库超时、NoSql超时）</li><li>回滚机制（上线回滚、数据库版本回滚、事务回滚）</li></ul><h4 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h4><ul><li>应用缓存</li><li>HTTP缓存</li><li>多级缓存</li><li>分布式缓存</li><li>连接池</li><li>异步并发</li></ul><h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><ul><li>二阶段提交(强一致)</li><li>三阶段提交(强一致)</li><li>消息中间件(最终一致性)，推荐阿里的RocketMQ</li></ul><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><ul><li>任务队列</li><li>消息队列</li><li>请求队列</li></ul><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><ul><li>单体垂直扩容</li><li>单体水平扩容</li><li>应用拆分</li><li>数据库拆分</li><li>数据库分库分表</li><li>数据异构</li><li>分布式任务</li></ul><h4 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h4><ul><li>SQL注入</li><li>XSS攻击</li><li>CSRF攻击</li><li>拒绝服务（DoS，Denial　of　Service）攻击</li></ul><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a></p></blockquote><blockquote><p><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><blockquote><p><a href="https://www.cnblogs.com/netfocus/archive/2012/02/12/2347919.html" target="_blank" rel="noopener">【3】LMAX架构简介·汤雪华</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;万丈高楼平地起的前提是地基好.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;技术选型&quot;&gt;&lt;a href=&quot;#技术选型&quot; class=&quot;headerlink&quot; title=&quot;技术选型&quot;&gt;&lt;/a&gt;技术选型&lt;/h3&gt;&lt;h4 id=&quot;网关&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="导航" scheme="https://lywlefan.github.io/categories/%E5%AF%BC%E8%88%AA/"/>
    
    
      <category term="架构导航" scheme="https://lywlefan.github.io/tags/%E6%9E%B6%E6%9E%84%E5%AF%BC%E8%88%AA/"/>
    
      <category term="架构" scheme="https://lywlefan.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>撮合系统设计</title>
    <link href="https://lywlefan.github.io/2019/06/26/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF/%E4%BA%A4%E6%98%93%E6%89%80/%E6%92%AE%E5%90%88%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    <id>https://lywlefan.github.io/2019/06/26/业务场景/交易所/撮合系统设计/</id>
    <published>2019-06-25T16:00:00.000Z</published>
    <updated>2019-06-27T11:35:30.508Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要：撮合技术主要是从数据库撮合技术向内存撮合技术发展，这是因为数据库撮合技术越来越无法满足金融交易对于高可靠性、高性能、强安全性、可扩展性以及易维护性的需求。本文来自中生代技术群的34期分享，将和大家讨论基于内存的撮合的系统设计。李伟山，毕业于国防科技大学，曾就职于华为、阿里巴巴，目前人江苏大圆银泰技术总监，对于高并发、大数据架构设计有深刻的了解。1.概述</p></blockquote><p>随着信息技术的日新月异和金融业务的快速发展,金融交易领域对于核心技术的求也在不断增强,国内外金融交易模式已经从传统的人工叫价的方式变成了由高度电子化交易系统撮合订单的方式。传统的金融交易主要发生在有型金融市场中,金融交易的买卖双方通过叫价进行价格协商等方式最终达成一致,从而形成一笔交易,同时按照交易订单到指定的交割地点进行实物交割的交易方式。由于交易的整个过程主要依靠人来执行,传统的金融交易缺点主要有:效率低速度慢、交易时间限制大、交易空间限制大、交易成本非常髙、容易有内幕交易、交易扩展性差、交易容易出错、资金安全性差等一系列的缺点。</p><p>时代不断变迁,金融交易通过与计算机技术的结合,走上了电子化交易的道路,通过将金融交易市场电子化,电子交易不仅消除了传统金融交易的种种弊端,也促进了现代金融业的快速发展。电子金融交易的主要优点有:交易效率高速度快、交易透明度高、交易成本低、系统安全性高、不受交易时间的限制、不受交易空间的限制、可以进行多方位的扩展、大力推动现代金融业发展等。</p><p>因此现在电子交易己经成为了金融交易市场的主流交易方式。随着交易人数、笔数的不断增加,系统承受着越来越大的压力,如果在交易时间内系统发生故障,造成的损失往往不可估量。因此发出更可靠更高效的电子交易系统己经成为了金融交易领域的当务之急。</p><p>撮合交易在金融交易系统中扮演者非常重要的角色。了解撮合交易的本质以及业务对于设计撮合系统至关重要。江苏大泰技术有限公司，致力于互联网金融平台的开发，目前已经在运行的平台有大宗交易、普洱茶交易系统，后期会发布连续现货和发售交易平台，接下来为大家介绍基于内存的撮合交易系统设计概要。</p><h3 id="2-系统总体设计"><a href="#2-系统总体设计" class="headerlink" title="2.系统总体设计"></a>2.系统总体设计</h3><h4 id="2-1-层次设计"><a href="#2-1-层次设计" class="headerlink" title="2.1 层次设计"></a>2.1 层次设计</h4><p>一般而言,金融交易撮合系统中包括以下几个核心模块:</p><p>用户:终端用户委托报价与数量,生成订单发送至交易平台。</p><p>网关:负责收集用户订单,并将其派发给撮合引擎。</p><p>撮合引擎:交易系统中的核心部分,用于接收订单并根据业务逻辑实现订单   撮合同时生成交易记录,随后给予用户交易结果反馈。</p><p>数据库:用来存放交易过程中的订单和交易记录,实现数据持久化。</p><p>此外,本文根据不同类型的金融交易展品将撮合模块划分为若干业务分区,每个分区独立进行撮合,彼此不受影响。对于单个业务分区而言,撮合系统整体架构设计如图1.2所示,本章的总体设计围绕撮合引擎层以及撮合引擎与网关层、数据库层的交互方式的总体设计。</p><h4 id="2-2-撮合交易算法"><a href="#2-2-撮合交易算法" class="headerlink" title="2.2 撮合交易算法"></a>2.2 撮合交易算法</h4><p>如图2.1所示,撮合引擎的核心业务模块就是撮合交易算法撮合交易算法的任务一方面是完成对客户所下订单进行公平合理的排列和撮合功能,也要保证撮合算法的公平性、高效性以及扩展性等。由于不同金融交易系统的撮合业务各有不同,因此本节对通用的撮合交易算法进行概括性描述。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://mmbiz.qpic.cn/mmbiz_png/8jNAbhjXPiaPSXURRrM6z0TmxnwYWDcjPmgBLFM6paMJCDPghmFZic61JrBoeV2SlGd9bXoqDlAcEHfuaLOYmLBw/0?wx_fmt=png" alt title>                </div>                <div class="image-caption"></div>            </figure><h5 id="2-2-1订单队列"><a href="#2-2-1订单队列" class="headerlink" title="2.2.1订单队列"></a>2.2.1订单队列</h5><p>撮合交易的重要组成部分就是买卖订单,通过对买卖订单进行撮合最后形成交易记录。所以对无法立刻完成撮合的订单,需要有买入队列和卖出队列保存订单。队列按照<strong>“价格优先、同价格下时间优先”</strong>的原则。买入队列按照委托价格从低到高的顺序,卖出队列则按照委托价格从低到高的顺序排列,如图</p><h5 id="2-2-2撮合顺序"><a href="#2-2-2撮合顺序" class="headerlink" title="2.2.2撮合顺序"></a>2.2.2撮合顺序</h5><p>撮合引擎接收到新的买入订单,则会到卖出队列的头部查找是否存在符合价格规则的卖出订单,如果存在卖出价格小于或等于买入价格的订单,则从队列中取出此订单并撮合成一笔交易;如果卖出队列为空或队列头部不满足价格关系,则将买入订单插入买入队列中,由于买入队列是按照价格与时间先后进行排序,所以新插入的订单会经过一次排序插入到买入队列的相应位置。</p><p>相同的,当撮合引擎接收到新的卖出订单,则会到买入队列的头部査找是否存在符合价格规则的买入订单,如果存在买入价格大于或等于卖出价格的订单,则从订单队列中取出此订单并撮合成一笔交易;如果买入队列为空或队列头部不满足价格关系,则将卖出订单插入到卖出队列中,由于卖出队列也是按照价格与时间先后进行排序的所以新插入的订单会经过一次排序插入到卖出队列的相应位置[23]。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://mmbiz.qpic.cn/mmbiz_png/8jNAbhjXPiaPSXURRrM6z0TmxnwYWDcjPKy0IicpPXvp6gNznmrfAWnLOZNjBRbcSOZwSQ8zsFrx6D8nbT15c72A/0?wx_fmt=png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>结合买卖订单情况,撮合算法流程如图2.3所示。从图2.3所示的撮合顺序可知,买卖队列的有序性是保证撮合顺序的确定性的基础,并且撮合过程中每笔订单都可以撮合出当前最优交易。</p><h4 id="2-3-内存撮合"><a href="#2-3-内存撮合" class="headerlink" title="2.3 内存撮合"></a>2.3 内存撮合</h4><p>当前的数据库撮合技术的性能低下的原因在于过多与数据库交互,使得I/O很多,系统整体处理速度同时受数据库事务逻辑约束。</p><p>本文釆用内存撮合技术,通过最大程度去除与数据库的交互过程,将整个错和逻辑放在内存中进行(如图2.4所示)。因此比数据库撮合技术少了许多I/O交S间,在性能上可以大幅提升撮合速度;例是内存撮合的弊端就是由于内存的易失性,.?服务器出现故障停机时,所有的交易数据将会丢失,系统的可靠性以及一致性都相应人幅降低。因此本文在提高内存撮合技术可靠性的方面采用丫多机热备份及分布式一致性技术作为补充,从而获得内存撮合技术的高性能以及数据库撮合技术的数据持久性。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://mmbiz.qpic.cn/mmbiz_png/8jNAbhjXPiaPSXURRrM6z0TmxnwYWDcjP15dWgFNVGIvpBEhNxLYcmFheu1UVibmuDY4OSFicicEHOAfdVELHfqt0g/0?wx_fmt=png" alt title>                </div>                <div class="image-caption"></div>            </figure>  <h4 id="2-4-多机热备份"><a href="#2-4-多机热备份" class="headerlink" title="2.4 多机热备份"></a>2.4 多机热备份</h4><p>由于内存撮合技术在撮合引攀出现异常时的可靠性和一致性非常差,而金融交场系统因为其业务特性,对服务小断以及数据丢失的容忍度非常低,提高容错性,一般多采取的是多机热条份技术。本文采用多机热备份技术,将一组撮合引樂部署成互为备份的撮合引擎集群,并且在同一时间内只有一台撮合引擎提供服务。当-其中运行这的一台撮六引擎出现故障无法继续正常工作 ,撮合引擎集群会迅速检测到这个故障,并选举出一个备份撮合引擎接管故障撮合引舉的任务从而保证整个撮合系统的正常运行多机热备份技术的本质就足针对服务器临时故障所做的一种备份技术,本文迎过采用多机热备份技术,来避免长 间的撮合服务中断,保证撮合系统长期、可靠的服务。如阁2.5所示,通过将多台撮合引擎进行热格份,从而保证在撮合引擎出现故障时,会在可以接受的时间内完成主机和备机之间的切换,由备份机提供无缝连续服务。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://mmbiz.qpic.cn/mmbiz_png/8jNAbhjXPiaPSXURRrM6z0TmxnwYWDcjPU3Awr4cSVaYvEHtZat9Yib4z9v8HI92oCoJpGic0X1Isgd04gvIomKbw/0?wx_fmt=png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>通过釆用多机热备份技术,降低了单一内存撮合引擎故障时系统不可用的问题,但仍旧无法提供100%的可用性,因为当出现大规模服务器集群故障时,仍旧存在服务不可用的可能性,但在实际生产环境中,三台互为备份的服务器就可以提供较高的可以用于生产环境的可靠性。</p><h4 id="2-5-内存状态机复制"><a href="#2-5-内存状态机复制" class="headerlink" title="2.5 内存状态机复制"></a>2.5 内存状态机复制</h4><p>由于多机热备份技术引入了多台互为热备份的撮合引擎,根据撮合系统设计以及撮合逻辑要求,需要保证服务器之间的数据一致,这就需要保证多服务器之间一致性,这也是本文难点之一。</p><p>本文提出一种内存状态机复制方案,即将撮合算法视作一个确定性状态机,将其复制多份并部署到撮合系统中的多台撮合引擎中。每个撮合引擎副本从相同的初始状态开始运行,当撮合系统收到网关发来的订单时,系统中的每个撮合引擎都会撮合这个订单,并依次产生交易记录,同时更新确定性撮合算法状态机的独立状态。通过这样的方式,当撮合系统正常运转时,每个撮合引擎副本都会具有相同的结果状态;当撮合系统出现故障或异常时,撮合引擎就会出现状态的不一致情况,换句话说一旦撮合系统的结果或状态出现了不一致的情况就可以断定系统出现了异常。</p><h5 id="2-5-1关键技术点"><a href="#2-5-1关键技术点" class="headerlink" title="2.5.1关键技术点"></a>2.5.1关键技术点</h5><p>本文为了实现这样的内存状态机复制撮合系统,将撮合系统划分为以下组成关键技术点：</p><ul><li><p>将确定性撮合算法状态机服务部署到多个独立撮合引擎</p></li><li><p>接收网关订单,并作为确定性撮合算法状态机的输入</p></li><li><p>根据撮合算法需求,选择一种订单排序方式</p></li><li><p>每个撮合引擎对按照排序方式排序过的订单进行撮合</p></li><li><p>将确定性撮合算法状态机输出的交易记录作为给用户或数据库的响应</p></li><li><p>监控撮合引擎副本的状态或输出的差别</p></li></ul><h5 id="2-5-2实现方案"><a href="#2-5-2实现方案" class="headerlink" title="2.5.2实现方案"></a>2.5.2实现方案</h5><p>为实现基于内存状态机复制的撮合系统,本文主要通过以下方案实现状态机复制的关键技术点:</p><ul><li><p>采用原子多播解决撮合引擎订单的可靠多播与全局有序性</p></li><li><p>采用基于无锁订单队列的流水线撮合技术提供快速的订单撮合</p></li><li><p>采用异步一致性持久化技术实现与数据库的交互</p></li><li><p>采用失效备援技术对撮合引擎集群进行状态监控并保证系统的容错能;</p></li><li><p>采用进度追赶技术解决将故障撮合引擎的恢复或新撮合引擎的加入</p></li></ul><h4 id="2-6-系统架构"><a href="#2-6-系统架构" class="headerlink" title="2.6 系统架构"></a>2.6 系统架构</h4><h5 id="2-6-1系统硬件体系架构"><a href="#2-6-1系统硬件体系架构" class="headerlink" title="2.6.1系统硬件体系架构"></a>2.6.1系统硬件体系架构</h5><p>典型的高可靠高性能撮合模型硬件架构如图2.6所示,系统由n台客户端、N台网关、X个产品集群(每个集群由2至3台撮合引擎组成,负责响应产品订单的处理)、一个交易记录数据库和可选的监视系统组成。其中客户端连接到相应网关,网关负责接收客户端提交的订单,并根据订单相关的金融产品类别,转发到相对应的产品集群。产品集群中所有撮合引擎均接收网关发送的订单,根据撮合业务规则,将其撮合并回馈消息给网关和客户端,同时将撮合生成的交易记录持久化到交易记录数据库中。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://mmbiz.qpic.cn/mmbiz_png/8jNAbhjXPiaPSXURRrM6z0TmxnwYWDcjPGBaCyygk3QxLDxS31JA12tPUu52WouXgpI75hOJMzqElCBNDL1PdaA/0?wx_fmt=png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>通过对产品集群进行扩充,增加撮合引擎数量,可以增强产品集群的可靠性。将不同金融产品转发到不同的撮合产品集群中可以实现多产品高效并行撮合。</p><h5 id="2-6-2-系统软件体系架构"><a href="#2-6-2-系统软件体系架构" class="headerlink" title="2.6.2 系统软件体系架构"></a>2.6.2 系统软件体系架构</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://mmbiz.qpic.cn/mmbiz_png/8jNAbhjXPiaPSXURRrM6z0TmxnwYWDcjPB9aicOqu9cpuS1bPrLyO1BGljN70CMT08lLia3Kl4Eu4QWJfFbTa7Ypg/0?wx_fmt=png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>如图2.7所示,高可靠高性能撮合模型主要由表示层、转发层、业务层和数据层组成。其核心部分业务层主要由撮合引擎集群组成,每个撮合引擎采用原子多播将订单定序后进行撮合处理,并结合无锁订单队列实现高效流水线撮合,最后结果写入本地日志。整个业务流程由消息传递总线将消息反馈给转发层。转发层则根据产品转发规则将订单转发给相应撮合引擎集群;而撮合引擎将本地日志中的交易记录读取到异步持久化代理进程中,并进而与数据层的异步持久化写入进程通信,并最终持久化到数据库中。本地日志增强了撮合系统数据的可靠性,在出现故障后,数据仍就可以从本地日志中恢复;而界步的持久化机制则提高了数据的持久化吞吐率。</p><h5 id="2-6-3撮合引擎架构"><a href="#2-6-3撮合引擎架构" class="headerlink" title="2.6.3撮合引擎架构"></a>2.6.3撮合引擎架构</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://mmbiz.qpic.cn/mmbiz_png/8jNAbhjXPiaPSXURRrM6z0TmxnwYWDcjPa1EESIvmatQ9NQh6R07tg5shjTFzMNfsl0Sx9fCGpQ7q6SajBNRtLg/0?wx_fmt=png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>为了使系统可扩展易维护,撮合引擎由原子多播订单定序模块、撮合处理器模块、交易记录日志模块和内存数据组成,每个模块根据功能业务划分。其中各部分主要有以下功能:交易订单接收线程:负责从网关接收订单,并完成原子多播定序流程。交易订单发送线程:将定序完成的订单发送给相关撮合业务线程。交易信息发送线程:将订单交易状态反馈给网关。外围业务逻辑线程:进行撮合数据的准备处理,更新内存订单数据。撮合业务逻辑线程:根据确定性撮合算法撮合接收的订单。交易行情发布线程:处理内存行情信息并发布给网关。同步日志写线程:将订单撮合产生的交易记录同步持久化到本地日志文件。异步持久化代理进程:异步将日志文件中的数据读取并持久化到数据库。订单信息:存储订单的相关价格、数量、用户、限制、类型和状态等信息交易行情信息:撮合交易过程中的交易行情信息。</p><h5 id="2-6-4系统接口"><a href="#2-6-4系统接口" class="headerlink" title="2.6.4系统接口"></a>2.6.4系统接口</h5><p>撮合系统主要为使用者提供订单的下单和查询服务、交易行情的实时反馈功能以及系统状态的监控查看服务。因此系统需要实现预留的接口主要包括:下单接口、订单查询接口、行情查询接口、系统控制接口和运行状态查询接口等。</p><h4 id="2-7-小节"><a href="#2-7-小节" class="headerlink" title="2.7 小节"></a>2.7 小节</h4><p>从总体设计入手,将撮合业务处理从数据库迁移至内存中,同时釆用多机热备份技术解决内存撮合技术的易失性问题,最终提出内存状态机复制方案作为高可靠髙性能撮合系统的实现路线。撮合技术的具体实现将在下一章进行详细论述。</p><p>###FAQ</p><p>Q：热备的机制上。多个机器内存上的状态如何保证强一致性的？</p><p>A： 是热备机器都是无状态，普洱茶按照不同品种产生不同撮合序列，只要保证单品种有序，其他撮合机和本机没有关系。</p><p>Q: 如果新加入一台撮合引擎，怎么判断所有的撮合数据都同步到了这台新的引擎上？</p><p>A: 委托单先要写raid文件系统，新增撮合引擎，也可以拿到数据。</p><p>Q: 根据你的描述，一个集群中为了判断撮合引擎是否有故障，至少应该有3台撮合引擎吧?</p><p>A:  zk来管理，并且有风控进程监控撮合进度。</p><p>Q: 内存状态机的复制究竟是结果还是数据？</p><p>A: 数据，就是把处理到某个状态的数据复制出来。</p><p>Q: 如果只有两台撮合引擎，如果对一个买入订单，发现结果不一致，如何判断是哪一台的故障？</p><p>A: 撮合只有一台进行撮合，撮合结束才回写数据库产生行情和分发个个终端，用户就可以看到自己委托单是否成交。</p><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a><br><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a><br><a href="https://toutiao.io/posts/q5bov1/preview" target="_blank" rel="noopener">【3】撮合系统· 李伟山</a><br><a href="https://www.itcodemonkey.com/article/11017.html" target="_blank" rel="noopener">【4】撮合系统·技术方舟</a><br><a href="https://zhuanlan.zhihu.com/p/67311339" target="_blank" rel="noopener">【5】交易所视角下的套利指令撮合机制</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;摘要：撮合技术主要是从数据库撮合技术向内存撮合技术发展，这是因为数据库撮合技术越来越无法满足金融交易对于高可靠性、高性能、强安全性、可扩展性以及易维护性的需求。本文来自中生代技术群的34期分享，将和大家讨论基于内存的撮合的系统设计。李伟山，毕业于国
      
    
    </summary>
    
      <category term="业务场景" scheme="https://lywlefan.github.io/categories/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF/"/>
    
    
      <category term="交易所" scheme="https://lywlefan.github.io/tags/%E4%BA%A4%E6%98%93%E6%89%80/"/>
    
      <category term="撮合" scheme="https://lywlefan.github.io/tags/%E6%92%AE%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>2.disruptor应用</title>
    <link href="https://lywlefan.github.io/2019/06/26/%E9%AB%98%E5%B9%B6%E5%8F%91/disruptor%E5%AD%A6%E4%B9%A0/2.disruptor%E5%BA%94%E7%94%A8/"/>
    <id>https://lywlefan.github.io/2019/06/26/高并发/disruptor学习/2.disruptor应用/</id>
    <published>2019-06-25T16:00:00.000Z</published>
    <updated>2019-06-26T10:09:12.170Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>disruptor号称能够在一个线程里每秒处理6百万订单,业务逻辑处理器完全是运行在内存中，使用事件源驱动方式。</p></blockquote><h3 id="本节导航"><a href="#本节导航" class="headerlink" title="本节导航"></a>本节导航</h3><ul><li><p>Disruptor核心链路场景应用讲解</p></li><li><p>并行计算- 串行操作</p></li><li><p>并行计算- 并行操作</p></li><li><p>并行计算- 多遍形高端操作</p></li><li><p>并行计算- 多生产者消费模型</p></li><li><p>并行计算- 多消费者消费模型</p></li></ul><h3 id="Disruptor核心链路场景应用讲解"><a href="#Disruptor核心链路场景应用讲解" class="headerlink" title="Disruptor核心链路场景应用讲解"></a>Disruptor核心链路场景应用讲解</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><h5 id="啥是核心链路"><a href="#啥是核心链路" class="headerlink" title="啥是核心链路?"></a>啥是核心链路?</h5><p>就拿京东来说,下单支付就是核心链路,物流也是核心链路.</p><h5 id="核心链路特点"><a href="#核心链路特点" class="headerlink" title="核心链路特点"></a>核心链路特点</h5><ul><li><p>代码复杂</p></li><li><p>业务逻辑复杂</p></li></ul><h5 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h5><ul><li><p>传统完全解耦的方式</p></li><li><p>模板模式</p></li></ul><h5 id="使用框架"><a href="#使用框架" class="headerlink" title="使用框架"></a>使用框架</h5><ul><li><p>有限状态机框架：Spring-StateMachine</p></li><li><p>使用Disruptor</p></li></ul><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a></p></blockquote><blockquote><p><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><blockquote><p><a href="https://code.google.com/archive/p/disruptor/wikis/BlogsAndArticles.wiki" target="_blank" rel="noopener">【3】disruptor官网</a></p></blockquote><blockquote><p><a href="https://zl198751.iteye.com/blog/1848575" target="_blank" rel="noopener">【4】JAVA CAS原理深度分析</a></p></blockquote><blockquote><p><a href="http://ifeve.com/disruptor/" target="_blank" rel="noopener">【5】并发框架Disruptor译文</a></p></blockquote><blockquote><p><a href="https://blog.52itstyle.vip/archives/2911/" target="_blank" rel="noopener">【6】从构建分布式秒杀系统聊聊Disruptor高性能队列</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;disruptor号称能够在一个线程里每秒处理6百万订单,业务逻辑处理器完全是运行在内存中，使用事件源驱动方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;本节导航&quot;&gt;&lt;a href=&quot;#本节导航&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="高并发" scheme="https://lywlefan.github.io/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://lywlefan.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="disruptor" scheme="https://lywlefan.github.io/tags/disruptor/"/>
    
  </entry>
  
</feed>
