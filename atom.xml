<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>share猿</title>
  
  <subtitle>https://lywlefan.github.io/</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lywlefan.github.io/"/>
  <updated>2019-10-24T10:31:25.136Z</updated>
  <id>https://lywlefan.github.io/</id>
  
  <author>
    <name>share猿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue基础</title>
    <link href="https://lywlefan.github.io/2019/10/24/%E5%89%8D%E7%AB%AF/vue/vue%E5%9F%BA%E7%A1%80/"/>
    <id>https://lywlefan.github.io/2019/10/24/前端/vue/vue基础/</id>
    <published>2019-10-23T16:00:00.000Z</published>
    <updated>2019-10-24T10:31:25.136Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="什么是Vue？？"><a href="#什么是Vue？？" class="headerlink" title="什么是Vue？？"></a>什么是Vue？？</h4><p>开发web界面的前端库</p><h4 id="vue特性"><a href="#vue特性" class="headerlink" title="vue特性"></a>vue特性</h4><ul><li>具有<strong>响应式编程</strong>（保持状态和视图同步）</li><li>组件化</li><li>轻量级</li><li>易上手</li></ul><p><strong>MVC</strong>：MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。</p><p><strong>MVP</strong>：MVP是Model-View-Presenter的简称，即模型-视图-表现层的缩写。MVP是由MVC模式进化而来的，MVP改进了MVC中的控制器过于臃肿的问题。</p><table><thead><tr><th></th><th>MVC</th><th></th><th>MVP</th></tr></thead><tbody><tr><td>Model</td><td>业务逻辑和实体模型</td><td>Model</td><td>业务逻辑和实体模型</td></tr><tr><td>View</td><td>对应布局文件</td><td>View</td><td>对应Activity，负责view的绘制与用户交互</td></tr><tr><td>Controller</td><td>对应Activity等</td><td>Presenter</td><td>负责完成view与model的交互，处理程序逻辑</td></tr></tbody></table><p><strong>MVVM</strong>：</p><p><strong>MVM</strong>：</p><h4 id="理念"><a href="#理念" class="headerlink" title="理念"></a>理念</h4><p>一切都是组件！</p><h4 id="为什么用vue"><a href="#为什么用vue" class="headerlink" title="为什么用vue"></a>为什么用vue</h4><ul><li>轻量，易上手</li><li>阿里支持，开源weex</li><li>抛弃IE8支持</li><li>Android支持到4.2+</li><li>ios支持到7+</li><li>适用前后端分离项目</li><li>压缩后仅有18KB，不依赖其他</li></ul><h3 id="前端框架基本逻辑"><a href="#前端框架基本逻辑" class="headerlink" title="前端框架基本逻辑"></a>前端框架基本逻辑</h3><ul><li>模板渲染</li><li>事件绑定</li><li>用户交互处理</li></ul><h3 id="实例及选项"><a href="#实例及选项" class="headerlink" title="实例及选项"></a>实例及选项</h3><p>一个Vue实例相当于一个MVVM模式中的ViewModel，实例化的时候传入一个<strong>选项对象</strong>（包括数据、模板、挂载元素、方法、生命周期钩子等）</p><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><h5 id="el"><a href="#el" class="headerlink" title="el"></a>el</h5><p><strong>为实例提供挂载元素</strong>，类型为字符串。在初始化指定el，实例将立即进入编译过程。</p><h5 id="template"><a href="#template" class="headerlink" title="template"></a>template</h5><p>配置挂载 </p><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;h4 id
      
    
    </summary>
    
      <category term="前端" scheme="https://lywlefan.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="vue" scheme="https://lywlefan.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>jpa原生sql分页</title>
    <link href="https://lywlefan.github.io/2019/10/18/%E5%90%8E%E7%AB%AF/%E6%A1%86%E6%9E%B6/java/hibernate/jpa%E5%8E%9F%E7%94%9Fsql%E5%88%86%E9%A1%B5/"/>
    <id>https://lywlefan.github.io/2019/10/18/后端/框架/java/hibernate/jpa原生sql分页/</id>
    <published>2019-10-17T16:00:00.000Z</published>
    <updated>2019-10-18T03:59:52.031Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>其实需求很简单,就是通过查询一个表得到数据列表,然后再对这个数据列表进行分页,自定义sql如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">t.order_number <span class="keyword">AS</span> orderNumber,</span><br><span class="line"><span class="keyword">sum</span>(t.coupon_amt) <span class="keyword">AS</span> <span class="keyword">sum</span>,</span><br><span class="line"><span class="keyword">sum</span>(</span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> t.use_state = <span class="string">'NOT_USE'</span> <span class="keyword">THEN</span></span><br><span class="line">t.coupon_amt</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">) <span class="keyword">AS</span> balance</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">open_oil_coupon t</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">t.user_id = ? <span class="number">1</span></span><br><span class="line"><span class="keyword">AND</span> t.app_id = ? <span class="number">2</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">t.order_id</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">balance = <span class="number">0</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">t.created_at <span class="keyword">DESC</span>,</span><br><span class="line">balance <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="方法一-通过jpa的原生sql分页查询"><a href="#方法一-通过jpa的原生sql分页查询" class="headerlink" title="方法一:通过jpa的原生sql分页查询"></a>方法一:通过jpa的原生sql分页查询</h3><h4 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OilCouponRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">OilCoupon</span>,<span class="title">Long</span>&gt;,<span class="title">JpaSpecificationExecutor</span>&lt;<span class="title">OilCoupon</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Query</span>(value = <span class="string">"SELECT t.order_number AS orderNumber, sum(t.coupon_amt) AS sum, sum(CASE WHEN t.use_state = 'NOT_USE' THEN t.coupon_amt ELSE 0 END ) AS balance FROM open_oil_coupon t WHERE t.user_id = ?1 AND t.app_id = ?2 GROUP BY t.order_number HAVING balance &gt; 0"</span>,nativeQuery = <span class="keyword">true</span>,</span><br><span class="line">            countQuery = <span class="string">"SELECT count(*) FROM (SELECT t.order_number AS orderNumber, sum(t.coupon_amt) AS sum, sum(CASE WHEN t.use_state = 'NOT_USE' THEN t.coupon_amt ELSE 0 END ) AS balance FROM open_oil_coupon t WHERE t.user_id = ?1 AND t.app_id = ?2 GROUP BY t.order_number HAVING balance = 0) T"</span>)</span><br><span class="line"><span class="function">Page&lt;Map&gt; <span class="title">getAllCouponsUsed</span><span class="params">(Long userId, String appId, Pageable pageable)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>:countQuery如果带有having等语句最好的办法是把@Query的sql复制一份把他查出来的结果当成表,然后对其进行count(*)查询。</p><h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> OpenPage&lt;CouponsVo&gt; <span class="title">getCouponsByOrderId</span><span class="params">(String appId, Long userId, CouponPageVo couponPageVo)</span></span>&#123;</span><br><span class="line">       Pageable pageable = <span class="keyword">new</span> PageRequest(couponPageVo.getPageNum(), couponPageVo.getPageSize(), Sort.Direction.DESC, <span class="string">"order_number"</span>);</span><br><span class="line">       OpenPage&lt;CouponsVo&gt; pages = <span class="keyword">new</span> OpenPage();</span><br><span class="line">       Page page2 = oilCouponRepository.getAllCouponsUsed(userId,appId,pageable);</span><br><span class="line">       List&lt;CouponsVo&gt; couponsVos = JSON.parseArray(JSON.toJSONString(page2.getContent()),CouponsVo.class);</span><br><span class="line">       pages.setContent(couponsVos);</span><br><span class="line">       pages.setPageNum(page2.getNumber());</span><br><span class="line">       pages.setPageSize(page2.getSize());</span><br><span class="line">       pages.setTotalElements(page2.getTotalElements());</span><br><span class="line">       pages.setTotalPages(page2.getTotalPages());</span><br><span class="line">       <span class="keyword">return</span> pages;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>:排序的字段要用跟数据库里面一样的字段名称</p><h3 id="方法二-通过jdbc原生sql拼接的方法进行分页"><a href="#方法二-通过jdbc原生sql拼接的方法进行分页" class="headerlink" title="方法二:通过jdbc原生sql拼接的方法进行分页"></a>方法二:通过jdbc原生sql拼接的方法进行分页</h3><h4 id="抽象的jdbc分页类型"><a href="#抽象的jdbc分页类型" class="headerlink" title="抽象的jdbc分页类型"></a>抽象的jdbc分页类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.winstar.config;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.winstar.util.OpenPage;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.Assert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.EntityManager;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包:com.winstar.manager.repository</span></span><br><span class="line"><span class="comment"> * 类描述: jdbc父Dao封装</span></span><br><span class="line"><span class="comment"> * 创建人:shareyuan</span></span><br><span class="line"><span class="comment"> * 创建时间:2018/12/26 11:52</span></span><br><span class="line"><span class="comment"> * 版本:v1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractServerRepository</span>&lt;<span class="title">T</span>, <span class="title">PK</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">protected</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    EntityManager entityManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;T&gt; entityClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EMPYT_STR = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; fieldClassNames = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractServerRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.entityClass = (Class&lt;T&gt;) ((ParameterizedType) getClass()</span><br><span class="line">                .getGenericSuperclass()).getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">this</span>.initEntityFieldsClassNames();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initEntityFieldsClassNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Field[] fields = <span class="keyword">this</span>.entityClass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">this</span>.fieldClassNames = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            fieldClassNames.put(field.getName(), field.getType().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Description: 根据SQL查询数据并返回一个List&lt;Map&lt;String,Object&gt;&gt;,将其封装为 Page</span></span><br><span class="line"><span class="comment">    * Param: sql,pageNo,pageSize,values</span></span><br><span class="line"><span class="comment">    * return: Page</span></span><br><span class="line"><span class="comment">    * Author: shareyuan</span></span><br><span class="line"><span class="comment">    * Date: 2018/12/27</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OpenPage <span class="title">findPageBySqlForListMap</span><span class="params">(<span class="keyword">final</span> String sql, <span class="keyword">final</span> <span class="keyword">int</span> pageNo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">final</span> <span class="keyword">int</span> pageSize, <span class="keyword">final</span> Object... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String countSql = <span class="string">"SELECT count(1) FROM ("</span>+ removeOrders(sql) + <span class="string">") T"</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> totalCount = <span class="keyword">this</span>.getCountBySql(countSql, values);</span><br><span class="line">        <span class="keyword">if</span> (totalCount &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> OpenPage();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> startIndex = OpenPage.getStartOfPage(pageNo, pageSize);</span><br><span class="line">            <span class="keyword">final</span> String querySql =getString( sql,<span class="string">" limit "</span>, startIndex,<span class="string">","</span>, pageSize);</span><br><span class="line">            List&lt;Map&lt;String,Object&gt;&gt; list = <span class="keyword">this</span>.jdbcTemplate.queryForList(querySql,values);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> OpenPage(pageNo,pageSize, list,Integer.parseInt(String.valueOf(totalCount)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Description: 根据id获取唯一对象</span></span><br><span class="line"><span class="comment">    * Param: id</span></span><br><span class="line"><span class="comment">    * return: T</span></span><br><span class="line"><span class="comment">    * Author: shareyuan</span></span><br><span class="line"><span class="comment">    * Date: 2018/12/27</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">findOne</span><span class="params">(<span class="keyword">final</span> PK id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> entityManager.find(entityClass,id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 根据sql查询数据总数</span></span><br><span class="line"><span class="comment">     * Param:  sql,values</span></span><br><span class="line"><span class="comment">     * return:  Long</span></span><br><span class="line"><span class="comment">     * Author: shareyuan</span></span><br><span class="line"><span class="comment">     * Date: 2018/12/26</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Long <span class="title">getCountBySql</span><span class="params">(<span class="keyword">final</span> String sql, <span class="keyword">final</span> Object... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForObject(sql, Long.class, values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Description: 组合传入字符串数组</span></span><br><span class="line"><span class="comment">    * Param: objs</span></span><br><span class="line"><span class="comment">    * return: String</span></span><br><span class="line"><span class="comment">    * Author: shareyuan</span></span><br><span class="line"><span class="comment">    * Date: 2018/12/26</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  String <span class="title">getString</span><span class="params">(Object... objs)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(objs != <span class="keyword">null</span> &amp;&amp; objs.length &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objs.length; i++) &#123;</span><br><span class="line">                sb.append(objs[i] == <span class="keyword">null</span> ? EMPYT_STR : objs[i].toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> EMPYT_STR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Description: 去除sql的orderby 子句，用于分页查询</span></span><br><span class="line"><span class="comment">    * Param: sql</span></span><br><span class="line"><span class="comment">    * return: String</span></span><br><span class="line"><span class="comment">    * Author: shareyuan</span></span><br><span class="line"><span class="comment">    * Date: 2018/12/27</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">removeOrders</span><span class="params">(String sql)</span> </span>&#123;</span><br><span class="line">        Pattern p = Pattern.compile(<span class="string">"order\\s*by[\\w|\\W|\\s|\\S]*"</span>,</span><br><span class="line">                Pattern.CASE_INSENSITIVE);</span><br><span class="line">        Matcher m = p.matcher(sql);</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line">            m.appendReplacement(sb, <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        m.appendTail(sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Description: 去除sql的select 子句，未考虑union的情况</span></span><br><span class="line"><span class="comment">    * Param: sql</span></span><br><span class="line"><span class="comment">    * return: String</span></span><br><span class="line"><span class="comment">    * Author: shareyuan</span></span><br><span class="line"><span class="comment">    * Date: 2018/12/27</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">removeSelect</span><span class="params">(String sql)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> beginPos = sql.toLowerCase().indexOf(<span class="string">"from "</span>);</span><br><span class="line">        Assert.isTrue(beginPos != -<span class="number">1</span>, <span class="string">" hql : "</span> + sql</span><br><span class="line">                + <span class="string">" must has a keyword 'from'"</span>);</span><br><span class="line">        <span class="keyword">return</span> sql.substring(beginPos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Repository-1"><a href="#Repository-1" class="headerlink" title="Repository"></a>Repository</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span>(<span class="string">"oilCouponJdbcRepository"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OilCouponJdbcRepository</span> <span class="keyword">extends</span> <span class="title">AbstractServerRepository</span>&lt;<span class="title">OilCoupon</span>,<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Service-1"><a href="#Service-1" class="headerlink" title="Service"></a>Service</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> OpenPage&lt;Map&gt; <span class="title">getPage</span><span class="params">(String appId, Long userId, CouponPageVo couponPageVo)</span> </span>&#123;</span><br><span class="line">        StringBuffer sql = <span class="keyword">new</span> StringBuffer(<span class="string">"SELECT t.order_number AS orderNumber, sum(t.coupon_amt) AS sum, sum(CASE WHEN t.use_state = 'NOT_USE' THEN t.coupon_amt ELSE 0 END ) AS balance FROM open_oil_coupon t"</span>);</span><br><span class="line">        List params = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(appId))&#123;</span><br><span class="line">            sql.append(<span class="string">" WHERE t.user_id = ?  "</span>);</span><br><span class="line">            params.add(userId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(appId))&#123;</span><br><span class="line">            sql.append(<span class="string">" AND t.app_id = ? "</span>);</span><br><span class="line">            params.add(appId);</span><br><span class="line">        &#125;</span><br><span class="line">        sql.append(<span class="string">" GROUP BY t.order_number"</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.equals(couponPageVo.getUseState(),CommonEnum.USED.getValue()))&#123;</span><br><span class="line">            sql.append(<span class="string">" HAVING balance = 0"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.equals(couponPageVo.getUseState(),CommonEnum.NOT_USE.getValue()))&#123;</span><br><span class="line">            sql.append(<span class="string">" HAVING balance &gt; 0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sql.append(<span class="string">" ORDER BY t.created_at DESC,balance "</span>);</span><br><span class="line">        log.info(<span class="string">"分页sql为:&#123;&#125;,分页请求参数为:&#123;&#125;"</span>,sql,params.toArray());</span><br><span class="line">        <span class="keyword">return</span> oilCouponJdbcRepository.findPageBySqlForListMap(sql.toString(),couponPageVo.getPageNum(),couponPageVo.getPageSize(),params.toArray());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>:jdbc分页的好处就是可以多表进行联查自定义sql,相对来说比较灵活,对于复杂sql,我个人感觉可读性要比jpa的自定义sql要好一些。</p><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a><br><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h2&gt;&lt;p&gt;其实需求很简单,就是通过查询一个表得到数据列表,然后再对这个数据列表进行分页,自定义sql如下:&lt;/p&gt;
&lt;figure class=&quot;hi
      
    
    </summary>
    
      <category term="后端" scheme="https://lywlefan.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="java" scheme="https://lywlefan.github.io/tags/java/"/>
    
      <category term="框架" scheme="https://lywlefan.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="hibernate" scheme="https://lywlefan.github.io/tags/hibernate/"/>
    
  </entry>
  
  <entry>
    <title>如何设计一个秒杀系统读书笔记</title>
    <link href="https://lywlefan.github.io/2019/10/17/%E5%90%8E%E7%AB%AF/%E9%AB%98%E5%B9%B6%E5%8F%91/java/%E4%B9%A6%E7%B1%8D/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F-%E8%AE%B8%E4%BB%A4%E6%B3%A2/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://lywlefan.github.io/2019/10/17/后端/高并发/java/书籍/如何设计一个秒杀系统-许令波/如何设计一个秒杀系统读书笔记/</id>
    <published>2019-10-16T16:00:00.000Z</published>
    <updated>2019-10-21T10:29:17.789Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h2><h3 id="秒杀系统关键点"><a href="#秒杀系统关键点" class="headerlink" title="秒杀系统关键点"></a>秒杀系统关键点</h3><p>①我觉得作为一个程序员,你首先需要从高维度出发,从整体上思考问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G:对整体要有高屋建瓴，要站在最高处俯瞰，在落实的时候要把握好细节，下绣花针功夫。</span><br></pre></td></tr></table></figure><p>②秒杀其实主要解决两个问题,<strong>一个是并发读,一个是并发写</strong>。并发读的核心优化理念是尽量<strong>减少用户到服务来“读”数据</strong>,或者让他们读更少的数据;并发写的处理原则也一样,它<strong>要求我们在数据库层面独立出来一个库,做特殊的处理</strong>。另外,我们还要针对秒杀系统做一些保护,针对意料之外的情况<strong>设计兜底方案</strong>,以防止最坏的情况发生。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G：两个疑问，见疑问区域</span><br></pre></td></tr></table></figure><p>③从浏览器到服务端我们要遵循几个原则：</p><ul><li>请求数据尽量少</li><li>请求数尽量少</li><li>路径尽量短</li><li>依赖尽量少</li><li>不要有单点</li></ul><p><strong>④整体架构概括为几个字：稳、准、快</strong></p><ul><li>稳（高性能）：流量超出预期要保证稳定</li><li>准（一致性）：秒杀多少个商品就是多少个，一台也不能多，一台也不能少</li><li>快（高可用）：支撑大的流量，性能要好</li></ul><h3 id="设计秒杀系统注意的5个架构原则"><a href="#设计秒杀系统注意的5个架构原则" class="headerlink" title="设计秒杀系统注意的5个架构原则"></a>设计秒杀系统注意的5个架构原则</h3><p><strong>①“4要1不要”</strong></p><ul><li><p>数据尽量少：上传的数据和返回的数据</p></li><li><p>请求尽量少：</p><ul><li><p>合并CSS和JavaScript文件，多个合成一个</p><p>在 URL 中用逗号隔开 (<a href="https://g.xxx.com/tm/xx-b/4.0.94/mods/??module-preview/index.xtpl.js,module-jhs/index.xtpl.js,module-focus/index.xtpl.js)。" target="_blank" rel="noopener">https://g.xxx.com/tm/xx-b/4.0.94/mods/??module-preview/index.xtpl.js,module-jhs/index.xtpl.js,module-focus/index.xtpl.js)。</a> 这种方式在服务端仍然是单个文件各自存放,只是服务端会有一个组件解析这个 URL,然后动态把这些文件合并起来一起返回。</p></li></ul></li><li><p>路径尽量短</p><ul><li>缩短请求不仅可以增加可用性而且可以有效提升性能</li><li>要缩短访问路径有一种办法,就是多个相互强依赖的应用合并部署在一起,把远程过程调用<br>(RPC)变成JVM内部之间的调用。</li></ul></li><li><p>依赖尽量少</p><ul><li>系统分级（0级、1级、2级等等）</li></ul></li><li><p>不要单点</p><ul><li>应用无状态化</li><li>服务无状态化</li></ul></li></ul><p><strong>架构是一种平衡的艺术,而最好的架构一旦脱离了它所适应的场景,一切都将是空谈。</strong></p><h3 id="二八原则-有正对性的处理好系统的热点数据"><a href="#二八原则-有正对性的处理好系统的热点数据" class="headerlink" title="二八原则:有正对性的处理好系统的热点数据"></a>二八原则:有正对性的处理好系统的热点数据</h3><p>把少部分访问速度高的数据隔离拆分出来做单独的处理,让大多数的请求正常运行。</p><h3 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h3><p>削峰的存在，一是可以让服务端处理变得更加平稳，二是可以节省服务器的资源成本。</p><p>它遵从“请求数要尽量少”的原则。</p><h3 id="影响性能的因素有哪些？又该如何提高系统的性能？"><a href="#影响性能的因素有哪些？又该如何提高系统的性能？" class="headerlink" title="影响性能的因素有哪些？又该如何提高系统的性能？"></a>影响性能的因素有哪些？又该如何提高系统的性能？</h3><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><h3 id="如何减少用户来服务端读数据？？"><a href="#如何减少用户来服务端读数据？？" class="headerlink" title="如何减少用户来服务端读数据？？"></a>如何减少用户来服务端读数据？？</h3><h3 id="什么是兜底方案？？如何设计兜底？？"><a href="#什么是兜底方案？？如何设计兜底？？" class="headerlink" title="什么是兜底方案？？如何设计兜底？？"></a>什么是兜底方案？？如何设计兜底？？</h3><h3 id="什么是无状态化？？？"><a href="#什么是无状态化？？？" class="headerlink" title="什么是无状态化？？？"></a>什么是无状态化？？？</h3><h3 id="什么是”热点数据”"><a href="#什么是”热点数据”" class="headerlink" title="什么是”热点数据”???"></a>什么是”热点数据”???</h3><p>热点数据就是一个系统中,用户<strong>访问量最大的数据</strong>,比如:热点商品。热点数据又分为<strong>:静态热点数据</strong>和<strong>动态热点数据</strong>。</p><h4 id="如何分析发现热点数据"><a href="#如何分析发现热点数据" class="headerlink" title="如何分析发现热点数据??"></a>如何分析发现热点数据??</h4><p><strong>静态热点数据的发现</strong></p><p>提前通过统计这些数据,比如:热卖商品,我们可以通过TOP排行榜进行统计,秒杀商品可以让商家进行报名,提前对这些数据做好缓存和预处理。</p><p><strong>动态数据的发现</strong></p><p>构建热点发现系统,用于在短时间内发现热点商品,从而做出相应的处理策略。</p><ol><li>构建一个<strong>异步的系统</strong>，它可以收集交易链路上各个环节中的中间件产品的热点 Key，如 Nginx、缓存、RPC 服务框架等这些中间件（一些中间件产品本身已经有<strong>热点统计模块</strong>）。</li><li>建立一个<strong>热点上报和可以按照需求订阅的热点服务的下发规范</strong>，主要目的是通过交易链路上各个系统（包括详情、购物车、交易、优惠、库存、物流等）访问的时间差，<strong>把上游已经发现的热点透传给下游系统</strong>，提前做好保护。比如，对于大促高峰期，<strong>详情系统是最早知道的</strong>，在统一<strong>接入层上 Nginx 模块统计的热点 URL</strong>。</li><li>将<strong>上游系统收集的热点数据发送到热点服务台</strong>，然后下游系统（如交易系统）就会知道哪些商品会被频繁调用，然后做热点保护。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/热点分析系统.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G:热点分析平台:它存在的主要作用就是从各个可能收集热点数据的地方(每台机器上的Agen把日志汇总)收集到热点数据,然后对这些数据进行分析(分析集群),把分析到的热点数据进行发布,相关服务订阅到热点数据后,提前对这些热点数据做好处理(填充到 Cache等手段)。</span><br></pre></td></tr></table></figure><p><strong>热点分析系统构建注意事项:</strong></p><ol><li>这个热点服务后台抓取热点数据日志最好采用<strong>异步方式</strong>，因为“异步”一方面便于保证通用性，另一方面又不影响业务系统和中间件产品的主流程。</li><li><strong>热点服务发现和中间件自身的热点保护模块并存</strong>，每个中间件和应用还需要保护自己。热点服务台提供热点数据的收集和订阅服务，便于把各个系统的热点数据透明出来。</li><li>热点发现要做到接近实时（3s 内完成热点数据的发现），因为只有做到<strong>接近实时</strong>，动态发现才有意义，才能<strong>实时地对下游系统提供保护</strong>。</li></ol><p><strong>总结热点数据发现的方法</strong>:</p><ul><li>人工标识</li><li>大数据统计计算</li><li>以及实时热点发现方案</li></ul><h4 id="发现热点数据后如何处理热点数据"><a href="#发现热点数据后如何处理热点数据" class="headerlink" title="发现热点数据后如何处理热点数据?"></a>发现热点数据后如何处理热点数据?</h4><p><strong>优化</strong></p><p><strong>LRU淘汰算法</strong>实时缓存热点数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。</span><br></pre></td></tr></table></figure><p><strong>限制</strong></p><p>限制更多的是一种保护机制，限制的办法也有很多，例如对被访问商品的 ID 做一致性 Hash，然后根据 Hash 做分桶，每个分桶设置一个处理队列，这样可以把热点商品限制在一个请求队列里，防止因某些热点商品占用太多的服务器资源，而使其他请求始终得不到服务器的处理资源。</p><p><strong>隔离</strong></p><p>不要让 1% 的请求影响到另外的 99%，隔离出来后也更方便对这 1% 的请求做针对性的优化。</p><p>具体到“秒杀”业务，我们可以在以下几个层次实现隔离:</p><ol><li><strong>业务隔离</strong>。把秒杀做成一种营销活动，卖家要参加秒杀这种营销活动需要单独报名，从技术上来说，卖家报名后对我们来说就有了已知热点，因此可以<strong>提前做好预热</strong>。</li><li><strong>系统隔离</strong>。系统隔离更多的是运行时的隔离，可以通过<strong>分组部署的方式和另外 99% 分开</strong>。秒杀可以申请单独的域名，目的也是让请求落到不同的集群中。</li><li><strong>数据隔离</strong>。秒杀所调用的数据大部分都是热点数据，比如会启用单独的 Cache 集群或者 MySQL 数据库来放热点数据，目的也是不想 0.01% 的数据有机会影响 99.99% 数据。</li></ol><p>你可以按照用户来区分，给不同的用户分配不同的 Cookie，<strong>在接入层，路由到不同的服务接口</strong>中；</p><p>你还可以在接入层针对 <strong>URL 中的不同 Path 来设置限流</strong>策略。</p><p>服务层调用不同的服务接口，以及数据层通过给数据打标来区分等等这些措施，其目的都是<strong>把已经识别出来的热点请求和普通的请求区分</strong>开。</p><h3 id="流量削峰-1"><a href="#流量削峰-1" class="headerlink" title="流量削峰"></a>流量削峰</h3><h4 id="什么是流量削峰"><a href="#什么是流量削峰" class="headerlink" title="什么是流量削峰???"></a>什么是流量削峰???</h4><p>在秒杀的过程中,就某一个时间来说请求实非常大的,我们的服务监控会看到一根非常直的线,因为所有请求都汇聚在这个时间点,对流量产生瞬时的消耗。</p><p>而流量削峰就是避免这种情况的发生,让并发请延缓,过滤掉无效的请求,让秒杀请求不在瞬时爆发,避免压垮服务器情况的发生。</p><h4 id="为什么要削峰"><a href="#为什么要削峰" class="headerlink" title="为什么要削峰???"></a>为什么要削峰???</h4><p>秒杀就像大家去买早餐,早餐是有限的,买早餐的人可能非常多,大家为了买到早餐都往早餐店冲,这样的结果就是挤爆早餐店,大家谁也买不到早餐。</p><p>把请求当做买早餐的人,把早餐当成秒杀的商品是一样的道理.所以,削峰的意义就在于让服务器正常处理请求,避免服务器资源的浪费,保质保量完成请求任务。</p><h4 id="如何进行流量削峰"><a href="#如何进行流量削峰" class="headerlink" title="如何进行流量削峰???"></a>如何进行流量削峰???</h4><h5 id="无损的解决方案"><a href="#无损的解决方案" class="headerlink" title="无损的解决方案"></a>无损的解决方案</h5><ul><li>答题</li><li>排队</li><li>分层过滤</li></ul><h5 id="有损的解决方案"><a href="#有损的解决方案" class="headerlink" title="有损的解决方案"></a>有损的解决方案</h5><ul><li>限流</li><li>负载保护</li></ul><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a></p></blockquote><blockquote><p><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;阅读笔记&quot;&gt;&lt;a href=&quot;#阅读笔记&quot; class=&quot;headerlink&quot; title=&quot;阅读笔记&quot;&gt;&lt;/a&gt;阅读笔记&lt;/h2&gt;&lt;h3 id=&quot;秒杀系统关键点&quot;&gt;&lt;a href=&quot;#秒杀系统关键点&quot; class=&quot;headerlink&quot; title=&quot;秒杀系
      
    
    </summary>
    
      <category term="后端" scheme="https://lywlefan.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="java" scheme="https://lywlefan.github.io/tags/java/"/>
    
      <category term="高并发" scheme="https://lywlefan.github.io/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
      <category term="java并发编程实战-王宝令" scheme="https://lywlefan.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98-%E7%8E%8B%E5%AE%9D%E4%BB%A4/"/>
    
      <category term="读书笔记" scheme="https://lywlefan.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>后端导航</title>
    <link href="https://lywlefan.github.io/2019/10/15/%E5%90%8E%E7%AB%AF/%E5%90%8E%E7%AB%AF%E5%AF%BC%E8%88%AA/"/>
    <id>https://lywlefan.github.io/2019/10/15/后端/后端导航/</id>
    <published>2019-10-14T16:00:00.000Z</published>
    <updated>2019-10-17T01:48:18.792Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网站直达"><a href="#网站直达" class="headerlink" title="网站直达"></a>网站直达</h1><h2 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h2><h2 id="团队博客"><a href="#团队博客" class="headerlink" title="团队博客"></a>团队博客</h2><p><a href="https://tech.meituan.com/" target="_blank" rel="noopener">美团技术团队</a>&emsp;<a href="https://blog.didiyun.com/index.php/category/development/" target="_blank" rel="noopener">滴滴技术团队</a>&emsp;<a href="http://jm.taobao.org/" target="_blank" rel="noopener">阿里中间件团队博客</a> &emsp;<a href="https://www.baidu.com/link?url=jqkSj1_Ki_48KWDAFwel7BJIu8Bmjq8e3F0W_6qg7PjVfpgUKYRia9PNGma1xz7y&amp;wd=&amp;eqid=b52783800040a54d000000035da73d69" target="_blank" rel="noopener"><em>阿里</em>云系统组<em>技术博客</em></a>&emsp; <a href="https://cloud.tencent.com/developer" target="_blank" rel="noopener">腾讯云+社区</a>&emsp;</p><h2 id="个人博客"><a href="#个人博客" class="headerlink" title="个人博客"></a>个人博客</h2><p><a href="http://jijiangshe.com" target="_blank" rel="noopener">技匠社</a> &emsp;<a href="https://sspai.com" target="_blank" rel="noopener">少数派</a>&emsp;<a href="https://me.csdn.net/qq_27093465" target="_blank" rel="noopener">李学凯</a>&emsp;<a href="http://blog.didispace.com/" target="_blank" rel="noopener">程序员DD</a> &emsp;<a href="http://itmuch.com/" target="_blank" rel="noopener">周立|Spring Cloud</a> &emsp;<a href="http://www.bysocket.com/" target="_blank" rel="noopener">泥瓦匠BYSocket的博客</a> &emsp;<a href="http://kailing.pub/" target="_blank" rel="noopener">KL博客</a> <a href="http://edisonxu.org/" target="_blank" rel="noopener">Edison Xu’s Blog</a> &emsp;<a href="http://blog.720ui.com/" target="_blank" rel="noopener">梁桂钊的博客</a> &emsp;<a href="http://www.icnws.com/" target="_blank" rel="noopener">城南往事</a> &emsp;<a href="http://www.ictgu.cn/" target="_blank" rel="noopener">Any-Video</a> <a href="http://blog.54im.com/" target="_blank" rel="noopener">钿畑的博客</a>&emsp; <a href="http://cmsblogs.com/" target="_blank" rel="noopener">chenssy</a> &emsp;<a href="https://www.cnkirito.moe/" target="_blank" rel="noopener">徐靖峰|个人博客</a> &emsp;<a href="http://cxytiandi.com/" target="_blank" rel="noopener">猿天地</a> <a href="https://crossoverjie.top/" target="_blank" rel="noopener">crossoverjie</a>&emsp; <a href="http://www.iocoder.cn/" target="_blank" rel="noopener">芋道源码</a> &emsp;<a href="https://purewhite.io/" target="_blank" rel="noopener">Pure White</a> &emsp;<a href="https://blog.52itstyle.vip/" target="_blank" rel="noopener">小柒</a>&emsp; <a href="https://www.cnblogs.com/netfocus/archive/2012/02/12/2347919.html" target="_blank" rel="noopener">汤雪华的博客</a>&emsp; <a href="https://www.cnblogs.com/huxi2b/" target="_blank" rel="noopener">kafka核心技术讲解作者·huxihx</a> &emsp;<a href="https://blog.csdn.net/a724888" target="_blank" rel="noopener">黄小斜</a> <a href="https://github.com/h2pl/" target="_blank" rel="noopener">黄小斜github</a>&emsp;<a href="https://www.cnblogs.com/wayfarer/" target="_blank" rel="noopener">张逸的博客(ThoughtWorks架构师)</a>&emsp;<a href="https://nndl.github.io/" target="_blank" rel="noopener">神经网络与深度学习·邱锡鹏</a>&emsp;</p><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a><br><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;网站直达&quot;&gt;&lt;a href=&quot;#网站直达&quot; class=&quot;headerlink&quot; title=&quot;网站直达&quot;&gt;&lt;/a&gt;网站直达&lt;/h1&gt;&lt;h2 id=&quot;官网&quot;&gt;&lt;a href=&quot;#官网&quot; class=&quot;headerlink&quot; title=&quot;官网&quot;&gt;&lt;/a&gt;官网&lt;/h
      
    
    </summary>
    
      <category term="后端" scheme="https://lywlefan.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="导航" scheme="https://lywlefan.github.io/tags/%E5%AF%BC%E8%88%AA/"/>
    
  </entry>
  
  <entry>
    <title>如何把订单均匀分布到分片表里面</title>
    <link href="https://lywlefan.github.io/2019/09/29/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/sharding-jdbc/%E5%A6%82%E4%BD%95%E6%8A%8A%E8%AE%A2%E5%8D%95%E5%9D%87%E5%8C%80%E5%88%86%E5%B8%83%E5%88%B0%E5%88%86%E7%89%87%E8%A1%A8%E9%87%8C%E9%9D%A2/"/>
    <id>https://lywlefan.github.io/2019/09/29/后端/中间件/分库分表/sharding-jdbc/如何把订单均匀分布到分片表里面/</id>
    <published>2019-09-28T16:00:00.000Z</published>
    <updated>2019-10-15T06:42:25.684Z</updated>
    
    <content type="html"><![CDATA[<p>这几天学习了数据库的中间件—-sharding-jdbc,</p><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://shardingsphere.apache.org" target="_blank" rel="noopener">官方文档</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这几天学习了数据库的中间件—-sharding-jdbc,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;参考文档&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://shardingsphere
      
    
    </summary>
    
      <category term="后端" scheme="https://lywlefan.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="分库分表" scheme="https://lywlefan.github.io/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    
      <category term="sharding-jdbc" scheme="https://lywlefan.github.io/tags/sharding-jdbc/"/>
    
  </entry>
  
  <entry>
    <title>初始Sharding-jdbc.md</title>
    <link href="https://lywlefan.github.io/2019/09/27/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/sharding-jdbc/%E5%88%9D%E5%A7%8BSharding-jdbc/"/>
    <id>https://lywlefan.github.io/2019/09/27/后端/中间件/分库分表/sharding-jdbc/初始Sharding-jdbc/</id>
    <published>2019-09-26T16:00:00.000Z</published>
    <updated>2019-10-15T06:42:26.155Z</updated>
    
    <content type="html"><![CDATA[<p>让我们一起来学习数据库中间件shardingsphere,shareding-jdbc是他其中的一个产品.</p><h2 id="what"><a href="#what" class="headerlink" title="what"></a>what</h2><h3 id="什么是shardingsphere"><a href="#什么是shardingsphere" class="headerlink" title="什么是shardingsphere?"></a>什么是shardingsphere?</h3><p>shardingsphere是一个数据库中间件,</p><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://shardingsphere.apache.org" target="_blank" rel="noopener">官方文档</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;让我们一起来学习数据库中间件shardingsphere,shareding-jdbc是他其中的一个产品.&lt;/p&gt;
&lt;h2 id=&quot;what&quot;&gt;&lt;a href=&quot;#what&quot; class=&quot;headerlink&quot; title=&quot;what&quot;&gt;&lt;/a&gt;what&lt;/h2&gt;&lt;h3 
      
    
    </summary>
    
      <category term="后端" scheme="https://lywlefan.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="分库分表" scheme="https://lywlefan.github.io/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    
      <category term="sharding-jdbc" scheme="https://lywlefan.github.io/tags/sharding-jdbc/"/>
    
  </entry>
  
  <entry>
    <title>try-with-resources和multiple catch的学习</title>
    <link href="https://lywlefan.github.io/2019/09/03/%E5%90%8E%E7%AB%AF/%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/java/%E5%BC%82%E5%B8%B8/try-with-resources%E5%92%8Cmultiple%20catch%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>https://lywlefan.github.io/2019/09/03/后端/基础巩固/java/异常/try-with-resources和multiple catch的学习/</id>
    <published>2019-09-02T16:00:00.000Z</published>
    <updated>2019-10-15T06:42:24.753Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>万丈高楼平地起的前提是地基好.</p></blockquote><h1 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么?"></a>是什么?</h2><p>在Java编程过程中，如果打开了外部资源（文件、数据库连接、网络连接等），我们必须在这些外部资源使用完毕后，手动关闭它们。因为外部资源不由JVM管理，无法享用JVM的垃圾回收机制，如果我们不在编程时确保在正确的时机关闭外部资源，就会导致外部资源泄露，紧接着就会出现文件被异常占用，数据库连接过多导致连接池溢出等诸多很严重的问题。</p><p>为了确保外部资源一定要被关闭，通常关闭代码被写入finally代码块中，当然我们还必须注意到关闭资源时可能抛出的异常，于是变有了下面的经典代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    FileInputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        inputStream = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"test"</span>));</span><br><span class="line">        System.out.println(inputStream.read());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage(), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="multiple-catch"><a href="#multiple-catch" class="headerlink" title="multiple catch"></a>multiple catch</h1><h2 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么?"></a>是什么?</h2><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a><br><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;万丈高楼平地起的前提是地基好.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;try-with-resources&quot;&gt;&lt;a href=&quot;#try-with-resources&quot; class=&quot;headerlink&quot; title=&quot;try-wi
      
    
    </summary>
    
      <category term="后端" scheme="https://lywlefan.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="基础" scheme="https://lywlefan.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="java" scheme="https://lywlefan.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>AOT,JIT学习总结</title>
    <link href="https://lywlefan.github.io/2019/09/03/%E5%90%8E%E7%AB%AF/%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/java/jvm/AOT,JIT%E5%AD%A6%E4%B9%A0/"/>
    <id>https://lywlefan.github.io/2019/09/03/后端/基础巩固/java/jvm/AOT,JIT学习/</id>
    <published>2019-09-02T16:00:00.000Z</published>
    <updated>2019-10-15T06:42:25.223Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>万丈高楼平地起的前提是地基好.</p></blockquote><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么?"></a>是什么?</h2><p>JIT，即Just-in-time,动态(即时)编译，边运行边编译；AOT，Ahead Of Time，指运行前编译，是两种程序的编译方式</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>这两种编译方式的主要区别在于是否在“运行时”进行编译</p><h3 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>可以根据当前硬件情况实时编译生成最优机器指令（ps. AOT也可以做到，在用户使用是使用字节码根据机器情况在做一次编译）</li><li>可以根据当前程序的运行情况生成最优的机器指令序列</li><li>当程序需要支持动态链接时，只能使用JIT</li><li>可以根据进程中内存的实际情况调整代码，使内存能够更充分的利用</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>编译需要占用运行时资源，会导致进程卡顿</li><li>由于编译时间需要占用运行时间，对于某些代码的编译优化不能完全支持，需要在程序流畅和编译时间之间做权衡</li><li>在编译准备和识别频繁使用的方法需要占用时间，使得初始编译不能达到最高性能</li></ul><h3 id="AOT"><a href="#AOT" class="headerlink" title="AOT"></a>AOT</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>在程序运行前编译，可以避免在运行时的编译性能消耗和内存消耗</li><li>可以在程序运行初期就达到最高性能</li><li>可以显著的加快程序的启动</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>在程序运行前编译会使程序安装的时间增加</li><li>牺牲Java的一致性</li><li>将提前编译的内容保存会占用更多的外</li></ul><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a><br><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;万丈高楼平地起的前提是地基好.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink&quot; title=&quot;是什么?&quot;&gt;&lt;/a&gt;是什么?&lt;/h2&gt;&lt;p&gt;JIT，即Just-in-t
      
    
    </summary>
    
      <category term="后端" scheme="https://lywlefan.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="基础" scheme="https://lywlefan.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="java" scheme="https://lywlefan.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>02.redis的线程IO和通讯协议</title>
    <link href="https://lywlefan.github.io/2019/08/13/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/NOSQL/redis/03.redis%E7%9A%84%E7%BA%BF%E7%A8%8BIO%E5%92%8C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE/"/>
    <id>https://lywlefan.github.io/2019/08/13/后端/数据存储/NOSQL/redis/03.redis的线程IO和通讯协议/</id>
    <published>2019-08-12T16:00:00.000Z</published>
    <updated>2019-10-15T06:42:25.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="redis的线程IO"><a href="#redis的线程IO" class="headerlink" title="redis的线程IO"></a>redis的线程IO</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/3084894-bcf206af27739ea2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线程IO" title>                </div>                <div class="image-caption">线程IO</div>            </figure><p>Redis是个单线程程序!但是他有高并发特性,单个节点可以支持10w的QPS。除了redis是单线程,Nginx也是单线程的。单线程为什么如此之快?单线程有如何处理多并发的客户端连接?下面让我们带着这些问题一起深究redis的线程IO。</p><h3 id="5种IO模型学习"><a href="#5种IO模型学习" class="headerlink" title="5种IO模型学习"></a>5种IO模型学习</h3><ul><li><p>阻塞IO模型</p></li><li><p>非阻塞IO模型</p></li><li><p>IO复用模型</p></li><li><p>信号驱动的IO模型</p></li><li><p>异步IO模型</p></li></ul><h4 id="阻塞IO模型"><a href="#阻塞IO模型" class="headerlink" title="阻塞IO模型"></a>阻塞IO模型</h4><p>进程发起IO系统调用后，进程被阻塞，转到内核空间处理，整个IO处理完毕后返回进程。操作成功则进程获取到数据。</p><h5 id="类比"><a href="#类比" class="headerlink" title="类比"></a>类比</h5><p>老李去火车站买票，排队三天买到一张退票。</p><p>耗费：在车站吃喝拉撒睡 3天，其他事一件没干。</p><h5 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用"></a>典型应用</h5><ul><li><p>阻塞socket</p></li><li><p>java BIO</p></li></ul><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li><p>进程阻塞挂起不消耗CPU资源，及时响应每个操作；</p></li><li><p>实现难度低、开发应用较容易；</p></li><li><p>适用并发量小的网络应用开发；</p></li></ul><p>不适用并发量大的应用：因为一个请求IO会阻塞进程，所以，得为每请求分配一个处理进程（线程）以及时响应，系统开销大。</p><h4 id="非阻塞IO模型"><a href="#非阻塞IO模型" class="headerlink" title="非阻塞IO模型"></a>非阻塞IO模型</h4><p>进程发起IO系统调用后，如果内核缓冲区没有数据，需要到IO设备中读取，进程返回一个错误而不会被阻塞；进程发起IO系统调用后，如果内核缓冲区有数据，内核就会把数据返回进程。</p><h5 id="类比-1"><a href="#类比-1" class="headerlink" title="类比"></a>类比</h5><p> 老李去火车站买票，隔12小时去火车站问有没有退票，三天后买到一张票。</p><p> 耗费：往返车站6次，路上6小时，其他时间做了好多事。</p><h5 id="典型应用-1"><a href="#典型应用-1" class="headerlink" title="典型应用"></a>典型应用</h5><ul><li>socket是非阻塞的方式（设置为NONBLOCK）</li></ul><h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><ul><li><p>进程轮询（重复）调用，消耗CPU的资源；</p></li><li><p>实现难度低、开发应用相对阻塞IO模式较难；</p></li><li><p>适用并发量较小、且不需要及时响应的网络应用开发；</p></li></ul><h4 id="IO复用模型"><a href="#IO复用模型" class="headerlink" title="IO复用模型"></a>IO复用模型</h4><p>多个的进程的IO可以注册到一个复用器（select）上，然后用一个进程调用该select， select会监听所有注册进来的IO；</p><p>如果select没有监听的IO在内核缓冲区都没有可读数据，select调用进程会被阻塞；而当任一IO在内核缓冲区中有可数据时，select调用就会返回；</p><p>而后select调用进程可以自己或通知另外的进程（注册进程）来再次发起读取IO，读取内核中准备好的数据。</p><p>可以看到，多个进程注册IO后，只有另一个select调用进程被阻塞。</p><h5 id="类比-2"><a href="#类比-2" class="headerlink" title="类比"></a>类比</h5><p>是找一个宿管大妈来帮你监视下楼的女生, 这个期间你可以些其他的事情. 例如可以顺便看看其他妹子,玩玩王者荣耀, 上个厕所等等. IO复用又包括 select, poll, epoll 模式. 那么它们的区别是什么?</p><ul><li>select</li></ul><p>每一个女生下楼, select大妈都不知道这个是不是你的女神, 她需要一个一个询问, 并且select大妈能力还有限, 最多一次帮你监视1024个妹子</p><ul><li>poll</li></ul><p>不限制盯着女生的数量, 只要是经过宿舍楼门口的女生, 都会帮你去问是不是你女神</p><ul><li>epoll</li></ul><p>不限制盯着女生的数量, 并且也不需要一个一个去问. 那么如何做呢? epoll大妈会为每个进宿舍楼的女生脸上贴上一个大字条,上面写上女生自己的名字, 只要女生下楼了, epoll大妈就知道这个是不是你女神了, 然后大妈再通知你.</p><h5 id="典型应用-2"><a href="#典型应用-2" class="headerlink" title="典型应用"></a>典型应用</h5><ul><li><p>select</p></li><li><p>poll</p></li><li><p>epoll三种方案</p></li><li><p>nginx都可以选择使用这三个方案</p></li><li><p>Java NIO;</p></li></ul><h5 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h5><ul><li><p>专一进程解决多个进程IO的阻塞问题，性能好；Reactor模式;</p></li><li><p>实现、开发应用难度较大；</p></li><li><p>适用高并发服务应用开发：一个进程（线程）响应多个请求</p></li></ul><h5 id="形成原因"><a href="#形成原因" class="headerlink" title="形成原因"></a>形成原因</h5><p>如果一个I/O流进来，我们就开启一个进程处理这个I/O流。那么假设现在有一百万个I/O流进来，那我们就需要开启一百万个进程一一对应处理这些I/O流（——这就是传统意义下的多进程并发处理）。思考一下，一百万个进程，你的CPU占有率会多高，这个实现方式及其的不合理。所以人们提出了I/O多路复用这个模型，一个线程，通过记录I/O流的状态来同时管理多个I/O，可以提高服务器的吞吐能力。</p><h4 id="信号驱动的IO模型"><a href="#信号驱动的IO模型" class="headerlink" title="信号驱动的IO模型"></a>信号驱动的IO模型</h4><p>当进程发起一个IO操作，会向内核注册一个信号处理函数，然后进程返回不阻塞；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用IO读取数据。</p><h5 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h5><ul><li>回调机制，实现、开发应用难度大；</li></ul><h4 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h4><p>当进程发起一个IO操作，进程返回（不阻塞），但也不能返回果结；内核把整个IO处理完后，会通知进程结果。如果IO操作成功则进程直接获取到数据。</p><h5 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h5><ul><li><p>不阻塞，数据一步到位；Proactor模式；</p></li><li><p>需要操作系统的底层支持，LINUX 2.5 版本内核首现，2.6 版本产品的内核标准特性；</p></li><li><p>实现、开发应用难度大；</p></li><li><p>非常适合高性能高并发应用</p></li></ul><h5 id="典型"><a href="#典型" class="headerlink" title="典型"></a>典型</h5><ul><li><p>JAVA7 AIO</p></li><li><p>高性能服务器应用</p></li></ul><p>通过学习5种IO模型,我们知道了Redis就是使用的IO复用模型里面的select。</p><h3 id="指令队列"><a href="#指令队列" class="headerlink" title="指令队列"></a>指令队列</h3><p>Redis 会将每个客户端套接字都关联一个指令队列。客户端的指令通过队列来排队进行顺序处理，先到先服务。 也就是说指令的请求顺序是通过队列来进行约束的。</p><h3 id="响应队列"><a href="#响应队列" class="headerlink" title="响应队列"></a>响应队列</h3><p>每个客户端关联一个响应队列。然后服务端通过响应队列将数据返回给客户端。</p><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><p>服务器处理要响应 IO 事件外，还要处理其它事情。比如定时任务就是非常重要的一件事。如果线程阻塞在 select 系统调用上，定时任务将无法得到准时调度。那 Redis 是如何解决这个问题的呢？</p><blockquote><p>如果面试官问到这个问题我肯定是处于懵逼状态。老钱书中写到,redis会把定时任务记录到一个叫最小堆的数据结构中,每个周期循环redis会立即处理堆最上面的数据。  </p></blockquote><h2 id="redis的通讯协议"><a href="#redis的通讯协议" class="headerlink" title="redis的通讯协议"></a>redis的通讯协议</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/3084894-d8790174146ea545.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="通讯协议" title>                </div>                <div class="image-caption">通讯协议</div>            </figure><h3 id="RESP协议简介"><a href="#RESP协议简介" class="headerlink" title="RESP协议简介"></a>RESP协议简介</h3><p>Redis 的客户端和服务端之间采取了一种独立名为 RESP(REdis Serialization Protocol) 的协议，作者主要考虑了以下几个点：</p><ul><li>容易实现</li><li>解析快</li><li>人类可读</li></ul><p>注意：RESP 虽然是为 Redis 设计的，但是同样也可以用于其他 C/S 的软件。</p><h3 id="数据类型及示例"><a href="#数据类型及示例" class="headerlink" title="数据类型及示例"></a>数据类型及示例</h3><p>RESP 主要可以序列化以下几种类型：整数，单行回复(简单字符串)，数组，错误信息，多行字符串。Redis 客户端向服务端发送的是一组由执行的命令组成的字符串数组，服务端根据不同的命令回复不同类型的数据，但协议的每部分都是以 “\r\n” (CRLF) 结尾的。另外 RESP 是二进制安全的，不需要处理从一个进程到另一个进程的传输，因为它使用了前缀长度进行传输。</p><p>在 RESP 中, 一些数据的类型通过它的第一个字节进行判断：</p><ul><li><p>单行回复：回复的第一个字节是 “+”</p></li><li><p>错误信息：回复的第一个字节是 “-”</p></li><li><p>整形数字：回复的第一个字节是 “:”</p></li><li><p>多行字符串：回复的第一个字节是 “\$”</p></li><li><p>数组：回复的第一个字节是 “*”</p></li></ul><p>RESP 协议还是相对易于理解的，另外理解了协议也方便对 Redis 一些问题的定位及客户端的实现。</p><p>Redis 协议里有大量冗余的回车换行符，但是这不影响它成为互联网技术领域非常受欢迎的一个文本协议。有很多开源项目使用 RESP 作为它的通讯协议。在技术领域性能并不总是一切，还有简单性、易理解性和易实现性，这些都需要进行适当权衡。</p><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a></p></blockquote><blockquote><p><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><blockquote><p><a href="https://redis.io" target="_blank" rel="noopener">【3】redis官网</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;redis的线程IO&quot;&gt;&lt;a href=&quot;#redis的线程IO&quot; class=&quot;headerlink&quot; title=&quot;redis的线程IO&quot;&gt;&lt;/a&gt;redis的线程IO&lt;/h2&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
           
      
    
    </summary>
    
      <category term="后端" scheme="https://lywlefan.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="redis" scheme="https://lywlefan.github.io/tags/redis/"/>
    
      <category term="数据存储" scheme="https://lywlefan.github.io/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
      <category term="NOSQL" scheme="https://lywlefan.github.io/tags/NOSQL/"/>
    
  </entry>
  
  <entry>
    <title>内功修炼-算法02</title>
    <link href="https://lywlefan.github.io/2019/08/13/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%8A%9B%E6%89%A3/%E5%86%85%E5%8A%9F%E4%BF%AE%E7%82%BC-%E7%AE%97%E6%B3%9502/"/>
    <id>https://lywlefan.github.io/2019/08/13/算法/算法基础/力扣/内功修炼-算法02/</id>
    <published>2019-08-12T16:00:00.000Z</published>
    <updated>2019-10-15T08:11:12.416Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>万丈高楼平地起的前提是地基好.</p></blockquote><h2 id="题目-无重复字符的最长子串"><a href="#题目-无重复字符的最长子串" class="headerlink" title="题目:无重复字符的最长子串"></a>题目:无重复字符的最长子串</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><h4 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h4><ul><li>不含有重复字符的最大字符串长度</li></ul><h4 id="思路梳理"><a href="#思路梳理" class="headerlink" title="思路梳理"></a>思路梳理</h4><h5 id="我的解题思路"><a href="#我的解题思路" class="headerlink" title="我的解题思路"></a>我的解题思路</h5><ul><li><p>1.把字符串转换为字符数组</p></li><li><p>2.把字符串逐个放入set集合(set),同时记录放入集合的数量(j)</p></li><li><p>2.如果set集合长度和放入数量不符,记录该长度(l),清空set集合,把j设置为0,放入刚才放入的值,继续循环</p></li><li><p>3.如果继续出现上述清空,和上面记录的长度进行对比,小于清空继续,大于更新记录长度</p></li></ul><p>总结:上述解题思路忽略了空格字符串的情况,存在问题.</p><h5 id="正确的解题思路-滑动窗口"><a href="#正确的解题思路-滑动窗口" class="headerlink" title="正确的解题思路:滑动窗口"></a>正确的解题思路:滑动窗口</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/3084894-676af09bd331705a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="时间窗移动原理" title>                </div>                <div class="image-caption">时间窗移动原理</div>            </figure><ul><li><p>1.定义一个map集合(map)，用于存储字符值和位置，key为字符，value为字符位置加1</p></li><li><p>2.定义一个变量ans,用于记录时间窗最大长度</p></li><li><p>3.定义时间窗起点start和时间窗结束点end</p></li><li><p>4.然后把end向右滑动,最大长度为（end-start+1），如果map集合中存在该元素,说明遇到了重复的元素</p><ul><li><p>4.1.记录时间窗最大值ans</p></li><li><p>4.2.移动时间窗start到重复元素第一个之后的位置</p></li></ul></li><li><p>5.继续滑动,直到j=字符串长度</p></li></ul><h3 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h3><h4 id="我的解答"><a href="#我的解答" class="headerlink" title="我的解答"></a>我的解答</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 思路一:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      1.把字符串转换为字符数组</span></span><br><span class="line"><span class="comment"> *      2.把字符串逐个放入set集合(set),同时记录放入集合的数量(j)</span></span><br><span class="line"><span class="comment"> *      2.如果set集合长度和放入数量不符,记录该长度(l),清空set集合,把j设置为0,放入刚才放入的值,继续循环</span></span><br><span class="line"><span class="comment"> *      3.如果继续出现上述清空,和上面记录的长度进行对比,小于清空继续,大于更新记录长度</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      时间复杂度:T(N) 空间复杂度:O(1)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 测试情况:不通过</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 总结分析:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      1.没有考虑到空格字符串的情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring1</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> [] chars = s.toCharArray();</span><br><span class="line">    Set set = <span class="keyword">new</span> HashSet();</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;chars.length;i++)&#123;</span><br><span class="line">       set.add(chars[i]);</span><br><span class="line">       j++;</span><br><span class="line">       <span class="keyword">if</span> (set.size()&lt;j)&#123;</span><br><span class="line">           l = Math.max(set.size(),l);</span><br><span class="line">           set.clear();</span><br><span class="line">           j = <span class="number">1</span>;</span><br><span class="line">           set.add(chars[i]);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="正确的解答"><a href="#正确的解答" class="headerlink" title="正确的解答"></a>正确的解答</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 思路二: 滑动窗口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      1.定义一个map集合(map)，用于存储字符值和位置，key为字符，value为字符位置加1</span></span><br><span class="line"><span class="comment"> *      2.定义一个变量ans,用于记录时间窗最大长度</span></span><br><span class="line"><span class="comment"> *      3.定义时间窗起点start和时间窗结束点end</span></span><br><span class="line"><span class="comment"> *      4.然后把end向右滑动,最大长度为（end-start+1），如果map集合中存在该元素,说明遇到了重复的元素</span></span><br><span class="line"><span class="comment"> *          4.1.记录时间窗最大值ans</span></span><br><span class="line"><span class="comment"> *          4.2.移动时间窗start到重复元素第一个之后的位置</span></span><br><span class="line"><span class="comment"> *      5.继续滑动,直到j=字符串长度</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length(), ans = <span class="number">0</span>;</span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> end = <span class="number">0</span>, start = <span class="number">0</span>; end &lt; n; end++) &#123;</span><br><span class="line">        <span class="keyword">char</span> alpha = s.charAt(end);</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(alpha)) &#123;</span><br><span class="line">            start = Math.max(map.get(alpha), start);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = Math.max(ans, end - start + <span class="number">1</span>);</span><br><span class="line">        map.put(s.charAt(end), end + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目总结"><a href="#题目总结" class="headerlink" title="题目总结"></a>题目总结</h3><p>在做这道题目的过程中,没有考虑到空格字符串的情况,这是基础不扎实导致的,null/“”/“ “,这三个还是有很大的区别的,如果大家也遇到和我一样的问题,可以当做是一个教训。</p><p>还有就是滑动窗口,这个理解比较麻烦,最好可以看我上面画的那种图,或者你可以自己画一个出来,滑动窗口是一个常用的办法,我们要深入理解。记得在有一次做限流的时候也用到了滑动窗口的概念。</p><h3 id="问题讨论"><a href="#问题讨论" class="headerlink" title="问题讨论"></a>问题讨论</h3><ul><li>假如让你用滑动窗口实现一个简单的限流,如何实现?(加入星球看答案哦!里面有更多精彩内容!)</li></ul><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a></p></blockquote><blockquote><p><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><blockquote><p><a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">【3】leetcode算法指南</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;万丈高楼平地起的前提是地基好.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目-无重复字符的最长子串&quot;&gt;&lt;a href=&quot;#题目-无重复字符的最长子串&quot; class=&quot;headerlink&quot; title=&quot;题目:无重复字符的最长子串&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="算法" scheme="https://lywlefan.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="力扣" scheme="https://lywlefan.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="基础" scheme="https://lywlefan.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>21.合并两个有序的链表</title>
    <link href="https://lywlefan.github.io/2019/08/06/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%8A%9B%E6%89%A3/21.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>https://lywlefan.github.io/2019/08/06/算法/算法基础/力扣/21.合并两个有序的链表/</id>
    <published>2019-08-05T16:00:00.000Z</published>
    <updated>2019-10-15T08:11:12.750Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>万丈高楼平地起的前提是地基好.</p></blockquote><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><h3 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h3><h3 id="思路梳理"><a href="#思路梳理" class="headerlink" title="思路梳理"></a>思路梳理</h3><h3 id="题目实现"><a href="#题目实现" class="headerlink" title="题目实现"></a>题目实现</h3><h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a></p></blockquote><blockquote><p><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><blockquote><p><a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">【3】leetcode算法指南</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;万丈高楼平地起的前提是地基好.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;题目介绍&quot;&gt;&lt;a href=&quot;#题目介绍&quot; class=&quot;headerlink&quot; title=&quot;题目介绍&quot;&gt;&lt;/a&gt;题目介绍&lt;/h3&gt;&lt;p&gt;将两个有序链表合并为一个
      
    
    </summary>
    
      <category term="算法" scheme="https://lywlefan.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="力扣" scheme="https://lywlefan.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="基础" scheme="https://lywlefan.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>22.括号的生成</title>
    <link href="https://lywlefan.github.io/2019/08/05/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%8A%9B%E6%89%A3/22.%E6%8B%AC%E5%8F%B7%E7%9A%84%E7%94%9F%E6%88%90/"/>
    <id>https://lywlefan.github.io/2019/08/05/算法/算法基础/力扣/22.括号的生成/</id>
    <published>2019-08-04T16:00:00.000Z</published>
    <updated>2019-10-15T08:11:12.582Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>万丈高楼平地起的前提是地基好.</p></blockquote><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p><p>例如，给出 n = 3，生成结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[</span><br><span class="line">  &quot;((()))&quot;,</span><br><span class="line">  &quot;(()())&quot;,</span><br><span class="line">  &quot;(())()&quot;,</span><br><span class="line">  &quot;()(())&quot;,</span><br><span class="line">  &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="思路梳理"><a href="#思路梳理" class="headerlink" title="思路梳理"></a>思路梳理</h3><h4 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h4><ul><li><p>生成括号对数</p></li><li><p>生成括号不同对数</p></li><li><p>生成的括号必须要闭合</p></li><li><p>生成括号的类型要用大括号包住</p></li></ul><h4 id="如何实现哪"><a href="#如何实现哪" class="headerlink" title="如何实现哪??"></a>如何实现哪??</h4><h5 id="我的思路-分类法-X"><a href="#我的思路-分类法-X" class="headerlink" title="我的思路:分类法 (X)"></a>我的思路:分类法 (X)</h5><ul><li><p>第一种情况:括号中括号</p></li><li><p>第二种情况:括号中多个括号</p></li><li><p>第三种情况:分割括号,然后括号中括号(左右)</p></li><li><p>第四种情况:括号独立类型</p></li></ul><h5 id="官方思路"><a href="#官方思路" class="headerlink" title="官方思路:"></a>官方思路:</h5><h3 id="题目实现"><a href="#题目实现" class="headerlink" title="题目实现"></a>题目实现</h3><h4 id="我的实现"><a href="#我的实现" class="headerlink" title="我的实现"></a>我的实现</h4><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><h4 id="最优解实现"><a href="#最优解实现" class="headerlink" title="最优解实现"></a>最优解实现</h4><h5 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h5><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a></p></blockquote><blockquote><p><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><blockquote><p><a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">【3】leetcode算法指南</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;万丈高楼平地起的前提是地基好.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;题目介绍&quot;&gt;&lt;a href=&quot;#题目介绍&quot; class=&quot;headerlink&quot; title=&quot;题目介绍&quot;&gt;&lt;/a&gt;题目介绍&lt;/h3&gt;&lt;p&gt;给出 n 代表生成括号的
      
    
    </summary>
    
      <category term="算法" scheme="https://lywlefan.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="力扣" scheme="https://lywlefan.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="基础" scheme="https://lywlefan.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>20.有效的括号</title>
    <link href="https://lywlefan.github.io/2019/08/02/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%8A%9B%E6%89%A3/20.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>https://lywlefan.github.io/2019/08/02/算法/算法基础/力扣/20.有效的括号/</id>
    <published>2019-08-01T16:00:00.000Z</published>
    <updated>2019-10-15T08:11:12.866Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>万丈高楼平地起的前提是地基好.</p></blockquote><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: true</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出: true</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: &quot;(]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><h3 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h3><h3 id="思路梳理"><a href="#思路梳理" class="headerlink" title="思路梳理"></a>思路梳理</h3><h4 id="哪些情况括号不闭合"><a href="#哪些情况括号不闭合" class="headerlink" title="哪些情况括号不闭合"></a>哪些情况括号不闭合</h4><ul><li><p>第一种:[(])</p></li><li><p>第二种:[)</p></li><li><p>第三种:[](</p></li></ul><h4 id="如何判断括号没有闭合"><a href="#如何判断括号没有闭合" class="headerlink" title="如何判断括号没有闭合"></a>如何判断括号没有闭合</h4><blockquote><p>注意：只包括括号，这是条件要注意！</p></blockquote><ul><li><p>1.获取每种类型左括号的第一次出现的位置</p></li><li><p>2.然后再找到每种类型右括号第一次出现的位置</p></li><li><p>3.如果存在以下情况则括号没有闭合</p><ul><li><p>a.类型左括号位置小于另一种类型括号右括号的位置,则括号没有闭合</p></li><li><p>b.任意类型括号不存在左括号或者右括号,则括号没有闭合</p></li></ul></li></ul><h4 id="最优解"><a href="#最优解" class="headerlink" title="最优解"></a>最优解</h4><ul><li>1.把左括号压入栈中</li><li>2.如果遇到右括号,取出栈最上面的元素去对应的值,判断和循环的元素是否相等,相等继续循环,否则返回false</li><li>3.循环结束,栈里面的元素依次被取出,说明括号串没啥问题,是闭合的. </li></ul><h3 id="题目实现"><a href="#题目实现" class="headerlink" title="题目实现"></a>题目实现</h3><h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> Map&lt;Character, Character&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    map.put(<span class="string">'('</span>, <span class="string">')'</span>);</span><br><span class="line">    map.put(<span class="string">'&#123;'</span>, <span class="string">'&#125;'</span>);</span><br><span class="line">    map.put(<span class="string">'['</span>, <span class="string">']'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法一</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> in : s.toCharArray()) &#123;</span><br><span class="line">        <span class="comment">//左括号直接入栈</span></span><br><span class="line">        <span class="keyword">if</span> (map.keySet().contains(in)) &#123;</span><br><span class="line">            stack.push(in);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp; in == map.get(stack.pop())) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a></p></blockquote><blockquote><p><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><blockquote><p><a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">【3】leetcode算法指南</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;万丈高楼平地起的前提是地基好.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;题目介绍&quot;&gt;&lt;a href=&quot;#题目介绍&quot; class=&quot;headerlink&quot; title=&quot;题目介绍&quot;&gt;&lt;/a&gt;题目介绍&lt;/h3&gt;&lt;p&gt;给定一个只包括 ‘(‘，
      
    
    </summary>
    
      <category term="算法" scheme="https://lywlefan.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="力扣" scheme="https://lywlefan.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="基础" scheme="https://lywlefan.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>算法导航</title>
    <link href="https://lywlefan.github.io/2019/08/01/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%88%AA/"/>
    <id>https://lywlefan.github.io/2019/08/01/算法/算法导航/</id>
    <published>2019-07-31T16:00:00.000Z</published>
    <updated>2019-10-15T08:11:12.814Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>万丈高楼平地起的前提是地基好.</p></blockquote><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a></p></blockquote><blockquote><p><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><blockquote><p><a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">【3】leetcode算法指南</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;万丈高楼平地起的前提是地基好.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;参考文档&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://w
      
    
    </summary>
    
      <category term="算法" scheme="https://lywlefan.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="导航" scheme="https://lywlefan.github.io/tags/%E5%AF%BC%E8%88%AA/"/>
    
  </entry>
  
  <entry>
    <title>ab.exe压测工具的使用</title>
    <link href="https://lywlefan.github.io/2019/07/31/%E6%B5%8B%E8%AF%95/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/ab.exe%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://lywlefan.github.io/2019/07/31/测试/压力测试/ab.exe压测工具的使用/</id>
    <published>2019-07-30T16:00:00.000Z</published>
    <updated>2019-10-15T08:11:12.259Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>工欲善其事，必先利器！</p></blockquote><h3 id="ad-exe介绍"><a href="#ad-exe介绍" class="headerlink" title="ad.exe介绍"></a>ad.exe介绍</h3><p>ab.exe是一个性能检测工具，是apache server中的一个小组件，使用简单，方便</p><h3 id="ad-exe下载"><a href="#ad-exe下载" class="headerlink" title="ad.exe下载"></a>ad.exe下载</h3><p><a href="http://files.cnblogs.com/files/gossip/ab.zip" target="_blank" rel="noopener">下载地址</a></p><h3 id="ad-exe使用步骤"><a href="#ad-exe使用步骤" class="headerlink" title="ad.exe使用步骤"></a>ad.exe使用步骤</h3><h4 id="打开cmd"><a href="#打开cmd" class="headerlink" title="打开cmd"></a>打开cmd</h4><h4 id="进入ab-exe所在的路径（默认放在d盘根目录下）"><a href="#进入ab-exe所在的路径（默认放在d盘根目录下）" class="headerlink" title="进入ab.exe所在的路径（默认放在d盘根目录下）"></a>进入ab.exe所在的路径（默认放在d盘根目录下）</h4><h4 id="命令示例"><a href="#命令示例" class="headerlink" title="命令示例"></a>命令示例</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">#介绍ab的命令</span><br><span class="line">ab help</span><br><span class="line">#ab命令请求（一共请求10次,10个并发同时请求）</span><br><span class="line">ab -n 10 -c 10 http://www.cnblogs.com/</span><br><span class="line">#ab命令超时请求（一共请求50次,50个并发同时请求，超时时间设为100秒， 当出现timeout时，可以设置超时时间）</span><br><span class="line">ab -n 50 -c 50 -t 100 http://www.cnblogs.com/</span><br></pre></td></tr></table></figure><h3 id="ab命令使用场景"><a href="#ab命令使用场景" class="headerlink" title="ab命令使用场景"></a>ab命令使用场景</h3><ul><li>可以测试网关的限流</li></ul><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a><br><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;工欲善其事，必先利器！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;ad-exe介绍&quot;&gt;&lt;a href=&quot;#ad-exe介绍&quot; class=&quot;headerlink&quot; title=&quot;ad.exe介绍&quot;&gt;&lt;/a&gt;ad.exe介绍&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="测试" scheme="https://lywlefan.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="压力测试" scheme="https://lywlefan.github.io/tags/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>01.初始redis</title>
    <link href="https://lywlefan.github.io/2019/07/30/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/NOSQL/redis/01.%E5%88%9D%E5%A7%8Bredis/"/>
    <id>https://lywlefan.github.io/2019/07/30/后端/数据存储/NOSQL/redis/01.初始redis/</id>
    <published>2019-07-29T16:00:00.000Z</published>
    <updated>2019-10-15T06:42:25.070Z</updated>
    
    <content type="html"><![CDATA[<h3 id="redis是什么"><a href="#redis是什么" class="headerlink" title="redis是什么?"></a>redis是什么?</h3><p>redis是一个内存型数据(in-memory data structure store)。Redis是用ANSI C编写的。</p><h4 id="官网对redis关键词描述"><a href="#官网对redis关键词描述" class="headerlink" title="官网对redis关键词描述"></a>官网对redis关键词描述</h4><ul><li><p>开源内存数据库</p></li><li><p>可以进行缓存和消息代理</p></li><li><p>支持的数据类型有：字符串/hash/list/set/bitmaps/hyperloglogs</p></li><li><p>可以对集合进行排序</p></li><li><p>地理位置范围半径查询</p></li><li><p>支持流</p></li><li><p>内置复制功能</p></li><li><p>支持lua脚本</p></li><li><p>LRU缓存淘汰算法</p></li><li><p>磁盘级的持久化</p></li><li><p>redis集群</p></li></ul><h3 id="redis支持什么数据类型"><a href="#redis支持什么数据类型" class="headerlink" title="redis支持什么数据类型"></a>redis支持什么数据类型</h3><h4 id="字符类型-strings"><a href="#字符类型-strings" class="headerlink" title="字符类型(strings)"></a>字符类型(strings)</h4><h4 id="哈希类型-hashes"><a href="#哈希类型-hashes" class="headerlink" title="哈希类型(hashes)"></a>哈希类型(hashes)</h4><h4 id="list集合类型-lists"><a href="#list集合类型-lists" class="headerlink" title="list集合类型(lists)"></a>list集合类型(lists)</h4><h4 id="set集合类型-sets"><a href="#set集合类型-sets" class="headerlink" title="set集合类型(sets)"></a>set集合类型(sets)</h4><ul><li><p>不允许重复</p></li><li><p>无序</p></li></ul><h4 id="sorted-set集合类型-sorted-sets"><a href="#sorted-set集合类型-sorted-sets" class="headerlink" title="sorted set集合类型(sorted sets)"></a>sorted set集合类型(sorted sets)</h4><ul><li><p>不允许重复</p></li><li><p>有序(通过设置分数进行排序)</p></li></ul><h4 id="位图-bitmaps"><a href="#位图-bitmaps" class="headerlink" title="位图(bitmaps)"></a>位图(bitmaps)</h4><ul><li><p>按位进行标识</p></li><li><p>适合某个时间段状态只有两种的场景</p></li></ul><p>比如:签到,每天签到,状态就是签了或者没签</p><ul><li>占用内存小</li></ul><h4 id="hyperloglogs"><a href="#hyperloglogs" class="headerlink" title="hyperloglogs"></a>hyperloglogs</h4><ul><li><p>Redis 在 2.8.9 版本添加了 HyperLogLog 结构</p></li><li><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p></li><li><p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p></li><li><p>因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p></li><li><p>HyperLogLog是一种算法，并非redis独有</p></li><li><p>目的是做基数统计，故不是集合，不会保存元数据，只记录数量而不是数值。</p></li><li><p>耗空间极小，支持输入非常体积的数据量</p></li><li><p>核心是基数估算算法，主要表现为计算时内存的使用和数据合并的处理。最终数值存在一定误差</p></li><li><p>redis中每个hyperloglog key占用了12K的内存用于标记基数（官方文档）</p></li><li><p>pfadd命令并不会一次性分配12k内存，而是随着基数的增加而逐渐增加内存分配；而pfmerge操作则会将sourcekey合并后存储在12k大小的key中，这由hyperloglog合并操作的原理（两个hyperloglog合并时需要单独比较每个桶的值）可以很容易理解。</p></li><li><p>误差说明：基数估计的结果是一个带有 0.81% 标准错误（standard error）的近似值。是可接受的范围</p></li><li><p>Redis 对 HyperLogLog 的存储进行了优化，在计数比较小时，它的存储空间采用稀疏矩阵存储，空间占用很小，仅仅在计数慢慢变大，稀疏矩阵占用空间渐渐超过了阈值时才会一次性转变成稠密矩阵，才会占用 12k 的空间</p></li></ul><h5 id="数据结构描述"><a href="#数据结构描述" class="headerlink" title="数据结构描述"></a>数据结构描述</h5><h5 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h5><ul><li><p>基数统计(不允许重复的数据)</p></li><li><p>占用12k空间</p></li></ul><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul><li><p>统计注册 IP 数</p></li><li><p>统计每日访问 IP 数</p></li><li><p>统计页面实时 UV 数</p></li><li><p>统计在线用户数</p></li><li><p>统计用户每天搜索不同词条的个数</p></li></ul><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a></p></blockquote><blockquote><p><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><blockquote><p><a href="https://redis.io" target="_blank" rel="noopener">【3】redis官网</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;redis是什么&quot;&gt;&lt;a href=&quot;#redis是什么&quot; class=&quot;headerlink&quot; title=&quot;redis是什么?&quot;&gt;&lt;/a&gt;redis是什么?&lt;/h3&gt;&lt;p&gt;redis是一个内存型数据(in-memory data structure store
      
    
    </summary>
    
      <category term="后端" scheme="https://lywlefan.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="redis" scheme="https://lywlefan.github.io/tags/redis/"/>
    
      <category term="数据存储" scheme="https://lywlefan.github.io/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
      <category term="NOSQL" scheme="https://lywlefan.github.io/tags/NOSQL/"/>
    
  </entry>
  
  <entry>
    <title>02.redis的应用--布隆过滤器</title>
    <link href="https://lywlefan.github.io/2019/07/30/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/NOSQL/redis/02.redis%E7%9A%84%E5%BA%94%E7%94%A8--%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>https://lywlefan.github.io/2019/07/30/后端/数据存储/NOSQL/redis/02.redis的应用--布隆过滤器/</id>
    <published>2019-07-29T16:00:00.000Z</published>
    <updated>2019-10-15T06:42:26.043Z</updated>
    
    <content type="html"><![CDATA[<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><h4 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/3084894-1be30bea723ccf8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="布隆过滤器" title>                </div>                <div class="image-caption">布隆过滤器</div>            </figure><h3 id="布隆过滤器应用"><a href="#布隆过滤器应用" class="headerlink" title="布隆过滤器应用"></a>布隆过滤器应用</h3><h4 id="新闻推送去重"><a href="#新闻推送去重" class="headerlink" title="新闻推送去重"></a>新闻推送去重</h4><h4 id="垃圾邮件去重"><a href="#垃圾邮件去重" class="headerlink" title="垃圾邮件去重"></a>垃圾邮件去重</h4><h4 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h4><h5 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a>下载插件</h5><p><a href="https://github.com/RedisBloom/RedisBloom/releases" target="_blank" rel="noopener">点击该地址选择合适的版本</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#下载</span><br><span class="line">wget https://github.com/RedisLabsModules/rebloom/archive/v1.1.1.tar.gz</span><br><span class="line">#解压</span><br><span class="line">tar zxvf v1.1.1.tar.gz</span><br><span class="line">cd rebloom-1.1.1</span><br><span class="line"># 编译</span><br><span class="line">make</span><br></pre></td></tr></table></figure><h4 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a>配置插件</h4><p>在redis配置文件(redis.conf)中加入该模块即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadmodule /usr/local/web/redis/RedisBloom-1.1.1/rebloom.so</span><br></pre></td></tr></table></figure><p>或者启动的时候加载进去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /etc/redis/redis.conf --loadmodule /opt/redis/RedisBloom-2.0.1/src/rebloom.so INITIAL_SIZE 10000000 ERROR_RATE 0.0001</span><br></pre></td></tr></table></figure><h4 id="执行相关命令测试"><a href="#执行相关命令测试" class="headerlink" title="执行相关命令测试"></a>执行相关命令测试</h4><blockquote><p>以上就是我安装的步骤，但是安装完成后还是出现了问题，记录下来，后续慢慢解决。</p></blockquote><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a></p></blockquote><blockquote><p><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><blockquote><p><a href="https://redis.io" target="_blank" rel="noopener">【3】redis官网</a></p></blockquote><blockquote><p><a href="https://github.com/RedisBloom/RedisBloom" target="_blank" rel="noopener">【4】布隆过滤器插件下载地址</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;布隆过滤器&quot;&gt;&lt;a href=&quot;#布隆过滤器&quot; class=&quot;headerlink&quot; title=&quot;布隆过滤器&quot;&gt;&lt;/a&gt;布隆过滤器&lt;/h3&gt;&lt;h4 id=&quot;思维导图&quot;&gt;&lt;a href=&quot;#思维导图&quot; class=&quot;headerlink&quot; title=&quot;思维导图&quot;
      
    
    </summary>
    
      <category term="后端" scheme="https://lywlefan.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="redis" scheme="https://lywlefan.github.io/tags/redis/"/>
    
      <category term="数据存储" scheme="https://lywlefan.github.io/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
      <category term="NOSQL" scheme="https://lywlefan.github.io/tags/NOSQL/"/>
    
  </entry>
  
  <entry>
    <title>MPP(大规模并行处理)简介</title>
    <link href="https://lywlefan.github.io/2019/07/19/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/MBPP%E6%95%B0%E6%8D%AE%E5%BA%93/MPP(%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86)%E7%AE%80%E4%BB%8B/"/>
    <id>https://lywlefan.github.io/2019/07/19/后端/数据存储/MBPP数据库/MPP(大规模并行处理)简介/</id>
    <published>2019-07-18T16:00:00.000Z</published>
    <updated>2019-10-15T06:42:25.849Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&emsp;&emsp;实践一门技术的最好方式就是深入理解它的思想，然后造一个出来！</p></blockquote><h3 id="1、-什么是MPP？"><a href="#1、-什么是MPP？" class="headerlink" title="1、 什么是MPP？"></a>1、 什么是MPP？</h3><p>MPP (Massively Parallel Processing)，即大规模并行处理，在数据库非共享集群中，每个节点都有独立的磁盘存储系统和内存系统，业务数据根据数据库模型和应用特点划分到各个节点上，每台数据节点通过专用网络或者商业通用网络互相连接，彼此协同计算，作为整体提供数据库服务。非共享数据库集群有完全的可伸缩性、高可用、高性能、优秀的性价比、资源共享等优势。</p><p>简单来说，MPP是将任务并行的分散到多个服务器和节点上，在每个节点上计算完成后，将各自部分的结果汇总在一起得到最终的结果(与Hadoop相似)。</p><h3 id="2、MPP-大规模并行处理-架构"><a href="#2、MPP-大规模并行处理-架构" class="headerlink" title="2、MPP(大规模并行处理)架构"></a>2、MPP(大规模并行处理)架构</h3><p><img src="https://img-blog.csdn.net/20180607153205548?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTg5MDgz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt>                                         (MPP架构)</p><h3 id="3、-MPP架构特征"><a href="#3、-MPP架构特征" class="headerlink" title="3、 MPP架构特征"></a>3、 MPP架构特征</h3><p>● 任务并行执行;</p><p>● 数据分布式存储(本地化);</p><p>● 分布式计算;</p><p>● 私有资源;</p><p>● 横向扩展;</p><p>● Shared Nothing架构。</p><h3 id="4、-MPP服务器架构"><a href="#4、-MPP服务器架构" class="headerlink" title="4、 MPP服务器架构"></a>4、 MPP服务器架构</h3><p>它由多个SMP服务器通过一定的节点互联网络进行连接，协同工作，完成相同的任务，从用户的角度来看是一个服务器系统。其基本特征是由多个SMP服务器(每个SMP服务器称节点)通过节点互联网络连接而成，每个节点只访问自己的本地资源(内存、存储等)，是一种完全无共享(Share Nothing)结构，因而扩展能力最好，理论上其扩展无限制。</p><h3 id="5、MPPDB"><a href="#5、MPPDB" class="headerlink" title="5、MPPDB"></a>5、MPPDB</h3><p>MPPDB是一款 Shared Nothing 架构的分布式并行结构化数据库集群，具备高性能、高可用、高扩展特性，可以为超大规模数据管理提供高性价比的通用计算平台，并广泛地用于支撑各类数据仓库系统、BI 系统和决策支持系统</p><h3 id="6、MPPDB架构"><a href="#6、MPPDB架构" class="headerlink" title="6、MPPDB架构"></a>6、MPPDB架构</h3><p>MPP 采用完全并行的MPP + Shared Nothing 的分布式扁平架构，这种架构中的每一个节点（node）都是独立的、自给的、节点之间对等，而且整个系统中不存在单点瓶颈，具有非常强的扩展性。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20180607153236902?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTg5MDgz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="7、-MPPDB特征"><a href="#7、-MPPDB特征" class="headerlink" title="7、 MPPDB特征"></a>7、 MPPDB特征</h3><p>MPP 具备以下技术特征：</p><p>1) 低硬件成本：完全使用 x86 架构的 PC Server，不需要昂贵的 Unix 服务器和磁盘阵列；</p><p>2) 集群架构与部署：完全并行的 MPP + Shared Nothing 的分布式架构，采用 Non-Master 部署，节点对等的扁平结构；</p><p>3) 海量数据分布压缩存储：可处理 PB 级别以上的结构化数据，采用 hash分布、random 存储策略进行数据存储；同时采用先进的压缩算法，减少存储数据所需的空间，可以将所用空间减少 1~20 倍，并相应地提高 I/O 性能；</p><p>4) 数据加载高效性：基于策略的数据加载模式，集群整体加载速度可达2TB/h；</p><p>5) 高扩展、高可靠：支持集群节点的扩容和缩容，支持全量、增量的备份/恢复;</p><p>6) 高可用、易维护：数据通过副本提供冗余保护，自动故障探测和管理，自动同步元数据和业务数据。提供图形化工具，以简化管理员对数据库的管理工作；</p><p>7) 高并发：读写不互斥，支持数据的边加载边查询，单个节点并发能力大于 300 用户；</p><p>8) 行列混合存储：提供行列混合存储方案，从而提高了列存数据库特殊查询场景的查询响应耗时；</p><p>9) 标准化：支持SQL92 标准，支持 C API、ODBC、JDBC、ADO.NET 等接口规范。</p><h3 id="8、-常见MPPDB"><a href="#8、-常见MPPDB" class="headerlink" title="8、 常见MPPDB"></a>8、 常见MPPDB</h3><p>● GREENPLUM(EMC)</p><p>● Asterdata(Teradata)</p><p>● Nettezza(IBM)</p><p>● Vertica(HP)</p><p>● GBase 8a MPP cluster(南大通用)</p><h3 id="9、-MPPDB、Hadoop与传统数据库技术对比与适用场景"><a href="#9、-MPPDB、Hadoop与传统数据库技术对比与适用场景" class="headerlink" title="9、 MPPDB、Hadoop与传统数据库技术对比与适用场景"></a>9、 MPPDB、Hadoop与传统数据库技术对比与适用场景</h3><p>MPPDB与Hadoop都是将运算分布到节点中独立运算后进行结果合并(分布式计算)，但由于依据的理论和采用的技术路线不同而有各自的优缺点和适用范围。两种技术以及传统数据库技术的对比如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/19/5d3189cc48dc124520.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>综合而言，Hadoop和MPP两种技术的特定和适用场景为：</p><p>● Hadoop在处理非结构化和半结构化数据上具备优势，尤其适合海量数据批处理等应用要求。</p><p>● MPP适合替代现有关系数据机构下的大数据处理，具有较高的效率。</p><p>MPP适合多维度数据自助分析、数据集市等；Hadoop适合海量数据存储查询、批量数据ETL、非机构化数据分析(日志分析、文本分析)等。</p><p>由上述对比可预见未来大数据存储与处理趋势：MPPDB+Hadoop混搭使用，用MPP处理PB级别的、高质量的结构化数据，同时为应用提供丰富的SQL和事物支持能力；用Hadoop实现半结构化、非结构化数据处理。这样可以同时满足结构化、半结构化和非结构化数据的高效处理需求。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20180607153301340?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTg5MDgz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt title>                </div>                <div class="image-caption"></div>            </figure><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a>﻿<br><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a>﻿﻿</p></blockquote><p>—﻿</p><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong>﻿</p><p><img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>﻿﻿</p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;实践一门技术的最好方式就是深入理解它的思想，然后造一个出来！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1、-什么是MPP？&quot;&gt;&lt;a href=&quot;#1、-什么是MPP？&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="后端" scheme="https://lywlefan.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="数据存储" scheme="https://lywlefan.github.io/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
      <category term="MBPP数据库" scheme="https://lywlefan.github.io/tags/MBPP%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>理财书籍收集</title>
    <link href="https://lywlefan.github.io/2019/07/18/%E8%AF%BB%E4%B9%A6%E7%9C%8B%E6%8A%A5/%E4%B9%A6%E5%8D%95/%E7%90%86%E8%B4%A2%E4%B9%A6%E7%B1%8D%E6%94%B6%E9%9B%86/%E7%90%86%E8%B4%A2%E4%B9%A6%E7%B1%8D%E6%94%B6%E9%9B%86/"/>
    <id>https://lywlefan.github.io/2019/07/18/读书看报/书单/理财书籍收集/理财书籍收集/</id>
    <published>2019-07-17T16:00:00.000Z</published>
    <updated>2019-10-15T08:11:12.693Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>多读书，多看报，少吃零食，少睡觉！</p></blockquote><h2 id="理财书籍汇集"><a href="#理财书籍汇集" class="headerlink" title="理财书籍汇集"></a>理财书籍汇集</h2><h3 id="未读"><a href="#未读" class="headerlink" title="未读"></a>未读</h3><ul><li><p>《谁动了我的奶酪》 </p></li><li><p>《小狗钱钱》</p></li><li><p>《富爸爸，穷爸爸》，《财务自由之路》和《投资指南》 </p></li><li><p>《一分钟百万富翁》 </p></li><li><p>《怎样启迪你头脑中的金融意识》 </p></li><li><p>《财源滚滚》</p></li><li><p>《钻石就在你家后院》</p></li><li><p>《我的百万富翁兄弟》</p></li></ul><h3 id="已读"><a href="#已读" class="headerlink" title="已读"></a>已读</h3><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a><br><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;多读书，多看报，少吃零食，少睡觉！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;理财书籍汇集&quot;&gt;&lt;a href=&quot;#理财书籍汇集&quot; class=&quot;headerlink&quot; title=&quot;理财书籍汇集&quot;&gt;&lt;/a&gt;理财书籍汇集&lt;/h2&gt;&lt;h3 i
      
    
    </summary>
    
      <category term="读书看报" scheme="https://lywlefan.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%9C%8B%E6%8A%A5/"/>
    
    
      <category term="书单" scheme="https://lywlefan.github.io/tags/%E4%B9%A6%E5%8D%95/"/>
    
      <category term="理财" scheme="https://lywlefan.github.io/tags/%E7%90%86%E8%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>财务词汇</title>
    <link href="https://lywlefan.github.io/2019/07/11/%E8%AF%BB%E4%B9%A6%E7%9C%8B%E6%8A%A5/%E8%AF%8D%E6%B1%87/%E8%B4%A2%E5%8A%A1/%E8%B4%A2%E5%8A%A1%E8%AF%8D%E6%B1%87/"/>
    <id>https://lywlefan.github.io/2019/07/11/读书看报/词汇/财务/财务词汇/</id>
    <published>2019-07-10T16:00:00.000Z</published>
    <updated>2019-10-15T08:11:12.525Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>先有词汇量,然后再能好好说话,好好做事。</p></blockquote><ul><li><p>重要</p></li><li><p>不重要</p></li><li><p>理解</p></li><li><p>未理解</p></li></ul><h2 id="2019年"><a href="#2019年" class="headerlink" title="2019年"></a>2019年</h2><h3 id="7月份词汇"><a href="#7月份词汇" class="headerlink" title="7月份词汇"></a>7月份词汇</h3><h4 id="重要理解词汇"><a href="#重要理解词汇" class="headerlink" title="重要理解词汇"></a>重要理解词汇</h4><ul><li>资产</li></ul><blockquote><p>G:如何获得资产？<br>a.加杠杆购买资产，产生源源不断的现金流<br>b.花时间创造资产</p></blockquote><ul><li><p>负债</p></li><li><p>现值</p></li></ul><p>是在给定的利率水平下，未来的资金折现到现在时刻的价值。</p><ul><li><p>现金流</p><ul><li><p>经营性现金流</p></li><li><p>投资性现金流</p></li><li><p>融资性现金流</p></li></ul></li><li><p>资产负债表</p></li><li><p>损益表</p></li><li><p>所有者权益变动表</p></li><li><p>财务报表附注</p></li><li><p>审查报表</p></li><li><p>预算盈余</p></li><li><p>净现值法（NPV）</p><ul><li><p>净现值</p><p>未来资金流现值与未来资金流出现值差额。</p></li></ul></li><li><p>折现率</p></li></ul><p>折现率是指将未来有限期预期收益折算成现值的比率。</p><ul><li>内部收益率（IRR）</li></ul><h4 id="不重要理解词汇"><a href="#不重要理解词汇" class="headerlink" title="不重要理解词汇"></a>不重要理解词汇</h4><ul><li><p>直线法折旧</p></li><li><p>双倍余额递减法折旧（年折旧率=2÷预计的折旧年限×100％）</p></li></ul><h4 id="重要不理解词汇"><a href="#重要不理解词汇" class="headerlink" title="重要不理解词汇"></a>重要不理解词汇</h4><h4 id="不重要不理解词汇"><a href="#不重要不理解词汇" class="headerlink" title="不重要不理解词汇"></a>不重要不理解词汇</h4><ul><li><p>借款人</p></li><li><p>信贷人员</p></li><li><p>银行流水</p></li></ul><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a><br><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;先有词汇量,然后再能好好说话,好好做事。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;重要&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不重要&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;理解&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;未理解&lt;/p&gt;
&lt;/li
      
    
    </summary>
    
      <category term="读书看报" scheme="https://lywlefan.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%9C%8B%E6%8A%A5/"/>
    
    
      <category term="词汇" scheme="https://lywlefan.github.io/tags/%E8%AF%8D%E6%B1%87/"/>
    
      <category term="财务" scheme="https://lywlefan.github.io/tags/%E8%B4%A2%E5%8A%A1/"/>
    
  </entry>
  
</feed>
