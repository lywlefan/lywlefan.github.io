<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>share猿</title>
  
  <subtitle>https://lywlefan.github.io/</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lywlefan.github.io/"/>
  <updated>2019-07-19T09:15:28.267Z</updated>
  <id>https://lywlefan.github.io/</id>
  
  <author>
    <name>share猿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MPP(大规模并行处理)简介</title>
    <link href="https://lywlefan.github.io/2019/07/19/%E6%95%B0%E6%8D%AE%E5%BA%93/MBPP%E6%95%B0%E6%8D%AE%E5%BA%93/MPP(%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86)%E7%AE%80%E4%BB%8B/"/>
    <id>https://lywlefan.github.io/2019/07/19/数据库/MBPP数据库/MPP(大规模并行处理)简介/</id>
    <published>2019-07-18T16:00:00.000Z</published>
    <updated>2019-07-19T09:15:28.267Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&emsp;&emsp;实践一门技术的最好方式就是深入理解它的思想，然后造一个出来！</p></blockquote><h3 id="1、-什么是MPP？"><a href="#1、-什么是MPP？" class="headerlink" title="1、 什么是MPP？"></a>1、 什么是MPP？</h3><p>MPP (Massively Parallel Processing)，即大规模并行处理，在数据库非共享集群中，每个节点都有独立的磁盘存储系统和内存系统，业务数据根据数据库模型和应用特点划分到各个节点上，每台数据节点通过专用网络或者商业通用网络互相连接，彼此协同计算，作为整体提供数据库服务。非共享数据库集群有完全的可伸缩性、高可用、高性能、优秀的性价比、资源共享等优势。</p><p>简单来说，MPP是将任务并行的分散到多个服务器和节点上，在每个节点上计算完成后，将各自部分的结果汇总在一起得到最终的结果(与Hadoop相似)。</p><h3 id="2、MPP-大规模并行处理-架构"><a href="#2、MPP-大规模并行处理-架构" class="headerlink" title="2、MPP(大规模并行处理)架构"></a>2、MPP(大规模并行处理)架构</h3><p><img src="https://img-blog.csdn.net/20180607153205548?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTg5MDgz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt>                                         (MPP架构)</p><h3 id="3、-MPP架构特征"><a href="#3、-MPP架构特征" class="headerlink" title="3、 MPP架构特征"></a>3、 MPP架构特征</h3><p>● 任务并行执行;</p><p>● 数据分布式存储(本地化);</p><p>● 分布式计算;</p><p>● 私有资源;</p><p>● 横向扩展;</p><p>● Shared Nothing架构。</p><h3 id="4、-MPP服务器架构"><a href="#4、-MPP服务器架构" class="headerlink" title="4、 MPP服务器架构"></a>4、 MPP服务器架构</h3><p>它由多个SMP服务器通过一定的节点互联网络进行连接，协同工作，完成相同的任务，从用户的角度来看是一个服务器系统。其基本特征是由多个SMP服务器(每个SMP服务器称节点)通过节点互联网络连接而成，每个节点只访问自己的本地资源(内存、存储等)，是一种完全无共享(Share Nothing)结构，因而扩展能力最好，理论上其扩展无限制。</p><h3 id="5、MPPDB"><a href="#5、MPPDB" class="headerlink" title="5、MPPDB"></a>5、MPPDB</h3><p>MPPDB是一款 Shared Nothing 架构的分布式并行结构化数据库集群，具备高性能、高可用、高扩展特性，可以为超大规模数据管理提供高性价比的通用计算平台，并广泛地用于支撑各类数据仓库系统、BI 系统和决策支持系统</p><h3 id="6、MPPDB架构"><a href="#6、MPPDB架构" class="headerlink" title="6、MPPDB架构"></a>6、MPPDB架构</h3><p>MPP 采用完全并行的MPP + Shared Nothing 的分布式扁平架构，这种架构中的每一个节点（node）都是独立的、自给的、节点之间对等，而且整个系统中不存在单点瓶颈，具有非常强的扩展性。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20180607153236902?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTg5MDgz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="7、-MPPDB特征"><a href="#7、-MPPDB特征" class="headerlink" title="7、 MPPDB特征"></a>7、 MPPDB特征</h3><p>MPP 具备以下技术特征：</p><p>1) 低硬件成本：完全使用 x86 架构的 PC Server，不需要昂贵的 Unix 服务器和磁盘阵列；</p><p>2) 集群架构与部署：完全并行的 MPP + Shared Nothing 的分布式架构，采用 Non-Master 部署，节点对等的扁平结构；</p><p>3) 海量数据分布压缩存储：可处理 PB 级别以上的结构化数据，采用 hash分布、random 存储策略进行数据存储；同时采用先进的压缩算法，减少存储数据所需的空间，可以将所用空间减少 1~20 倍，并相应地提高 I/O 性能；</p><p>4) 数据加载高效性：基于策略的数据加载模式，集群整体加载速度可达2TB/h；</p><p>5) 高扩展、高可靠：支持集群节点的扩容和缩容，支持全量、增量的备份/恢复;</p><p>6) 高可用、易维护：数据通过副本提供冗余保护，自动故障探测和管理，自动同步元数据和业务数据。提供图形化工具，以简化管理员对数据库的管理工作；</p><p>7) 高并发：读写不互斥，支持数据的边加载边查询，单个节点并发能力大于 300 用户；</p><p>8) 行列混合存储：提供行列混合存储方案，从而提高了列存数据库特殊查询场景的查询响应耗时；</p><p>9) 标准化：支持SQL92 标准，支持 C API、ODBC、JDBC、ADO.NET 等接口规范。</p><h3 id="8、-常见MPPDB"><a href="#8、-常见MPPDB" class="headerlink" title="8、 常见MPPDB"></a>8、 常见MPPDB</h3><p>● GREENPLUM(EMC)</p><p>● Asterdata(Teradata)</p><p>● Nettezza(IBM)</p><p>● Vertica(HP)</p><p>● GBase 8a MPP cluster(南大通用)</p><h3 id="9、-MPPDB、Hadoop与传统数据库技术对比与适用场景"><a href="#9、-MPPDB、Hadoop与传统数据库技术对比与适用场景" class="headerlink" title="9、 MPPDB、Hadoop与传统数据库技术对比与适用场景"></a>9、 MPPDB、Hadoop与传统数据库技术对比与适用场景</h3><p>MPPDB与Hadoop都是将运算分布到节点中独立运算后进行结果合并(分布式计算)，但由于依据的理论和采用的技术路线不同而有各自的优缺点和适用范围。两种技术以及传统数据库技术的对比如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/19/5d3189cc48dc124520.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>综合而言，Hadoop和MPP两种技术的特定和适用场景为：</p><p>● Hadoop在处理非结构化和半结构化数据上具备优势，尤其适合海量数据批处理等应用要求。</p><p>● MPP适合替代现有关系数据机构下的大数据处理，具有较高的效率。</p><p>MPP适合多维度数据自助分析、数据集市等；Hadoop适合海量数据存储查询、批量数据ETL、非机构化数据分析(日志分析、文本分析)等。</p><p>由上述对比可预见未来大数据存储与处理趋势：MPPDB+Hadoop混搭使用，用MPP处理PB级别的、高质量的结构化数据，同时为应用提供丰富的SQL和事物支持能力；用Hadoop实现半结构化、非结构化数据处理。这样可以同时满足结构化、半结构化和非结构化数据的高效处理需求。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20180607153301340?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTg5MDgz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt title>                </div>                <div class="image-caption"></div>            </figure><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a>﻿<br><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a>﻿﻿</p></blockquote><p>—﻿</p><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong>﻿</p><p><img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>﻿﻿</p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;实践一门技术的最好方式就是深入理解它的思想，然后造一个出来！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1、-什么是MPP？&quot;&gt;&lt;a href=&quot;#1、-什么是MPP？&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="数据库" scheme="https://lywlefan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://lywlefan.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MBPP" scheme="https://lywlefan.github.io/tags/MBPP/"/>
    
  </entry>
  
  <entry>
    <title>理财书籍收集</title>
    <link href="https://lywlefan.github.io/2019/07/18/%E8%AF%BB%E4%B9%A6/%E6%94%B6%E9%9B%86/%E7%90%86%E8%B4%A2%E4%B9%A6%E7%B1%8D%E6%94%B6%E9%9B%86/%E7%90%86%E8%B4%A2%E4%B9%A6%E7%B1%8D%E6%94%B6%E9%9B%86/"/>
    <id>https://lywlefan.github.io/2019/07/18/读书/收集/理财书籍收集/理财书籍收集/</id>
    <published>2019-07-17T16:00:00.000Z</published>
    <updated>2019-07-18T03:35:38.802Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>多读书，多看报，少吃零食，少睡觉！</p></blockquote><h2 id="理财书籍汇集"><a href="#理财书籍汇集" class="headerlink" title="理财书籍汇集"></a>理财书籍汇集</h2><h3 id="未读"><a href="#未读" class="headerlink" title="未读"></a>未读</h3><ul><li><p>《谁动了我的奶酪》 </p></li><li><p>《小狗钱钱》</p></li><li><p>《富爸爸，穷爸爸》，《财务自由之路》和《投资指南》 </p></li><li><p>《一分钟百万富翁》 </p></li><li><p>《怎样启迪你头脑中的金融意识》 </p></li><li><p>《财源滚滚》</p></li><li><p>《钻石就在你家后院》</p></li><li><p>《我的百万富翁兄弟》</p></li></ul><h3 id="已读"><a href="#已读" class="headerlink" title="已读"></a>已读</h3><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a><br><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;多读书，多看报，少吃零食，少睡觉！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;理财书籍汇集&quot;&gt;&lt;a href=&quot;#理财书籍汇集&quot; class=&quot;headerlink&quot; title=&quot;理财书籍汇集&quot;&gt;&lt;/a&gt;理财书籍汇集&lt;/h2&gt;&lt;h3 i
      
    
    </summary>
    
      <category term="读书" scheme="https://lywlefan.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="读书" scheme="https://lywlefan.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="收集" scheme="https://lywlefan.github.io/tags/%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>财务词汇</title>
    <link href="https://lywlefan.github.io/2019/07/11/%E8%AF%8D%E6%B1%87/%E8%B4%A2%E5%8A%A1/%E8%B4%A2%E5%8A%A1%E8%AF%8D%E6%B1%87/"/>
    <id>https://lywlefan.github.io/2019/07/11/词汇/财务/财务词汇/</id>
    <published>2019-07-10T16:00:00.000Z</published>
    <updated>2019-07-19T09:50:08.629Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>先有词汇量,然后再能好好说话,好好做事。</p></blockquote><ul><li><p>重要</p></li><li><p>不重要</p></li><li><p>理解</p></li><li><p>未理解</p></li></ul><h2 id="2019年"><a href="#2019年" class="headerlink" title="2019年"></a>2019年</h2><h3 id="7月份词汇"><a href="#7月份词汇" class="headerlink" title="7月份词汇"></a>7月份词汇</h3><h4 id="重要理解词汇"><a href="#重要理解词汇" class="headerlink" title="重要理解词汇"></a>重要理解词汇</h4><ul><li>资产</li></ul><blockquote><p>G:如何获得资产？<br>a.加杠杆购买资产，产生源源不断的现金流<br>b.花时间创造资产</p></blockquote><ul><li><p>负债</p></li><li><p>现值</p></li></ul><p>是在给定的利率水平下，未来的资金折现到现在时刻的价值。</p><ul><li><p>现金流</p><ul><li><p>经营性现金流</p></li><li><p>投资性现金流</p></li><li><p>融资性现金流</p></li></ul></li><li><p>资产负债表</p></li><li><p>损益表</p></li><li><p>所有者权益变动表</p></li><li><p>财务报表附注</p></li><li><p>审查报表</p></li><li><p>预算盈余</p></li><li><p>净现值法（NPV）</p><ul><li><p>净现值</p><p>未来资金流现值与未来资金流出现值差额。</p></li></ul></li><li><p>折现率</p></li></ul><p>折现率是指将未来有限期预期收益折算成现值的比率。</p><ul><li>内部收益率（IRR）</li></ul><h4 id="不重要理解词汇"><a href="#不重要理解词汇" class="headerlink" title="不重要理解词汇"></a>不重要理解词汇</h4><ul><li><p>直线法折旧</p></li><li><p>双倍余额递减法折旧（年折旧率=2÷预计的折旧年限×100％）</p></li></ul><h4 id="重要不理解词汇"><a href="#重要不理解词汇" class="headerlink" title="重要不理解词汇"></a>重要不理解词汇</h4><h4 id="不重要不理解词汇"><a href="#不重要不理解词汇" class="headerlink" title="不重要不理解词汇"></a>不重要不理解词汇</h4><ul><li><p>借款人</p></li><li><p>信贷人员</p></li><li><p>银行流水</p></li></ul><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a><br><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;先有词汇量,然后再能好好说话,好好做事。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;重要&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不重要&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;理解&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;未理解&lt;/p&gt;
&lt;/li
      
    
    </summary>
    
      <category term="词汇" scheme="https://lywlefan.github.io/categories/%E8%AF%8D%E6%B1%87/"/>
    
    
      <category term="词汇" scheme="https://lywlefan.github.io/tags/%E8%AF%8D%E6%B1%87/"/>
    
      <category term="财务" scheme="https://lywlefan.github.io/tags/%E8%B4%A2%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>如果你不愿自己去学习和提升，生活会慢慢教会你！</title>
    <link href="https://lywlefan.github.io/2019/07/11/%E6%80%9D%E8%80%83/2019/7/%E5%A6%82%E6%9E%9C%E4%BD%A0%E4%B8%8D%E6%84%BF%E8%87%AA%E5%B7%B1%E5%8E%BB%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%8F%90%E5%8D%87%EF%BC%8C%E7%94%9F%E6%B4%BB%E4%BC%9A%E6%85%A2%E6%85%A2%E6%95%99%E4%BC%9A%E4%BD%A0%EF%BC%81/"/>
    <id>https://lywlefan.github.io/2019/07/11/思考/2019/7/如果你不愿自己去学习和提升，生活会慢慢教会你！/</id>
    <published>2019-07-10T16:00:00.000Z</published>
    <updated>2019-07-19T10:19:11.863Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在实践中思考感悟,在思考感悟后实践,一切伟大源于不断的思考和实践。</p></blockquote><h3 id="开篇语"><a href="#开篇语" class="headerlink" title="开篇语"></a>开篇语</h3><p>在这个偌大的世界里，我们的家教和我们的环境决定了我们的认知和格局,家庭出身我们没得选,更多的应该是感恩和爱,上天赐予我们亲爱的父母亲,他们默默无私不求回报,每每想起总让人热泪盈眶,这是世界上最伟大的爱,没有之一。</p><p>但是,成年后的我们的思维格局由我们自己决定,你愿不愿意正视自己,正视以前那个傻傻的自己,洗礼自己的一些思想,革新骨子里的各种观念。我相信,你会选择去改变,因为你有梦想。</p><p>上周听了一位财商老师的课,在课上有位50多岁的大叔问了怎么每年赚100万的问题。</p><p>老师说为什么要转一百万?</p><p>大叔说,我还有梦想,我现在每天摆地摊,我起早贪黑,我不怕苦不怕累。</p><p>老师沉默了许久,然后说我建议你不要有梦想,人生是短暂的,大半辈子已经过去了,你开开心心陪家人过完余生也是一种莫大的幸福,梦想这件事很痛,我怕你承受不起。</p><p>听到这里,我内心就像是被猛击了一下,趁着年轻放手去做自己喜欢的事,去追逐自己的梦想,做历练自己,有些事年轻的时候不学会,老了,没有力气了,生活会慢慢教你,会让你痛不欲生,因为这就是你年轻时的选择!</p><h4 id="是不是每次都说自己没钱-是不是想尽办法去赚钱到头却发现花的总比赚的多"><a href="#是不是每次都说自己没钱-是不是想尽办法去赚钱到头却发现花的总比赚的多" class="headerlink" title="是不是每次都说自己没钱,是不是想尽办法去赚钱到头却发现花的总比赚的多"></a>是不是每次都说自己没钱,是不是想尽办法去赚钱到头却发现花的总比赚的多</h4><p>一次无意的刷快手,听了零首付买房,花了298,抱着学习的态度去听了这堂财商课。虽然演讲的老师讲的有点浮夸,但他说的道理,说的思想却极大的震撼了我的内心,让我明白一个人穷不是没钱而是思想上的贫穷,见识上的贫穷,观念上的贫穷,知识上的贫穷。</p><p>时代的发展会把机会摆在每个人的面前,谁能抓住这些机会?谁能牢牢的握住它?谁能把这个机会发挥出巨大的价值?这跟什么有关系?</p><p>究其原因,我个人认为把握机会的前提是能看到机会,能理解这种机会,没有这种意识和格局,别人说你都听不懂,可能还会说人家是骗子,若干年过去后却发现自己是傻逼。</p><p>每一次革新中,都有巨大的机会存在,人口红利必然会导致房屋需求增加,城镇化发展会不断加速,谁能看到,在合适的时机把握机会,时代会把你推向浪潮之巅,抓不住又是为什么???</p><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a><br><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在实践中思考感悟,在思考感悟后实践,一切伟大源于不断的思考和实践。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;开篇语&quot;&gt;&lt;a href=&quot;#开篇语&quot; class=&quot;headerlink&quot; title=&quot;开篇语&quot;&gt;&lt;/a&gt;开篇语&lt;/h3&gt;&lt;
      
    
    </summary>
    
      <category term="思考" scheme="https://lywlefan.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
      <category term="思考" scheme="https://lywlefan.github.io/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="2019年" scheme="https://lywlefan.github.io/tags/2019%E5%B9%B4/"/>
    
      <category term="7月" scheme="https://lywlefan.github.io/tags/7%E6%9C%88/"/>
    
      <category term="生活" scheme="https://lywlefan.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>02.Java内存模型：看Java如何解决可见性和有序性问题</title>
    <link href="https://lywlefan.github.io/2019/07/03/%E9%AB%98%E5%B9%B6%E5%8F%91/%E4%B9%A6%E7%B1%8D/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98-%E7%8E%8B%E5%AE%9D%E4%BB%A4/02.Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%9A%E7%9C%8BJava%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98%20/"/>
    <id>https://lywlefan.github.io/2019/07/03/高并发/书籍/java并发编程实战-王宝令/02.Java内存模型：看Java如何解决可见性和有序性问题 /</id>
    <published>2019-07-02T16:00:00.000Z</published>
    <updated>2019-07-09T08:54:15.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h2><ul><li><p>java内存模型</p></li><li><p>volatile</p></li><li><p>Happens-Before规则</p></li></ul><h3 id="什么是java内存模型？"><a href="#什么是java内存模型？" class="headerlink" title="什么是java内存模型？"></a>什么是java内存模型？</h3><p>java内存模型说的直白一点就是java程序使用内存的规范，让java语言在各种系统和平台中能保持数据的一致性。</p><h4 id="Happens-Before规则（6项规则）"><a href="#Happens-Before规则（6项规则）" class="headerlink" title="Happens-Before规则（6项规则）"></a>Happens-Before规则（6项规则）</h4><p>前一个操作对后一个操作是可见的。假如有一个公有变量，a方法先引用然后b方法再引用，那么我们称a方法的操作对b方法可见。</p><h5 id="程序顺序性规则"><a href="#程序顺序性规则" class="headerlink" title="程序顺序性规则"></a>程序顺序性规则</h5><p>假如有一个公有变量，a方法先引用然后b方法再引用，那么我们称a方法的操作对b方法可见。</p><h5 id="volatile变量规则"><a href="#volatile变量规则" class="headerlink" title="volatile变量规则"></a>volatile变量规则</h5><p>volatile变量的写操作对volatile变量读操作可见。说白了读之前，我要知道是谁写的，不然我不读。</p><h5 id="传递性"><a href="#传递性" class="headerlink" title="传递性"></a>传递性</h5><p>如果A对B可见，B对C可见，那么A对C可见。</p><h5 id="管程中锁的规则"><a href="#管程中锁的规则" class="headerlink" title="管程中锁的规则"></a>管程中锁的规则</h5><p>管程是一种通用的同步原语，在java中指的是synchronized,synchronized是java里对管程的实现。</p><p>对变量进行加锁，执行完再继续。</p><h5 id="线程smart-规则"><a href="#线程smart-规则" class="headerlink" title="线程smart()规则"></a>线程smart()规则</h5><p>它是指主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作。</p><blockquote><p>G:说白了就是主线程要优于子线程。</p></blockquote><h5 id="线程join-规则"><a href="#线程join-规则" class="headerlink" title="线程join()规则"></a>线程join()规则</h5><h3 id="关键词解析"><a href="#关键词解析" class="headerlink" title="关键词解析"></a>关键词解析</h3><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>这个关键词可以禁用cpu缓存。禁用了cpu缓存，那么我们的变量只能从内存中进行读写。</p><h4 id="Happens-Before规则"><a href="#Happens-Before规则" class="headerlink" title="Happens-Before规则"></a>Happens-Before规则</h4><p>Happens-Before规则说白了就是定义java内存模型的一种约束或者规则。</p><blockquote><p>推荐书单</p></blockquote><p>-《Java并发编程实战》作者阵容可谓大师云集，也包括Doug Lea</p><p>-《Java并发编程的艺术》讲解并发包内部实现原理，能读明白，内功大增</p><p>-《图解Java多线程设计模式》并发编程设计模式方面的经典书籍</p><p>-《操作系统：精髓与设计原理》经典操作系统教材</p><ul><li><p><a href="http://ifeve.com" target="_blank" rel="noopener">http://ifeve.com</a> 国内专业并发编程网站</p></li><li><p><a href="http://www.cs.umd.edu/~pugh/java/memoryModel/" target="_blank" rel="noopener">http://www.cs.umd.edu/~pugh/java/memoryModel/</a> 很多并发编程的早期资料都在这里</p></li></ul><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a></p></blockquote><blockquote><p><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;阅读笔记&quot;&gt;&lt;a href=&quot;#阅读笔记&quot; class=&quot;headerlink&quot; title=&quot;阅读笔记&quot;&gt;&lt;/a&gt;阅读笔记&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;java内存模型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;volatile&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;H
      
    
    </summary>
    
      <category term="高并发" scheme="https://lywlefan.github.io/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://lywlefan.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="读书笔记" scheme="https://lywlefan.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java并发编程实战-王宝令" scheme="https://lywlefan.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98-%E7%8E%8B%E5%AE%9D%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>学习攻略.如何才能学好并发编程？</title>
    <link href="https://lywlefan.github.io/2019/07/02/%E9%AB%98%E5%B9%B6%E5%8F%91/%E4%B9%A6%E7%B1%8D/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98-%E7%8E%8B%E5%AE%9D%E4%BB%A4/%E5%AD%A6%E4%B9%A0%E6%94%BB%E7%95%A5.%E5%A6%82%E4%BD%95%E6%89%8D%E8%83%BD%E5%AD%A6%E5%A5%BD%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9F/"/>
    <id>https://lywlefan.github.io/2019/07/02/高并发/书籍/java并发编程实战-王宝令/学习攻略.如何才能学好并发编程？/</id>
    <published>2019-07-01T16:00:00.000Z</published>
    <updated>2019-07-02T09:23:11.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h2><p>并发是一门独立学科也是一门综合科学，从两个方面突破并发编程：</p><ul><li><p>跳出来，看全景</p></li><li><p>钻进去，看本质</p></li></ul><h3 id="跳出来，看全景"><a href="#跳出来，看全景" class="headerlink" title="跳出来，看全景"></a>跳出来，看全景</h3><p>学习最忌讳的就是“盲人摸象”，只看到局部，没有全局。从单一知识点跳出来，高屋建瓴看并发编程，首要之事就是建立一张全景图。</p><h4 id="并发核心问题"><a href="#并发核心问题" class="headerlink" title="并发核心问题"></a>并发核心问题</h4><h5 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h5><p>像做项目的分工一样，不同的工作分给不同的人，实现工作效率最大化。</p><p>在学习抽象的东西的时候要多与现实生活中的场景进行类比。</p><p>Java SDK 并发包里的 Executor、Fork/Join、Future本质上都是一种分工的方式。</p><p>并发编程领域还总结了一些设计模式，基本上都是和分工方法相关的，例如生产者 - 消费者、Message、Worker Thread 模式等。</p><h5 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h5><p>同步就相当于项目中的沟通协调，什么时间干什么工作。</p><p>放到软件程序中就是一个线程执行完，通知下一个线程执行而已。例如，用 Future 可以发起一个异步调用，当主线程通过 get() 方法取结果时，主线程就会等待，当异步执行的结果返回时，get() 方法就自动返回了，这就解决了我们主从线程的协作。</p><p>Java SDK 里提供的 CountDownLatch、CyclicBarrierr、Phaser、Exchanger 也都是用来解决线程协作问题的。</p><p>还有很多场景，是需要你自己来处理线程之间的协作。</p><p>在java并发编程领域，解决协作问题的核心就是<strong>管程</strong>，上面提到的所有线程协作技术底层都是利用管程解决的。管程是一种解决并发问题的通用模型，除了能解决线程协助问题，还能解决下面我们将要介绍的互斥问题。可以这么说，<strong>管程是解决并发问题的万能钥匙</strong>。</p><p>关键是理解管程模型，学好它就可以解决所有问题。</p><p>其次是了解java JDK并发包提供的几个线程协作的工具类场景，用好它们可以妥妥地提高你的工作效率。</p><h5 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h5><p>分工/同步主要强调性能，但是并发程序里还有一部分是关于正确性，用专业术语叫“线程安全”。</p><ul><li><p>可见性问题</p></li><li><p>有序性问题</p></li><li><p>原子性问题</p></li></ul><p>为了解决以上三个问题，java语言引入了内存模型，内存模型提供了一系列的规则，利用这些规则，我们可以避免以上问题。</p><p><strong>所谓互斥，指的是同一时刻，只允许一个线程访问共享变量。</strong></p><p>实现互斥的核心技术是锁，java语言里synchronized、SDK里各种Lock都能解决互斥问题。</p><p>虽说锁解决了安全性问题，但同时也带来了性能问题，那如何保证安全性的同时又尽量提高性能那？分场景优化：</p><ul><li><p>Java SDK 里提供的 ReadWriteLock、StampedLock 就可以优化读多写少场景下锁的性能。</p></li><li><p>还可以使用无锁的数据结构，例如 Java SDK 里提供的原子类都是基于无锁技术实现的。</p></li></ul><p>除此之外，还有一些其他的方案，原理是不共享变量或者变量只允许许读。这方面，Java 提供了Thread Local 和 final 关键字，还有一种 Copy-on-write 的模式。</p><p>使用锁除了要注意性能问题外，还需要注意死锁问题。</p><p>这部分内容比较复杂，往往还是跨领域的，例如要理解可见性，就需要了解一些 CPU 和缓存的知识；</p><p>很多无锁算法的实现往往也需要理解 CPU 缓存。</p><p>这部分内容的学习，需要博览群书，在大脑里建立起 CPU、内存、I/O 执行的模拟器。</p><p>全景图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/3084894-e4dba3439c48d077.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="钻进去，看本质"><a href="#钻进去，看本质" class="headerlink" title="钻进去，看本质"></a>钻进去，看本质</h3><p>深入理解，找到本质。</p><p>多分析这些概念和结论是怎么来的？？</p><p>它们是用来解决什么问题的？</p><p>知其然知其所以然。</p><p>工程上解决问题，一定要有理论做基础。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>推荐书单</p></blockquote><p>-《Java并发编程实战》作者阵容可谓大师云集，也包括Doug Lea</p><p>-《Java并发编程的艺术》讲解并发包内部实现原理，能读明白，内功大增</p><p>-《图解Java多线程设计模式》并发编程设计模式方面的经典书籍</p><p>-《操作系统：精髓与设计原理》经典操作系统教材</p><ul><li><p><a href="http://ifeve.com" target="_blank" rel="noopener">http://ifeve.com</a> 国内专业并发编程网站</p></li><li><p><a href="http://www.cs.umd.edu/~pugh/java/memoryModel/" target="_blank" rel="noopener">http://www.cs.umd.edu/~pugh/java/memoryModel/</a> 很多并发编程的早期资料都在这里</p></li></ul><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a></p></blockquote><blockquote><p><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;阅读笔记&quot;&gt;&lt;a href=&quot;#阅读笔记&quot; class=&quot;headerlink&quot; title=&quot;阅读笔记&quot;&gt;&lt;/a&gt;阅读笔记&lt;/h2&gt;&lt;p&gt;并发是一门独立学科也是一门综合科学，从两个方面突破并发编程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;跳出来，看全景&lt;/p&gt;
&lt;/l
      
    
    </summary>
    
      <category term="高并发" scheme="https://lywlefan.github.io/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://lywlefan.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="读书笔记" scheme="https://lywlefan.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java并发编程实战-王宝令" scheme="https://lywlefan.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98-%E7%8E%8B%E5%AE%9D%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>01.可见性、原子性和有序性问题：并发编程Bug的源头</title>
    <link href="https://lywlefan.github.io/2019/07/02/%E9%AB%98%E5%B9%B6%E5%8F%91/%E4%B9%A6%E7%B1%8D/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98-%E7%8E%8B%E5%AE%9D%E4%BB%A4/01.%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8BBug%E7%9A%84%E6%BA%90%E5%A4%B4%20/"/>
    <id>https://lywlefan.github.io/2019/07/02/高并发/书籍/java并发编程实战-王宝令/01.可见性、原子性和有序性问题：并发编程Bug的源头 /</id>
    <published>2019-07-01T16:00:00.000Z</published>
    <updated>2019-07-09T07:47:35.382Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h2><ul><li><p>可见性</p></li><li><p>原子性</p></li><li><p>有序性</p></li></ul><h3 id="并发幕后的故事"><a href="#并发幕后的故事" class="headerlink" title="并发幕后的故事"></a>并发幕后的故事</h3><p>这些年，我们的 CPU、内存、I/O 设备都在不断迭代，不断朝着更快的方向努力。但是，在这个快速发展的过程中，<strong>有一个核心矛盾一直存在，就是这三者的速度差异</strong>。</p><p>CPU和内存速度差异可以形象描述:CPU是天上一天，内存是地上一年。内存和I/O设备速度差异就更大了，内存是天山一天，I/O设备是地上十年。</p><p>大部分程序是需要访问内存，有些还要访问I/O,所以单方面提高CPU性能是无效的。</p><p>为了合理利用CPU高性能，平衡三者的速度差异，计算机体系/操作系统/编译程序都做了很大的贡献，主要体现在以下几点：</p><ul><li><p>CPU增加了缓存，以均衡速度差异</p></li><li><p>操作系统增加了进程/线程，以分时复用CPU，进而均衡CPU与I/O设备的速度差异；</p></li><li><p>编译程序优化指令执行次序，使得缓存能够更加合理的利用。</p></li></ul><h3 id="源头之一：缓存导致的可见性问题"><a href="#源头之一：缓存导致的可见性问题" class="headerlink" title="源头之一：缓存导致的可见性问题"></a>源头之一：缓存导致的可见性问题</h3><h4 id="单核时代"><a href="#单核时代" class="headerlink" title="单核时代"></a>单核时代</h4><p>单核时代，所有线程在一颗CPU上执行，CPU缓存与内存的数据一致性容易解决。</p><p>一个线程对CPU的操作，其他线程都是可见的。</p><p>如下图所示，线程A和线程B都是操作同一个CPU里面的缓存，线程A操作CPU变量V之后，线程B再访问就一定可以得到最新值：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/3084894-daaffaf66a9ac336.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure><p>一个线程对共享变量的修改，另外一个线程立刻看到，我们称为<strong>可见性</strong>。</p><h4 id="多核时代"><a href="#多核时代" class="headerlink" title="多核时代"></a>多核时代</h4><p>多核时代，每颗 CPU 都有自己的缓存，这时 CPU 缓存与内存的数据一致性就没那么容易解决了。</p><p>当多个线程在不同的 CPU 上执行时，这些线程操作的是不同的CPU。</p><p>线程 A 操作的是 CPU-1 上的缓存，而线程B操作的是 CPU-2 上的缓存，很明显，这个时候线程 A 对变量 V 的操作对于线程B 而言就不具备可见性了。这个就属于硬件程序员给软件程序员挖的“坑”。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/3084894-e90b1d6bad3f4d22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多核 CPU 的缓存与内存关系图" title>                </div>                <div class="image-caption">多核 CPU 的缓存与内存关系图</div>            </figure><p>下面我们再用一段代码来验证一下多核场景下的可见性问题。下面的代码，每执行一次 add10K() 方法，都会循环 10000 次 count+=1 操作。在 calc() 方法中我们创建了两个线程，每个线程调用一次 add10K() 方法，我们来想一想执行 calc() 方法得到的结果应该是多少呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add10K</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(idx++ &lt; <span class="number">10000</span>) &#123;</span><br><span class="line">      count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">    <span class="comment">// 创建两个线程，执行 add() 操作</span></span><br><span class="line">    Thread th1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      test.add10K();</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread th2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      test.add10K();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 启动两个线程</span></span><br><span class="line">    th1.start();</span><br><span class="line">    th2.start();</span><br><span class="line">    <span class="comment">// 等待两个线程执行结束</span></span><br><span class="line">    th1.join();</span><br><span class="line">    th2.join();</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直觉可能告诉你应该是20000，但实际结果确实10000到20000之间的随机数。为什么那？因为两个线程在两cpu的核之间不断切换才导致的。</p><blockquote><p>G:所谓可见性问题，说白了可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值同时可以操作这个值。</p></blockquote><h3 id="源头之二：线程切换带来的原子性问题"><a href="#源头之二：线程切换带来的原子性问题" class="headerlink" title="源头之二：线程切换带来的原子性问题"></a>源头之二：线程切换带来的原子性问题</h3><ul><li><p>关键词：</p><ul><li><p>线程切换</p></li><li><p>时间片</p></li><li><p>多进程</p></li><li><p>unix操作系统支持多进程分时复用而名噪天下</p></li><li><p>内存映射</p></li><li><p>一个进程创建的所有线程共享同一个内存空间</p></li><li><p>提到的“任务切换”都是指“线程切换”</p></li><li><p>高级语句里一条语句需要多条CPU指令来完成</p><p>  比如：count + =1，需要以下几个指令来完成</p><ul><li><p>指令一：把count从内存加载到cpu寄存器中</p></li><li><p>指令二：在寄存器执行+1操作</p></li><li><p>指令三：最后，将结果写入内存（缓存机制导致可能写入的是CPU缓存而不是内存）</p></li></ul></li></ul></li><li><p>重点语句</p><ul><li>我们把一个或多个操作在CPU执行的过程中不被中断的特性称为原子性。</li></ul></li></ul><h3 id="源头之三：编译优化带来的有序性问题"><a href="#源头之三：编译优化带来的有序性问题" class="headerlink" title="源头之三：编译优化带来的有序性问题"></a>源头之三：编译优化带来的有序性问题</h3><ul><li><p>关键词</p><p>  -</p></li><li><p>关键语句</p><ul><li>有序性：代码按先后顺序执行</li></ul></li><li><p>案例分析</p><ul><li><p>利用双重检查创建单例对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">          instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，假设有两个线程同时判断instance为null—&gt;此时A和B任意一个线程加锁成功（假设是A）,另外一个线程处于等待状态（假设是B）—&gt;线程A创建实例释放锁，然后唤醒B —&gt; B继续加锁，结果实力不为空，B不创建实例</p><p>以上逻辑看似无懈可击，但实际并不完美，问题出在哪里？？</p><p>出在new操作上</p><p>我们以为的new操作：</p><ul><li><p>1.分配一块内存M</p></li><li><p>2.在内存M上初始化Singleton对象</p></li><li><p>3.然后M的地址赋值给instance对象</p></li></ul><p>实际优化后如下：</p><ul><li><p>1.分配一块内存M</p></li><li><p>2.将M的地址赋值给instanc变量</p></li><li><p>3.最后在M上初始化Singleton对象</p></li></ul><p>优化后会导致什么问题那？假设A先执行getInstance()方法，当执行完指令2后恰好发生了线程切换，切换到线程B上；如果此时线程B也执行getInstance方法，那么线程B在执行第一个判断时会发现instance！=null，所以直接返回instance，而此时的instance是没有初始化过的，如果这个时候访问instance的成员变量就可能触发空指针异常。</p></li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>要想写好并发，就要知道并发问题出在哪里</p></li><li><p>只要我们能够深刻理解可见性/原子性/有序性在并发场景下的原理，很多并发bug都可以理解，可以诊断。</p></li><li><p>缓存导致可见性问题</p></li><li><p>线程切换带来的原子性问题</p></li><li><p>编译优化带来的有序性问题</p></li><li><p>在采用一项技术的时候一定要清楚它带来的问题是啥，以及如何规避</p></li></ul><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul><li>1.常听人说，在 32 位的机器上对 long 型变量进行加减操操作存在并发隐患，到底是不是这样呢？</li></ul><p>long类型64位，所以在32位的机器上，对long类型的数据操作通常需要多条指令组合出来，无法保证原子性，所以并发的时候会出问题        </p><blockquote><p>疑问：什么是32位机器？指的是啥？</p></blockquote><p>cpu运算的数据都是由内存提供的，内存与cpu的通信速度靠的是外部频率（所谓外频指的是cpu与外部组件进行数据传输/运算是的速度，倍频则是cpu内部用来加速工作性能的一个倍数，两者相乘才是cpu的频率），每次工作可以传输的数据量大小是由总线决定的。一般主板芯片组分为北桥与南桥，北桥的总线称为系统总线，因为是内存传输的主要信道，所以速度较快；南桥就是所谓的输入输出（I/O）总线，主要用于联系硬盘、usb、网卡等接口设备。</p><p>北桥所支持的频率我们称之为前端总线速度（Front Side Bus,FSB），而每次传输的位数则是总线宽度。所以总线频宽 = FSB x 总线宽度，也就是每秒钟可传送的最大数据量，目前常见的总线宽度有32为和64位。</p><p>例如前端总线的最高速度可达1600MHZ。我们看到内存和北桥的频宽为12.8GB/S，也就是1600MHZ x 64Bit =1600MHZ x 8Bytes = 12800MHZ = 12.8GB/S。</p><p>与总线宽度相似，cpu每次能处理的数据量称为字组大小，字组大小依据cpu的设计而有32位与64位。我们现在所称的计算机是32位或64位主要依据cpu解析的字组大小而来的！早期的32位cpu中，因为cpu每次能够解析的数据量有限，因此由内存传来的数据量就有所限制了。这也导致32位的cpu最多只能支持最大到4GB的内存。</p><blockquote><p>推荐书单</p></blockquote><p>-《Java并发编程实战》作者阵容可谓大师云集，也包括Doug Lea</p><p>-《Java并发编程的艺术》讲解并发包内部实现原理，能读明白，内功大增</p><p>-《图解Java多线程设计模式》并发编程设计模式方面的经典书籍</p><p>-《操作系统：精髓与设计原理》经典操作系统教材</p><ul><li><p><a href="http://ifeve.com" target="_blank" rel="noopener">http://ifeve.com</a> 国内专业并发编程网站</p></li><li><p><a href="http://www.cs.umd.edu/~pugh/java/memoryModel/" target="_blank" rel="noopener">http://www.cs.umd.edu/~pugh/java/memoryModel/</a> 很多并发编程的早期资料都在这里</p></li></ul><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a></p></blockquote><blockquote><p><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;阅读笔记&quot;&gt;&lt;a href=&quot;#阅读笔记&quot; class=&quot;headerlink&quot; title=&quot;阅读笔记&quot;&gt;&lt;/a&gt;阅读笔记&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可见性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;原子性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;有序性&lt;/p&gt;
&lt;/l
      
    
    </summary>
    
      <category term="高并发" scheme="https://lywlefan.github.io/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://lywlefan.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="读书笔记" scheme="https://lywlefan.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java并发编程实战-王宝令" scheme="https://lywlefan.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98-%E7%8E%8B%E5%AE%9D%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>12.客户端都有哪些不常见但是很高级的功能？</title>
    <link href="https://lywlefan.github.io/2019/07/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/kafka%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98-%E8%83%A1%E5%A4%95/12.%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%B8%B8%E8%A7%81%E4%BD%86%E6%98%AF%E5%BE%88%E9%AB%98%E7%BA%A7%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%9F/"/>
    <id>https://lywlefan.github.io/2019/07/02/中间件/kafka/读书笔记/kafka核心技术与实战-胡夕/12.客户端都有哪些不常见但是很高级的功能？/</id>
    <published>2019-07-01T16:00:00.000Z</published>
    <updated>2019-07-02T05:47:03.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h2><h3 id="kafka-拦截器"><a href="#kafka-拦截器" class="headerlink" title="kafka 拦截器"></a>kafka 拦截器</h3><p>拦截器的原理和spring的拦截器的原理类似，可以做消息处理前后多个点的动态植入不同的处理逻辑。比如消息发送前或者在消息消费后。</p><p>kafka拦截器分为生产者拦截器和消费者拦截器。</p><p>生产拦截器允许你在发送消息前以及消息提交后植入你的拦截器逻辑；</p><p>消费拦截器支持在消费消息前以及提交位移后编写特定逻辑。</p><p>两种拦截器都支持链的方式，kafka会按序执行拦截器逻辑。</p><p>###如何编写拦截器？</p><ul><li><p>生产者拦截器继承接口ProducerInterceptor</p><ul><li><p>onSend：消息调用前被调用</p></li><li><p>onAcknowledgement：消息提交成功或发送失败后被调用。这个方法要早于callback。这个方法和onSend不是在同一个线程里面调用，因此在两个方法调用过程中调用了某个共享变量，一定要保证线程安全。这个方法处在Producer发送的主路径中，所以我们不要放一些太重逻辑进去，负责你会发现Producer的TPS直线下降。</p></li></ul></li><li><p>消费者拦截器实现ConsumerInterceptor接口</p><ul><li><p>onConsume：在消息返回给Consumer 程序之前调用。也就是在消息开始处理前拦截一道。</p></li><li><p>onCommit：Consumer 在提交位移之后调用该方法。通常你可以在该方法做一些记账类的动作，比如：日志打印。</p></li></ul></li><li><p>注意的问题</p><ul><li>指定拦截器要指定它们全限定名，说的直白一点就是要把包名加上</li></ul></li></ul><h3 id="典型使用场景"><a href="#典型使用场景" class="headerlink" title="典型使用场景"></a>典型使用场景</h3><ul><li>客户端监控</li></ul><p>kafka默认提供的监控指标都是针对单个客户端或Broker的，你很难从具体消息维度去追踪群间消息的流转路径。同时如何监控一条消息从生产到最后消费的端到端延时也是很多kafka用户需要解决的问题。</p><p>从技术上讲，我们可以在客户端增加这样的逻辑，但是监控一般是不跟业务代码耦合的，因为耦合会影响业务代码性能。</p><p>基于以上的考虑，我们可以把监控的逻辑加到拦截器里面，这样做的好处可以实现可插拔，不耦合。    </p><ul><li>端到端性能检测</li></ul><p>同上。</p><ul><li>消息审计</li></ul><p>所谓消息审计就是可以随时查看消息的去向，什么时间发布的？被什么业务消费了？我们就可以借用kafka的拦截器实现这个场景。</p><h3 id="案例分享"><a href="#案例分享" class="headerlink" title="案例分享"></a>案例分享</h3><ul><li>处理端到端的延时</li></ul><p>统计Producer到Consumer消费时间总时长，我们消费拦截器就可以按如下来写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvgLatencyProducerInterceptor</span> <span class="keyword">implements</span> <span class="title">ProducerInterceptor</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Jedis jedis; <span class="comment">// 省略 Jedis 初始化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProducerRecord&lt;String, String&gt; <span class="title">onSend</span><span class="params">(ProducerRecord&lt;String, String&gt; record)</span> </span>&#123;</span><br><span class="line">        jedis.incr(<span class="string">"totalSentMessage"</span>);</span><br><span class="line">        <span class="keyword">return</span> record;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAcknowledgement</span><span class="params">(RecordMetadata metadata, Exception exception)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map&lt;java.lang.String, ?&gt; configs)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面是消费端代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvgLatencyConsumerInterceptor</span> <span class="keyword">implements</span> <span class="title">ConsumerInterceptor</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Jedis jedis; <span class="comment">// 省略 Jedis 初始化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConsumerRecords&lt;String, String&gt; <span class="title">onConsume</span><span class="params">(ConsumerRecords&lt;String, String&gt; records)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> lantency = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">            lantency += (System.currentTimeMillis() - record.timestamp());</span><br><span class="line">        &#125;</span><br><span class="line">        jedis.incrBy(<span class="string">"totalLatency"</span>, lantency);</span><br><span class="line">        <span class="keyword">long</span> totalLatency = Long.parseLong(jedis.get(<span class="string">"totalLatency"</span>));</span><br><span class="line">        <span class="keyword">long</span> totalSentMsgs = Long.parseLong(jedis.get(<span class="string">"totalSentMessage"</span>));</span><br><span class="line">        jedis.set(<span class="string">"avgLatency"</span>, String.valueOf(totalLatency / totalSentMsgs));</span><br><span class="line">        <span class="keyword">return</span> records;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCommit</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map&lt;String, ?&gt; configs)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里我们可以用redis记录消息消费的时间,到redis中我们就可以很好的进行统计了,可以很好的统计到从producer到consumer的时间了。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a></p></blockquote><blockquote><p><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;阅读笔记&quot;&gt;&lt;a href=&quot;#阅读笔记&quot; class=&quot;headerlink&quot; title=&quot;阅读笔记&quot;&gt;&lt;/a&gt;阅读笔记&lt;/h2&gt;&lt;h3 id=&quot;kafka-拦截器&quot;&gt;&lt;a href=&quot;#kafka-拦截器&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="中间件" scheme="https://lywlefan.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="读书笔记" scheme="https://lywlefan.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="kafka" scheme="https://lywlefan.github.io/tags/kafka/"/>
    
      <category term="kafka核心技术与实战-胡夕" scheme="https://lywlefan.github.io/tags/kafka%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98-%E8%83%A1%E5%A4%95/"/>
    
  </entry>
  
  <entry>
    <title>11.无消息丢失配置怎么实现？</title>
    <link href="https://lywlefan.github.io/2019/07/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/kafka%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98-%E8%83%A1%E5%A4%95/11.%E6%97%A0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E9%85%8D%E7%BD%AE%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F/"/>
    <id>https://lywlefan.github.io/2019/07/01/中间件/kafka/读书笔记/kafka核心技术与实战-胡夕/11.无消息丢失配置怎么实现？/</id>
    <published>2019-06-30T16:00:00.000Z</published>
    <updated>2019-07-01T07:43:27.779Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h2><ul><li><p>kafka中什么算消息丢失</p></li><li><p>什么情况下能保证kafka消息不丢失</p></li></ul><p>一句话概括,Kafka只对”已提交”的消息做有限度的持久化保证。</p><h3 id="什么是已提交的消息"><a href="#什么是已提交的消息" class="headerlink" title="什么是已提交的消息?"></a>什么是已提交的消息?</h3><p>当kafka的若干个Broker成功的接收到一条消息并写入到日志文件之后,它们就会告诉生产者程序这条消息已成功提交。此时,这条消息在kafka看来就正式变为”已提交”消息了。</p><p>为什么是若干个Broker?这取决于”已提交”的定义,你可以选择只有一个broker成功保存该消息就算已提交,也可以令所有broker都保存才算已提交.</p><h3 id="有限度的持久化保证"><a href="#有限度的持久化保证" class="headerlink" title="有限度的持久化保证"></a>有限度的持久化保证</h3><p>至少有一个Broker存活,只要这个条件成立,kafka就不会丢消息,但是一个都不会存活的情况是有可能出现的.</p><h4 id="消息丢失的案例"><a href="#消息丢失的案例" class="headerlink" title="消息丢失的案例"></a>消息丢失的案例</h4><p>复盘”kafka消息丢失”案例。</p><h5 id="生产者程序丢失数据"><a href="#生产者程序丢失数据" class="headerlink" title="生产者程序丢失数据"></a>生产者程序丢失数据</h5><p>kafka producer是异步发送消息的,所以说当我们调用完producer.send(msg)这个api后,他通过会立即返回,但是并不代表我们消息发送成功.</p><p>以上发送消息的方式是不靠谱的,建议不要这样去搞,因为这种方式以下原因可能造成消息发送失败:</p><ul><li><p>网络抖动</p></li><li><p>消息本身不合格,Broker不接受</p></li></ul><p>解决以上问题其实有比较好的办法,就是我们Producer永远使用带有回调通知的发送API,也就是说不要使用producer.send(msg),而要使用producer.send(msg,callback),callback会告诉你消息是否处理成功,然后你再根据具体情况进行相应的处理。</p><p>如果因为某些瞬间错误,可以让producer继续重试,总之发送消息失败的责任是producer而不是在broker,当然broker宕机断网除外。</p><h5 id="消费者程序丢失数据"><a href="#消费者程序丢失数据" class="headerlink" title="消费者程序丢失数据"></a>消费者程序丢失数据</h5><p>在kafka消费消息的时候有个”位移”的概念,我们可以把消费消息当做我们读书,而”位移”就相当于”书签”。</p><p>什么情况下消费者程序会存在丢数据的情况哪???</p><p>我们把上面的类比分成两个部分:1.读书 2.移动书签位置</p><p>加入我们先移动书签,再读书就有可能造成消费者丢数据的情况,比如:我们计划读书到100页,然后我们把书签放到100页,当我们读到96页的时候突然有急事出去了,下次继续读的时候就从100页开始了,中间的页我们就没读到。</p><p>针对以上情况,我们应该是先读书然后移动书签的位置。</p><blockquote><p>但是先读书再移动书签会不会造成消息重复消费的情况。</p></blockquote><p>还一种多线程消费的情况,以前我们是一个人读书,现在把一本书10章分给10个人一起读,然后大家读完宣布这本书读完。</p><p>以上这种情况有可能这种异常情况,有部分线程没有读完就更新了位移,这就导致部分消息没有消费,但是响应的确实已经消费了的情况。</p><p>解决以上问题的办法就是:多线程处理消费消息,Consumer程序不要开启自动提交位移,而是要应用程序手动提交位移。</p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul><li><p>使用掉回调的生产消息的方法</p></li><li><p>设置 acks = all。acks 是 Producer的一个参数，代表了你对“已提交”消息的定义。如果设置成 all，则表明所有副本 Broker都要接收到消息，该消息才算是“已提交”。这是最高等级的“已提交”定义。</p></li><li><p>设置 retries 为一个较大的值。这里的 retries 同样是 Producer 的参数，对应前面提到的 Producer 自动重试。当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了 retries &gt; 0 的 Producer 能够自动重试消息发送，避免消息丢失。</p></li><li><p>设置 unclean.leader.election.enable = false。这是 Broker 端的参数，它控制的是哪些 Broker有资格竞选分区的 Leader。如果一个 Broker 落后原先的 Leader 太多，那么它一旦成为新的 Leader，必然会造成消息的丢失。故一般都要将该参数设置成 false，即不允许这种情况的发生。</p></li><li><p>设置 replication.factor &gt;= 3。这也是 Broker 端的参数。其实这里想表述的是，最好将消息多保存几份，毕竟目前防止消息丢失的主要机制就是冗余。</p></li><li><p>设置 min.insync.replicas &gt; 1。这依然是 Broker 端参数，控制的是消息至少要被写入到多少个副本才算是“已提交”。设置成大于 1 可以提升消息持久性。在实际环境中千万不要使用默认值 1。</p></li><li><p>确保 replication.factor&gt; min.insync.replicas。如果两者相等，那么只要有一个副本挂机，整个分区就无法正常工作了。我们不仅要改善消息的持久性，防止数据丢失，还要在不降低可用性的基础上完成。推荐设置成 replication.factor = min.insync.replicas + 1。</p></li><li><p>确保消息消费完成再提交。Consumer 端有个参数 enable.auto.commit，最好把它设置成 false ，并采用手动提交位移的方式。 就像前面说的，这对于单 Consumer 多线程处理的场景而言是至关重要的。</p></li></ul><h3 id="开发讨论"><a href="#开发讨论" class="headerlink" title="开发讨论"></a>开发讨论</h3><p>特别隐秘丢消息的场景:</p><p>当增加主题分区后，在某段“不凑巧”的时间间隔后，Producer 先于 Consumer 感知到新增加的分区，而 Consumer 设置的是“从最新位移处”开始读取消息，因此在 Consumer 感知到新分区前，Producer 发送的这些消息就全部“丢失”了，或者说 Consumer 无法读取到这些消息。Kafka 设计上的一个小缺陷，你有什么解决的办法吗？</p><ul><li><p>cricket1981：consumer改用”从最早位置”读解决新加分区造成的问题</p></li><li><p>明翼：这个问题我想个办法就是程序停止再增加分区，如果不能停止那就找个通知机制了。请教一个问题min.insync.replicas这个参数如果设置成3，假设副本数设置为4，那岂不是只支持一台broker坏掉的情况？</p></li><li><p>作者：能想到的一个简单方法是让consumer端缓存订阅信息，如果发现新的订阅分区出现，手动调整位移到最开始处执行（比如consumer.seekToBeginning）</p></li></ul><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a></p></blockquote><blockquote><p><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;阅读笔记&quot;&gt;&lt;a href=&quot;#阅读笔记&quot; class=&quot;headerlink&quot; title=&quot;阅读笔记&quot;&gt;&lt;/a&gt;阅读笔记&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;kafka中什么算消息丢失&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;什么情况下能保证kafka消息不丢失&lt;/p&gt;
      
    
    </summary>
    
      <category term="中间件" scheme="https://lywlefan.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="读书笔记" scheme="https://lywlefan.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="kafka" scheme="https://lywlefan.github.io/tags/kafka/"/>
    
      <category term="kafka核心技术与实战-胡夕" scheme="https://lywlefan.github.io/tags/kafka%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98-%E8%83%A1%E5%A4%95/"/>
    
  </entry>
  
  <entry>
    <title>10.生产者压缩算法面面观</title>
    <link href="https://lywlefan.github.io/2019/06/28/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/kafka%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98-%E8%83%A1%E5%A4%95/10.%E7%94%9F%E4%BA%A7%E8%80%85%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%E9%9D%A2%E9%9D%A2%E8%A7%82/"/>
    <id>https://lywlefan.github.io/2019/06/28/中间件/kafka/读书笔记/kafka核心技术与实战-胡夕/10.生产者压缩算法面面观/</id>
    <published>2019-06-27T16:00:00.000Z</published>
    <updated>2019-06-28T10:22:40.122Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h2><ul><li><p>消息压缩</p></li><li><p>GZIP</p></li><li><p>Snappy</p></li><li><p>Zero Copy(零拷贝技术)</p></li><li><p>何时压缩</p></li></ul><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><h4 id="压缩算法笔记"><a href="#压缩算法笔记" class="headerlink" title="压缩算法笔记"></a>压缩算法笔记</h4><ul><li><p>GZIP</p></li><li><p>Snappy</p></li><li><p>LZ4</p></li><li><p>Zstandard(zstd):2.1.0开始，facebook开源的压缩算法，能够提高超高性能压缩比。</p></li></ul><h5 id="如何压缩"><a href="#如何压缩" class="headerlink" title="如何压缩"></a>如何压缩</h5><blockquote><p>v1（kafka 0.11.0之前）:message set, message ,v2（kafka 0.11.0以后）:record batch,record</p></blockquote><p>我看了三遍老师的课，得到了我要的答案：<br>1.如果生产者使用了压缩，broker为了crc校验，会启动解压，这个解压过程不可避免；<br>2.v2的broker为了低版本的消费者，会把消息再次解压并进行协议转换。</p><ul><li><p>CRC校验（每条消息执行CRC校验）</p></li><li><p>消息集合</p></li><li><p>消息</p></li><li><p>日志项</p></li></ul><h5 id="看一个压缩算法的指标"><a href="#看一个压缩算法的指标" class="headerlink" title="看一个压缩算法的指标"></a>看一个压缩算法的指标</h5><ul><li>压缩比</li></ul><p>原来占100份空间的东西压缩成20，那么压缩比就是5，显然压缩比越高越好。</p><ul><li>吞吐量(压缩/解压缩)</li></ul><p>每秒能压缩或者解压多少MB数据,同样吞吐量也是越高越好。</p><h5 id="facebook各个压缩算法性能测试"><a href="#facebook各个压缩算法性能测试" class="headerlink" title="facebook各个压缩算法性能测试"></a>facebook各个压缩算法性能测试</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/3084894-0842150408ba26c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png" title>                </div>                <div class="image-caption">1.png</div>            </figure><h5 id="如何选择压缩算法"><a href="#如何选择压缩算法" class="headerlink" title="如何选择压缩算法"></a>如何选择压缩算法</h5><ul><li><p>启用压缩的一个条件就是Producer程序运行机器上的CPU要充足。</p></li><li><p>带宽资源有限建议开启压缩(带宽比cpu和内存还要珍贵)</p></li><li><p>cpu资源富于，建议开启zstd压缩，这样能极大节省网络资源消耗。</p></li><li><p>规避意料之外的解压缩，比如：兼容老版本而引入解压缩</p></li><li><p>有条件尽量保证不要出现消息格式转换的情况</p></li></ul><h3 id="浓缩精华"><a href="#浓缩精华" class="headerlink" title="浓缩精华"></a>浓缩精华</h3><ul><li>Producer端压缩/Broker端保持/Consumer端解压</li></ul><h3 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h3><h4 id="producer和broker端的压缩算法尽量保持一致"><a href="#producer和broker端的压缩算法尽量保持一致" class="headerlink" title="producer和broker端的压缩算法尽量保持一致"></a>producer和broker端的压缩算法尽量保持一致</h4><h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><h4 id="京东小哥建议"><a href="#京东小哥建议" class="headerlink" title="京东小哥建议"></a>京东小哥建议</h4><blockquote><p>去掉因为做消息校验而引入解压缩,据他们称，去掉解压缩后，Broker端CPU使用率至少降低了50%。</p></blockquote><p>社区未采纳建议，原因是消息校验特别重要，不能盲目去掉。</p><h3 id="应用实践"><a href="#应用实践" class="headerlink" title="应用实践"></a>应用实践</h3><h4 id="实时日志收集系统"><a href="#实时日志收集系统" class="headerlink" title="实时日志收集系统"></a>实时日志收集系统</h4><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a></p></blockquote><blockquote><p><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;阅读笔记&quot;&gt;&lt;a href=&quot;#阅读笔记&quot; class=&quot;headerlink&quot; title=&quot;阅读笔记&quot;&gt;&lt;/a&gt;阅读笔记&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;消息压缩&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;GZIP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Snappy&lt;/p
      
    
    </summary>
    
      <category term="中间件" scheme="https://lywlefan.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="读书笔记" scheme="https://lywlefan.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="kafka" scheme="https://lywlefan.github.io/tags/kafka/"/>
    
      <category term="kafka核心技术与实战-胡夕" scheme="https://lywlefan.github.io/tags/kafka%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98-%E8%83%A1%E5%A4%95/"/>
    
  </entry>
  
  <entry>
    <title>09.生产者消息分区机制原理剖析</title>
    <link href="https://lywlefan.github.io/2019/06/28/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/kafka%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98-%E8%83%A1%E5%A4%95/09.%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E6%81%AF%E5%88%86%E5%8C%BA%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    <id>https://lywlefan.github.io/2019/06/28/中间件/kafka/读书笔记/kafka核心技术与实战-胡夕/09.生产者消息分区机制原理剖析/</id>
    <published>2019-06-27T16:00:00.000Z</published>
    <updated>2019-06-28T08:38:14.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h2><h3 id="生产者消息分区机制原理剖析"><a href="#生产者消息分区机制原理剖析" class="headerlink" title="生产者消息分区机制原理剖析"></a>生产者消息分区机制原理剖析</h3><ul><li><p>如何将大的数据均匀的分配到Kafka的各个Broker上？</p></li><li><p>为什么分区？</p></li></ul><h4 id="为什么分区？"><a href="#为什么分区？" class="headerlink" title="为什么分区？"></a>为什么分区？</h4><ul><li><p>三级结构：主题-分区-消息</p></li><li><p>主题下的每条消息只会保存在某一个分区中，而不会在多个分区中被保存多份</p></li></ul><blockquote><p>疑问:为什么kafka要这样设计？有什么好处？</p></blockquote><p><strong>回答</strong>:我们设想一个问题，我们在学校找一个学生，如果我们直接把学生集中在一起去找是不是很麻烦，很低效。换种方式，每50个学生一组，配置一个负责人，然后通知这些负责人去找某个同学，是不是很快就可以找到了，这也就是分区的意义所在。如果，我们把这种思想放到我们的系统中，就可以提高我们系统的负载均衡能力，实现了系统的高伸缩性(Scalability)</p><ul><li>不同的分区能够被放置到不同节点的机器上</li></ul><blockquote><p>疑问：同一个topic下不同的分区是保存到相同机器的不同磁盘上的吗？</p></blockquote><p><strong>回答</strong>:</p><p>在 MongoDB 和 Elasticsearch 中就叫分Shard，而在HBase中则叫Region,在Cassandra中又被称作vnode。</p><ul><li>实现业务级别的消息顺序的问题</li></ul><h5 id="都有哪些分区策略？"><a href="#都有哪些分区策略？" class="headerlink" title="都有哪些分区策略？"></a>都有哪些分区策略？</h5><p>所谓分区策略是决定生产者将消息发送到那个分区的算法。提供了默认的分区策略，同时支持自定义分区策略。</p><ul><li><p>自定义分区</p><ul><li><p>配置partitioner.class参数</p></li><li><p>实现Partitioner接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes, Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster)</span></span>;</span><br></pre></td></tr></table></figure><p>这里的topic、key、keyBytes、value和valueBytes都属于消息数据，cluster则是集群信息(比如当前Kafka集群有多少主题，多少Broker等)。</p></li></ul></li><li><p>策略</p><ul><li><p>轮询策略(Round-robin)</p><p>轮询是kafka默认的消息存储策略，新增的消息会依次进入1/2/3/4/….对应的分区。轮询策略有非常优秀的负载均衡表现，它总能保证消息最大限度地平均分配到所有分区上，故默认情况下它是最合理的分区策略，也是我们常用的分区策略之一。</p></li><li><p>随机策略(Randomness)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line"><span class="keyword">return</span> ThreadLocalRandom.current().nextInt(partitions.size());</span><br><span class="line">``` </span><br><span class="line">实现比较简单，先计算出该主题总的分区数，然后随机地返回一个小于它的正整数。</span><br><span class="line"></span><br><span class="line">该策略是kafka老版本的策略，追求数据均匀分布还是轮询策略比较好。</span><br><span class="line"></span><br><span class="line">- 按消息键保序策略</span><br><span class="line"></span><br><span class="line">    - 同一个消息key的消息进入同一个分区</span><br><span class="line">    </span><br><span class="line">    - 一个分区只能被同一个消费组（ConsumerGroup）内的一个消费者消费</span><br><span class="line">    </span><br><span class="line">    这里我们可以给我们的消息以时间的维度定义key，如此同一时间的消息就进入了同一个分区，同一个分区下的消息也有了顺序性。</span><br><span class="line">    </span><br><span class="line">    - 每个分区消息都是有顺序的</span><br><span class="line">    </span><br><span class="line">    - 代码实现</span><br><span class="line">    </span><br><span class="line">    ```java</span><br><span class="line">    List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line">    <span class="keyword">return</span> Math.abs(key.hashCode()) % partitions.size();</span><br></pre></td></tr></table></figure></li><li><p>其他分区策略(比如：基于地理位置的分区策略)</p><ul><li><p>场景</p><p>公司有两个机房，一个在广州，一个在北京，在每个机房里面抽取部分机器组成kafka集群。现在公司app搞活动，北京新注册的用户送北京烤鸭一只，广州注册的用户送一次大保健，我们如何用kafka实现这一需求？</p></li><li><p>解决方案一</p></li><li><p>解决方案二</p></li></ul></li></ul></li></ul><h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><h3 id="自己提问"><a href="#自己提问" class="headerlink" title="自己提问"></a>自己提问</h3><h4 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h4><blockquote><p>通过kafka创建一个topic，默认分几个区？</p></blockquote><p><strong>回答</strong>：创建topic的时候就需要指定需要创建的分区个数.</p><h4 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h4><blockquote><p>基于地理位置的分区策略可以通过按消息键保序策略实现，这样做有什么意义？</p></blockquote><h3 id="其他人的问题"><a href="#其他人的问题" class="headerlink" title="其他人的问题"></a>其他人的问题</h3><h4 id="问题1-1"><a href="#问题1-1" class="headerlink" title="问题1"></a>问题1</h4><blockquote><p>老师能不能有空能不能讲讲kafka和rocketMQ的对比, 我用下来感觉整体挺像的但是具体使用场景和性能优劣方面还是有点不知道该使用选择, 谢谢.</p></blockquote><p><strong>回答</strong>：在我看来RocketMQ与Kafka的主要区别 ：1. Kafka吞吐量大，多是面向大数据场景。RocketMQ吞吐量也很强， 不过它号称是金融业务级的消息中间件，也就是说可以用于实际的业务系统；2. RocketMQ毕竟是阿里出品，在国内技术支持力度要比Kafka强；3. Kafka现在主要发力Streaming，RocketMQ在流处理这块表现如何我不太清楚，至少streaming不是它现阶段的主要卖点。</p><h4 id="问题2-1"><a href="#问题2-1" class="headerlink" title="问题2"></a>问题2</h4><blockquote><p>kafka的主题只有一级、像mq可以进行主题分层：一级主题、二级主题。kafka为何这样设计？</p></blockquote><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a></p></blockquote><blockquote><p><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;阅读笔记&quot;&gt;&lt;a href=&quot;#阅读笔记&quot; class=&quot;headerlink&quot; title=&quot;阅读笔记&quot;&gt;&lt;/a&gt;阅读笔记&lt;/h2&gt;&lt;h3 id=&quot;生产者消息分区机制原理剖析&quot;&gt;&lt;a href=&quot;#生产者消息分区机制原理剖析&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="中间件" scheme="https://lywlefan.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="读书笔记" scheme="https://lywlefan.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="kafka" scheme="https://lywlefan.github.io/tags/kafka/"/>
    
      <category term="kafka核心技术与实战-胡夕" scheme="https://lywlefan.github.io/tags/kafka%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98-%E8%83%A1%E5%A4%95/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程：CountDownLatch、CyclicBarrier和Semaphore</title>
    <link href="https://lywlefan.github.io/2019/06/27/%E9%AB%98%E5%B9%B6%E5%8F%91/%E5%9F%BA%E7%A1%80/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9ACountDownLatch%E3%80%81CyclicBarrier%E5%92%8CSemaphore/"/>
    <id>https://lywlefan.github.io/2019/06/27/高并发/基础/Java并发编程：CountDownLatch、CyclicBarrier和Semaphore/</id>
    <published>2019-06-26T16:00:00.000Z</published>
    <updated>2019-06-27T09:31:40.159Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>面向对象的语言最好的学习方法就是在实际生活中找一个列子类比。</p></blockquote><ul><li><p>CountDownLatch(计数器)</p></li><li><p>CyclicBarrier(回环栅栏)</p></li><li><p>Semaphore(信号量)</p></li></ul><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>CountDownLatch类位于java.util.concurrent包下，利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。</p><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//count代表计数的个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;; </span><br><span class="line"><span class="comment">//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;; </span><br><span class="line"><span class="comment">//将count值减1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123; &#125;;</span><br></pre></td></tr></table></figure><h4 id="类比理解"><a href="#类比理解" class="headerlink" title="类比理解"></a>类比理解</h4><p>大家在考科目一的时候是如何考的？我们知道车管所的考试机器比考试人数要少很多，假如机器有50个，每次考官让50个人进去，然后再宣布考试开始，其他人继续等待。</p><p>CountDownLatch就可以实现这个效果，我们可以这样做：</p><ul><li><p>CountDownLatch latch=new CountDownLatch(50)</p></li><li><p>进入考场一个学员，我们就latch.countDown()减一</p></li><li><p>到latch为0的时候，考官宣布考试开始，如此而已</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </span><br><span class="line">         <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">          </span><br><span class="line">         <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"执行完毕"</span>);</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;;</span><br><span class="line">         &#125;.start();</span><br><span class="line">          </span><br><span class="line">         <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">                     Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                     System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"执行完毕"</span>);</span><br><span class="line">                     latch.countDown();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;;</span><br><span class="line">         &#125;.start();</span><br><span class="line">          </span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             System.out.println(<span class="string">"等待2个子线程执行完毕..."</span>);</span><br><span class="line">            latch.await();</span><br><span class="line">            System.out.println(<span class="string">"2个子线程已经执行完毕"</span>);</span><br><span class="line">            System.out.println(<span class="string">"继续执行主线程"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">线程Thread-<span class="number">0</span>正在执行</span><br><span class="line">线程Thread-<span class="number">1</span>正在执行</span><br><span class="line">等待<span class="number">2</span>个子线程执行完毕...</span><br><span class="line">线程Thread-<span class="number">0</span>执行完毕</span><br><span class="line">线程Thread-<span class="number">1</span>执行完毕</span><br><span class="line"><span class="number">2</span>个子线程已经执行完毕</span><br><span class="line">继续执行主线程</span><br></pre></td></tr></table></figure><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><h4 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h4><p>字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。我们暂且把这个状态就叫做barrier，当调用await()方法之后，线程就处于barrier了。</p><p>CyclicBarrier类位于java.util.concurrent包下，CyclicBarrier提供2个构造器：</p><h5 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数parties指让多少个线程或者任务等待至barrier状态；参数barrierAction为当这些线程都达到barrier状态时会执行的内容。</p><h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><p>然后CyclicBarrier中最重要的方法就是await方法，它有2个重载版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span><span class="keyword">throws</span> InterruptedException,BrokenBarrierException,TimeoutException </span>&#123; &#125;;</span><br></pre></td></tr></table></figure><p>第一个版本比较常用，用来挂起当前线程，直至所有线程都到达barrier状态再同时执行后续任务；</p><p>第二个版本是让这些线程等待至一定的时间，如果还有线程没有到达barrier状态就直接让到达barrier的线程执行后续任务。</p><h4 id="类比理解-1"><a href="#类比理解-1" class="headerlink" title="类比理解"></a>类比理解</h4><h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><p>假若有若干个线程都要进行写数据操作，并且只有所有线程都完成写数据操作之后，这些线程才能继续做后面的事情，此时就可以利用CyclicBarrier了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">4</span>;</span><br><span class="line">        CyclicBarrier barrier  = <span class="keyword">new</span> CyclicBarrier(N);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">            <span class="keyword">new</span> Writer(barrier).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Writer</span><span class="params">(CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"正在写入数据..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);      <span class="comment">//以睡眠来模拟写入数据操作</span></span><br><span class="line">                System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"写入数据完毕，等待其他线程写入完毕"</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(BrokenBarrierException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"所有线程写入完毕，继续处理其他任务..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">线程Thread-<span class="number">0</span>正在写入数据...</span><br><span class="line">线程Thread-<span class="number">3</span>正在写入数据...</span><br><span class="line">线程Thread-<span class="number">2</span>正在写入数据...</span><br><span class="line">线程Thread-<span class="number">1</span>正在写入数据...</span><br><span class="line">线程Thread-<span class="number">2</span>写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-<span class="number">0</span>写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-<span class="number">3</span>写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-<span class="number">1</span>写入数据完毕，等待其他线程写入完毕</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br></pre></td></tr></table></figure><p>从上面输出结果可以看出，每个写入线程执行完写数据操作之后，就在等待其他线程写入操作完毕。</p><p>当所有线程线程写入操作完毕之后，所有线程就继续进行后续的操作了。</p><h5 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h5><p>如果说想在所有线程写入操作完之后，进行额外的其他操作可以为CyclicBarrier提供Runnable参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">4</span>;</span><br><span class="line">        CyclicBarrier barrier  = <span class="keyword">new</span> CyclicBarrier(N,<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"当前线程"</span>+Thread.currentThread().getName());   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">            <span class="keyword">new</span> Writer(barrier).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Writer</span><span class="params">(CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"正在写入数据..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);      <span class="comment">//以睡眠来模拟写入数据操作</span></span><br><span class="line">                System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"写入数据完毕，等待其他线程写入完毕"</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(BrokenBarrierException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"所有线程写入完毕，继续处理其他任务..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">线程Thread-<span class="number">0</span>正在写入数据...</span><br><span class="line">线程Thread-<span class="number">1</span>正在写入数据...</span><br><span class="line">线程Thread-<span class="number">2</span>正在写入数据...</span><br><span class="line">线程Thread-<span class="number">3</span>正在写入数据...</span><br><span class="line">线程Thread-<span class="number">0</span>写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-<span class="number">1</span>写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-<span class="number">2</span>写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-<span class="number">3</span>写入数据完毕，等待其他线程写入完毕</span><br><span class="line">当前线程Thread-<span class="number">3</span></span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br></pre></td></tr></table></figure><p>从结果可以看出，当四个线程都到达barrier状态后，会从四个线程中选择一个线程去执行Runnable。</p><h5 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h5><p>下面看一下为await指定时间的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">4</span>;</span><br><span class="line">        CyclicBarrier barrier  = <span class="keyword">new</span> CyclicBarrier(N);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;N-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">new</span> Writer(barrier).start();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">new</span> Writer(barrier).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Writer</span><span class="params">(CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"正在写入数据..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);      <span class="comment">//以睡眠来模拟写入数据操作</span></span><br><span class="line">                System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"写入数据完毕，等待其他线程写入完毕"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await(<span class="number">2000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(BrokenBarrierException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"所有线程写入完毕，继续处理其他任务..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">线程Thread-<span class="number">0</span>正在写入数据...</span><br><span class="line">线程Thread-<span class="number">2</span>正在写入数据...</span><br><span class="line">线程Thread-<span class="number">1</span>正在写入数据...</span><br><span class="line">线程Thread-<span class="number">2</span>写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-<span class="number">0</span>写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-<span class="number">1</span>写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-<span class="number">3</span>正在写入数据...</span><br><span class="line">java.util.concurrent.TimeoutException</span><br><span class="line">Thread-<span class="number">1</span>所有线程写入完毕，继续处理其他任务...</span><br><span class="line">Thread-<span class="number">0</span>所有线程写入完毕，继续处理其他任务...</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(Unknown Source)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(Unknown Source)</span><br><span class="line">    at com.cxh.test1.Test$Writer.run(Test.java:<span class="number">58</span>)</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(Unknown Source)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(Unknown Source)</span><br><span class="line">    at com.cxh.test1.Test$Writer.run(Test.java:<span class="number">58</span>)</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(Unknown Source)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(Unknown Source)</span><br><span class="line">    at com.cxh.test1.Test$Writer.run(Test.java:<span class="number">58</span>)</span><br><span class="line">Thread-<span class="number">2</span>所有线程写入完毕，继续处理其他任务...</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">线程Thread-<span class="number">3</span>写入数据完毕，等待其他线程写入完毕</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(Unknown Source)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(Unknown Source)</span><br><span class="line">    at com.cxh.test1.Test$Writer.run(Test.java:<span class="number">58</span>)</span><br><span class="line">Thread-<span class="number">3</span>所有线程写入完毕，继续处理其他任务...</span><br></pre></td></tr></table></figure><p>上面的代码在main方法的for循环中，故意让最后一个线程启动延迟，因为在前面三个线程都达到barrier之后，等待了指定的时间发现第四个线程还没有达到barrier，就抛出异常并继续执行后面的任务。</p><h5 id="例5"><a href="#例5" class="headerlink" title="例5"></a>例5</h5><p>另外CyclicBarrier是可以重用的，看下面这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">4</span>;</span><br><span class="line">        CyclicBarrier barrier  = <span class="keyword">new</span> CyclicBarrier(N);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Writer(barrier).start();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">25000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">"CyclicBarrier重用"</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Writer(barrier).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Writer</span><span class="params">(CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"正在写入数据..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);      <span class="comment">//以睡眠来模拟写入数据操作</span></span><br><span class="line">                System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"写入数据完毕，等待其他线程写入完毕"</span>);</span><br><span class="line">             </span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(BrokenBarrierException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"所有线程写入完毕，继续处理其他任务..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">线程Thread-0正在写入数据...</span><br><span class="line">线程Thread-1正在写入数据...</span><br><span class="line">线程Thread-3正在写入数据...</span><br><span class="line">线程Thread-2正在写入数据...</span><br><span class="line">线程Thread-1写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-3写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-2写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-0写入数据完毕，等待其他线程写入完毕</span><br><span class="line">Thread-0所有线程写入完毕，继续处理其他任务...</span><br><span class="line">Thread-3所有线程写入完毕，继续处理其他任务...</span><br><span class="line">Thread-1所有线程写入完毕，继续处理其他任务...</span><br><span class="line">Thread-2所有线程写入完毕，继续处理其他任务...</span><br><span class="line">CyclicBarrier重用</span><br><span class="line">线程Thread-4正在写入数据...</span><br><span class="line">线程Thread-5正在写入数据...</span><br><span class="line">线程Thread-6正在写入数据...</span><br><span class="line">线程Thread-7正在写入数据...</span><br><span class="line">线程Thread-7写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-5写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-6写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-4写入数据完毕，等待其他线程写入完毕</span><br><span class="line">Thread-4所有线程写入完毕，继续处理其他任务...</span><br><span class="line">Thread-5所有线程写入完毕，继续处理其他任务...</span><br><span class="line">Thread-6所有线程写入完毕，继续处理其他任务...</span><br><span class="line">Thread-7所有线程写入完毕，继续处理其他任务...</span><br></pre></td></tr></table></figure><p>从执行结果可以看出，在初次的4个线程越过barrier状态后，又可以用来进行新一轮的使用。而CountDownLatch无法进行重复使用。</p><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>Semaphore翻译成字面意思为 信号量，Semaphore可以控同时访问的线程个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。</p><h4 id="基础-2"><a href="#基础-2" class="headerlink" title="基础"></a>基础</h4><p>Semaphore类位于java.util.concurrent包下，它提供了2个构造器：</p><h5 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;          <span class="comment">//参数permits表示许可数目，即同时可以允许多少线程进行访问</span></span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;    <span class="comment">//这个多了一个参数fair表示是否是公平的，即等待时间越久的越先获取许可</span></span><br><span class="line">    sync = (fair)? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h5><p>下面说一下Semaphore类中比较重要的几个方法，首先是acquire()、release()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  &#125;     <span class="comment">//获取一个许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;    <span class="comment">//获取permits个许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123; &#125;          <span class="comment">//释放一个许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123; &#125;    <span class="comment">//释放permits个许可</span></span><br></pre></td></tr></table></figure><p>acquire()用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许可。</p><p>release()用来释放许可。注意，在释放许可之前，必须先获获得许可。</p><p>这4个方法都会被阻塞，如果想立即得到执行结果，可以使用下面几个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span> </span>&#123; &#125;;    <span class="comment">//尝试获取一个许可，若获取成功，则立即返回true，若获取失败，则立即返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;;  <span class="comment">//尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123; &#125;; <span class="comment">//尝试获取permits个许可，若获取成功，则立即返回true，若获取失败，则立即返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;; <span class="comment">//尝试获取permits个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false</span></span><br></pre></td></tr></table></figure><p>另外还可以通过availablePermits()方法得到可用的许可数目。</p><h4 id="类比理解-2"><a href="#类比理解-2" class="headerlink" title="类比理解"></a>类比理解</h4><p>下面通过一个例子来看一下Semaphore的具体使用：</p><p>假若一个工厂有5台机器，但是有8个工人，一台机器同时只能被一个工人使用，只有使用完了，其他工人才能继续使用。那么我们就可以通过Semaphore来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">8</span>;            <span class="comment">//工人数</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>); <span class="comment">//机器数目</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">            <span class="keyword">new</span> Worker(i,semaphore).start();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(<span class="keyword">int</span> num,Semaphore semaphore)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">            <span class="keyword">this</span>.semaphore = semaphore;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(<span class="string">"工人"</span>+<span class="keyword">this</span>.num+<span class="string">"占用一个机器在生产..."</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">"工人"</span>+<span class="keyword">this</span>.num+<span class="string">"释放出机器"</span>);</span><br><span class="line">                semaphore.release();           </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">工人<span class="number">0</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">1</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">2</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">4</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">5</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">0</span>释放出机器</span><br><span class="line">工人<span class="number">2</span>释放出机器</span><br><span class="line">工人<span class="number">3</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">7</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">4</span>释放出机器</span><br><span class="line">工人<span class="number">5</span>释放出机器</span><br><span class="line">工人<span class="number">1</span>释放出机器</span><br><span class="line">工人<span class="number">6</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">3</span>释放出机器</span><br><span class="line">工人<span class="number">7</span>释放出机器</span><br><span class="line">工人<span class="number">6</span>释放出机器</span><br></pre></td></tr></table></figure><h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>下面对上面说的三个辅助类进行一个总结：</p><h4 id="1）CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同："><a href="#1）CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：" class="headerlink" title="1）CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同："></a>1）CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：</h4><ul><li><p>CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；</p></li><li><p>而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；</p></li><li><p>另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。</p></li></ul><h4 id="2）Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。"><a href="#2）Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。" class="headerlink" title="2）Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。"></a>2）Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。</h4><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a></p></blockquote><blockquote><p><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><blockquote><p><a href="https://code.google.com/archive/p/disruptor/wikis/BlogsAndArticles.wiki" target="_blank" rel="noopener">【3】disruptor官网</a></p></blockquote><blockquote><p><a href="https://zl198751.iteye.com/blog/1848575" target="_blank" rel="noopener">【4】JAVA CAS原理深度分析</a></p></blockquote><blockquote><p><a href="http://ifeve.com/disruptor/" target="_blank" rel="noopener">【5】并发框架Disruptor译文</a></p></blockquote><blockquote><p><a href="https://blog.52itstyle.vip/archives/2911/" target="_blank" rel="noopener">【6】从构建分布式秒杀系统聊聊Disruptor高性能队列</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;面向对象的语言最好的学习方法就是在实际生活中找一个列子类比。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;CountDownLatch(计数器)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CyclicBarrier(回环栅栏)&lt;/p&gt;
&lt;/
      
    
    </summary>
    
      <category term="高并发" scheme="https://lywlefan.github.io/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://lywlefan.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="基础" scheme="https://lywlefan.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>架构导航</title>
    <link href="https://lywlefan.github.io/2019/06/26/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E5%AF%BC%E8%88%AA/"/>
    <id>https://lywlefan.github.io/2019/06/26/架构/架构导航/</id>
    <published>2019-06-25T16:00:00.000Z</published>
    <updated>2019-07-19T09:03:26.298Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>万丈高楼平地起的前提是地基好.</p></blockquote><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><h4 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h4><ul><li>Nginx</li><li>Kong</li><li>Zuul</li><li>GateWay</li></ul><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><ul><li>Redis</li><li>MemCached</li><li>OsCache</li><li>EhCache</li></ul><h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><ul><li>ElasticSearch</li><li>Solr</li></ul><h4 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h4><ul><li>Hystrix</li><li>resilience4j</li></ul><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><ul><li>DNS</li><li>F5</li><li>LVS</li><li>Nginx</li><li>OpenResty</li><li><p>HAproxy</p><h4 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h4></li><li><p>Eureka</p></li><li>Zookeeper</li><li>Redis</li><li>Etcd</li><li>Consul</li></ul><h4 id="认证鉴权"><a href="#认证鉴权" class="headerlink" title="认证鉴权"></a>认证鉴权</h4><ul><li>JWT<h4 id="消费队列"><a href="#消费队列" class="headerlink" title="消费队列"></a>消费队列</h4></li><li>RabbitMQ</li><li>ZeroMQ</li><li>Redis</li><li>ActiveMQ</li><li>Kafka<h4 id="系统监控"><a href="#系统监控" class="headerlink" title="系统监控"></a>系统监控</h4></li><li>Grafana</li><li>Prometheus</li><li>Influxdb</li><li>Telegraf</li><li>Lepus<h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4></li><li>OSS</li><li>NFS</li><li>FastDFS</li><li>MogileFS<h4 id="RPC框架"><a href="#RPC框架" class="headerlink" title="RPC框架"></a>RPC框架</h4><ul><li>Dubbo</li><li>Motan</li><li>Thrift</li><li>grpc<h4 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h4></li></ul></li><li>Maven</li><li>Gradle<h4 id="集成部署"><a href="#集成部署" class="headerlink" title="集成部署"></a>集成部署</h4></li><li>Docker</li><li>Jenkins</li><li>Git</li><li>Maven<h4 id="分布式配置"><a href="#分布式配置" class="headerlink" title="分布式配置"></a>分布式配置</h4></li><li>Disconf</li><li>Apollo</li><li>Spring Cloud Config</li><li>Diamond<h4 id="压测"><a href="#压测" class="headerlink" title="压测"></a>压测</h4></li><li>LoadRunner</li><li>JMeter</li><li>AB</li><li>webbench<h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4></li><li>MySql</li><li>Redis</li><li>MongoDB</li><li>PostgreSQL</li><li>Memcache</li><li>HBase</li><li>MPP数据库(Greenplum、TiDB、Postgresql XC、HAWQ等)</li></ul><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><ul><li>专用网络VPC</li><li>弹性公网IP</li><li>CDN<h4 id="数据库中间件"><a href="#数据库中间件" class="headerlink" title="数据库中间件"></a>数据库中间件</h4></li><li>DRDS</li><li>Mycat</li><li>360 Atlas</li><li>Cobar (不维护了)<h4 id="分布式框架"><a href="#分布式框架" class="headerlink" title="分布式框架"></a>分布式框架</h4></li><li>Dubbo</li><li>Motan</li><li>Spring-Could<h4 id="分布式任务"><a href="#分布式任务" class="headerlink" title="分布式任务"></a>分布式任务</h4></li><li>XXL</li><li>JOB</li><li>Elastic-Job</li><li>Saturn</li><li>Quartz<h4 id="分布式追踪"><a href="#分布式追踪" class="headerlink" title="分布式追踪"></a>分布式追踪</h4></li><li>Pinpoint</li><li>CAT</li><li>zipkin<h4 id="分布式日志"><a href="#分布式日志" class="headerlink" title="分布式日志"></a>分布式日志</h4></li><li>elasticsearch</li><li>logstash</li><li>Kibana </li><li>redis</li><li><p>kafka</p><h4 id="版本发布"><a href="#版本发布" class="headerlink" title="版本发布"></a>版本发布</h4></li><li><p>蓝绿部署</p></li><li>A/B测试</li><li>灰度发布／金丝雀发布</li></ul><h3 id="持续交付"><a href="#持续交付" class="headerlink" title="持续交付"></a>持续交付</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog.52itstyle.vip/usr/uploads/2018/12/547524725.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="链路监控"><a href="#链路监控" class="headerlink" title="链路监控"></a>链路监控</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog.52itstyle.vip/usr/uploads/2018/12/930721230.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="监控架构"><a href="#监控架构" class="headerlink" title="监控架构"></a>监控架构</h3><p>####四层监控</p><ul><li>前端监控：IP、PV、运营商、系统、性能、状态码</li><li>业务监控：登录、注册、下单、支付</li><li>应用层监控：service、sql、cache、相应时间</li><li>系统监控：物理机、虚拟机、容器，CPU、内存、IO、硬盘</li><li>基础监控：网络、交换机、路由器</li></ul><h4 id="监控分类"><a href="#监控分类" class="headerlink" title="监控分类"></a>监控分类</h4><ul><li>日志监控</li><li>调用链监控</li><li>告警系统</li><li>Metrics监控</li><li>监控检查</li></ul><p>Docker、Grafana、Prometheus、Telegraf、Influxdb、Lepus、Elasticsearch、Logstash、Kibana、kafka、node插件、dashboards仪表盘、钉钉、邮件、微信。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog.52itstyle.vip/usr/uploads/2017/11/3315159539.png" alt title>                </div>                <div class="image-caption"></div>            </figure><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog.52itstyle.vip/usr/uploads/2017/11/603463236.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="服务框架和治理"><a href="#服务框架和治理" class="headerlink" title="服务框架和治理"></a>服务框架和治理</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog.52itstyle.vip/usr/uploads/2018/12/1389990329.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="架构必备"><a href="#架构必备" class="headerlink" title="架构必备"></a>架构必备</h3><ul><li>负载均衡（负载均衡算法）</li><li>反向代理</li><li>服务隔离</li><li>服务限流</li><li>服务降级（自动优雅降级）</li><li>失效转移</li><li>超时重试（代理超时、容器超时、前端超时、中间件超时、数据库超时、NoSql超时）</li><li>回滚机制（上线回滚、数据库版本回滚、事务回滚）</li></ul><h4 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h4><ul><li>应用缓存</li><li>HTTP缓存</li><li>多级缓存</li><li>分布式缓存</li><li>连接池</li><li>异步并发</li></ul><h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><ul><li>二阶段提交(强一致)</li><li>三阶段提交(强一致)</li><li>消息中间件(最终一致性)，推荐阿里的RocketMQ</li></ul><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><ul><li>任务队列</li><li>消息队列</li><li>请求队列</li></ul><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><ul><li>单体垂直扩容</li><li>单体水平扩容</li><li>应用拆分</li><li>数据库拆分</li><li>数据库分库分表</li><li>数据异构</li><li>分布式任务</li></ul><h4 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h4><ul><li>SQL注入</li><li>XSS攻击</li><li>CSRF攻击</li><li>拒绝服务（DoS，Denial　of　Service）攻击</li></ul><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a></p></blockquote><blockquote><p><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><blockquote><p><a href="https://www.cnblogs.com/netfocus/archive/2012/02/12/2347919.html" target="_blank" rel="noopener">【3】LMAX架构简介·汤雪华</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;万丈高楼平地起的前提是地基好.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;技术选型&quot;&gt;&lt;a href=&quot;#技术选型&quot; class=&quot;headerlink&quot; title=&quot;技术选型&quot;&gt;&lt;/a&gt;技术选型&lt;/h3&gt;&lt;h4 id=&quot;网关&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="导航" scheme="https://lywlefan.github.io/categories/%E5%AF%BC%E8%88%AA/"/>
    
    
      <category term="架构导航" scheme="https://lywlefan.github.io/tags/%E6%9E%B6%E6%9E%84%E5%AF%BC%E8%88%AA/"/>
    
      <category term="架构" scheme="https://lywlefan.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>撮合系统设计</title>
    <link href="https://lywlefan.github.io/2019/06/26/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF/%E4%BA%A4%E6%98%93%E6%89%80/%E6%92%AE%E5%90%88%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    <id>https://lywlefan.github.io/2019/06/26/业务场景/交易所/撮合系统设计/</id>
    <published>2019-06-25T16:00:00.000Z</published>
    <updated>2019-06-27T11:35:30.508Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要：撮合技术主要是从数据库撮合技术向内存撮合技术发展，这是因为数据库撮合技术越来越无法满足金融交易对于高可靠性、高性能、强安全性、可扩展性以及易维护性的需求。本文来自中生代技术群的34期分享，将和大家讨论基于内存的撮合的系统设计。李伟山，毕业于国防科技大学，曾就职于华为、阿里巴巴，目前人江苏大圆银泰技术总监，对于高并发、大数据架构设计有深刻的了解。1.概述</p></blockquote><p>随着信息技术的日新月异和金融业务的快速发展,金融交易领域对于核心技术的求也在不断增强,国内外金融交易模式已经从传统的人工叫价的方式变成了由高度电子化交易系统撮合订单的方式。传统的金融交易主要发生在有型金融市场中,金融交易的买卖双方通过叫价进行价格协商等方式最终达成一致,从而形成一笔交易,同时按照交易订单到指定的交割地点进行实物交割的交易方式。由于交易的整个过程主要依靠人来执行,传统的金融交易缺点主要有:效率低速度慢、交易时间限制大、交易空间限制大、交易成本非常髙、容易有内幕交易、交易扩展性差、交易容易出错、资金安全性差等一系列的缺点。</p><p>时代不断变迁,金融交易通过与计算机技术的结合,走上了电子化交易的道路,通过将金融交易市场电子化,电子交易不仅消除了传统金融交易的种种弊端,也促进了现代金融业的快速发展。电子金融交易的主要优点有:交易效率高速度快、交易透明度高、交易成本低、系统安全性高、不受交易时间的限制、不受交易空间的限制、可以进行多方位的扩展、大力推动现代金融业发展等。</p><p>因此现在电子交易己经成为了金融交易市场的主流交易方式。随着交易人数、笔数的不断增加,系统承受着越来越大的压力,如果在交易时间内系统发生故障,造成的损失往往不可估量。因此发出更可靠更高效的电子交易系统己经成为了金融交易领域的当务之急。</p><p>撮合交易在金融交易系统中扮演者非常重要的角色。了解撮合交易的本质以及业务对于设计撮合系统至关重要。江苏大泰技术有限公司，致力于互联网金融平台的开发，目前已经在运行的平台有大宗交易、普洱茶交易系统，后期会发布连续现货和发售交易平台，接下来为大家介绍基于内存的撮合交易系统设计概要。</p><h3 id="2-系统总体设计"><a href="#2-系统总体设计" class="headerlink" title="2.系统总体设计"></a>2.系统总体设计</h3><h4 id="2-1-层次设计"><a href="#2-1-层次设计" class="headerlink" title="2.1 层次设计"></a>2.1 层次设计</h4><p>一般而言,金融交易撮合系统中包括以下几个核心模块:</p><p>用户:终端用户委托报价与数量,生成订单发送至交易平台。</p><p>网关:负责收集用户订单,并将其派发给撮合引擎。</p><p>撮合引擎:交易系统中的核心部分,用于接收订单并根据业务逻辑实现订单   撮合同时生成交易记录,随后给予用户交易结果反馈。</p><p>数据库:用来存放交易过程中的订单和交易记录,实现数据持久化。</p><p>此外,本文根据不同类型的金融交易展品将撮合模块划分为若干业务分区,每个分区独立进行撮合,彼此不受影响。对于单个业务分区而言,撮合系统整体架构设计如图1.2所示,本章的总体设计围绕撮合引擎层以及撮合引擎与网关层、数据库层的交互方式的总体设计。</p><h4 id="2-2-撮合交易算法"><a href="#2-2-撮合交易算法" class="headerlink" title="2.2 撮合交易算法"></a>2.2 撮合交易算法</h4><p>如图2.1所示,撮合引擎的核心业务模块就是撮合交易算法撮合交易算法的任务一方面是完成对客户所下订单进行公平合理的排列和撮合功能,也要保证撮合算法的公平性、高效性以及扩展性等。由于不同金融交易系统的撮合业务各有不同,因此本节对通用的撮合交易算法进行概括性描述。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://mmbiz.qpic.cn/mmbiz_png/8jNAbhjXPiaPSXURRrM6z0TmxnwYWDcjPmgBLFM6paMJCDPghmFZic61JrBoeV2SlGd9bXoqDlAcEHfuaLOYmLBw/0?wx_fmt=png" alt title>                </div>                <div class="image-caption"></div>            </figure><h5 id="2-2-1订单队列"><a href="#2-2-1订单队列" class="headerlink" title="2.2.1订单队列"></a>2.2.1订单队列</h5><p>撮合交易的重要组成部分就是买卖订单,通过对买卖订单进行撮合最后形成交易记录。所以对无法立刻完成撮合的订单,需要有买入队列和卖出队列保存订单。队列按照<strong>“价格优先、同价格下时间优先”</strong>的原则。买入队列按照委托价格从低到高的顺序,卖出队列则按照委托价格从低到高的顺序排列,如图</p><h5 id="2-2-2撮合顺序"><a href="#2-2-2撮合顺序" class="headerlink" title="2.2.2撮合顺序"></a>2.2.2撮合顺序</h5><p>撮合引擎接收到新的买入订单,则会到卖出队列的头部查找是否存在符合价格规则的卖出订单,如果存在卖出价格小于或等于买入价格的订单,则从队列中取出此订单并撮合成一笔交易;如果卖出队列为空或队列头部不满足价格关系,则将买入订单插入买入队列中,由于买入队列是按照价格与时间先后进行排序,所以新插入的订单会经过一次排序插入到买入队列的相应位置。</p><p>相同的,当撮合引擎接收到新的卖出订单,则会到买入队列的头部査找是否存在符合价格规则的买入订单,如果存在买入价格大于或等于卖出价格的订单,则从订单队列中取出此订单并撮合成一笔交易;如果买入队列为空或队列头部不满足价格关系,则将卖出订单插入到卖出队列中,由于卖出队列也是按照价格与时间先后进行排序的所以新插入的订单会经过一次排序插入到卖出队列的相应位置[23]。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://mmbiz.qpic.cn/mmbiz_png/8jNAbhjXPiaPSXURRrM6z0TmxnwYWDcjPKy0IicpPXvp6gNznmrfAWnLOZNjBRbcSOZwSQ8zsFrx6D8nbT15c72A/0?wx_fmt=png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>结合买卖订单情况,撮合算法流程如图2.3所示。从图2.3所示的撮合顺序可知,买卖队列的有序性是保证撮合顺序的确定性的基础,并且撮合过程中每笔订单都可以撮合出当前最优交易。</p><h4 id="2-3-内存撮合"><a href="#2-3-内存撮合" class="headerlink" title="2.3 内存撮合"></a>2.3 内存撮合</h4><p>当前的数据库撮合技术的性能低下的原因在于过多与数据库交互,使得I/O很多,系统整体处理速度同时受数据库事务逻辑约束。</p><p>本文釆用内存撮合技术,通过最大程度去除与数据库的交互过程,将整个错和逻辑放在内存中进行(如图2.4所示)。因此比数据库撮合技术少了许多I/O交S间,在性能上可以大幅提升撮合速度;例是内存撮合的弊端就是由于内存的易失性,.?服务器出现故障停机时,所有的交易数据将会丢失,系统的可靠性以及一致性都相应人幅降低。因此本文在提高内存撮合技术可靠性的方面采用丫多机热备份及分布式一致性技术作为补充,从而获得内存撮合技术的高性能以及数据库撮合技术的数据持久性。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://mmbiz.qpic.cn/mmbiz_png/8jNAbhjXPiaPSXURRrM6z0TmxnwYWDcjP15dWgFNVGIvpBEhNxLYcmFheu1UVibmuDY4OSFicicEHOAfdVELHfqt0g/0?wx_fmt=png" alt title>                </div>                <div class="image-caption"></div>            </figure>  <h4 id="2-4-多机热备份"><a href="#2-4-多机热备份" class="headerlink" title="2.4 多机热备份"></a>2.4 多机热备份</h4><p>由于内存撮合技术在撮合引攀出现异常时的可靠性和一致性非常差,而金融交场系统因为其业务特性,对服务小断以及数据丢失的容忍度非常低,提高容错性,一般多采取的是多机热条份技术。本文采用多机热备份技术,将一组撮合引樂部署成互为备份的撮合引擎集群,并且在同一时间内只有一台撮合引擎提供服务。当-其中运行这的一台撮六引擎出现故障无法继续正常工作 ,撮合引擎集群会迅速检测到这个故障,并选举出一个备份撮合引擎接管故障撮合引舉的任务从而保证整个撮合系统的正常运行多机热备份技术的本质就足针对服务器临时故障所做的一种备份技术,本文迎过采用多机热备份技术,来避免长 间的撮合服务中断,保证撮合系统长期、可靠的服务。如阁2.5所示,通过将多台撮合引擎进行热格份,从而保证在撮合引擎出现故障时,会在可以接受的时间内完成主机和备机之间的切换,由备份机提供无缝连续服务。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://mmbiz.qpic.cn/mmbiz_png/8jNAbhjXPiaPSXURRrM6z0TmxnwYWDcjPU3Awr4cSVaYvEHtZat9Yib4z9v8HI92oCoJpGic0X1Isgd04gvIomKbw/0?wx_fmt=png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>通过釆用多机热备份技术,降低了单一内存撮合引擎故障时系统不可用的问题,但仍旧无法提供100%的可用性,因为当出现大规模服务器集群故障时,仍旧存在服务不可用的可能性,但在实际生产环境中,三台互为备份的服务器就可以提供较高的可以用于生产环境的可靠性。</p><h4 id="2-5-内存状态机复制"><a href="#2-5-内存状态机复制" class="headerlink" title="2.5 内存状态机复制"></a>2.5 内存状态机复制</h4><p>由于多机热备份技术引入了多台互为热备份的撮合引擎,根据撮合系统设计以及撮合逻辑要求,需要保证服务器之间的数据一致,这就需要保证多服务器之间一致性,这也是本文难点之一。</p><p>本文提出一种内存状态机复制方案,即将撮合算法视作一个确定性状态机,将其复制多份并部署到撮合系统中的多台撮合引擎中。每个撮合引擎副本从相同的初始状态开始运行,当撮合系统收到网关发来的订单时,系统中的每个撮合引擎都会撮合这个订单,并依次产生交易记录,同时更新确定性撮合算法状态机的独立状态。通过这样的方式,当撮合系统正常运转时,每个撮合引擎副本都会具有相同的结果状态;当撮合系统出现故障或异常时,撮合引擎就会出现状态的不一致情况,换句话说一旦撮合系统的结果或状态出现了不一致的情况就可以断定系统出现了异常。</p><h5 id="2-5-1关键技术点"><a href="#2-5-1关键技术点" class="headerlink" title="2.5.1关键技术点"></a>2.5.1关键技术点</h5><p>本文为了实现这样的内存状态机复制撮合系统,将撮合系统划分为以下组成关键技术点：</p><ul><li><p>将确定性撮合算法状态机服务部署到多个独立撮合引擎</p></li><li><p>接收网关订单,并作为确定性撮合算法状态机的输入</p></li><li><p>根据撮合算法需求,选择一种订单排序方式</p></li><li><p>每个撮合引擎对按照排序方式排序过的订单进行撮合</p></li><li><p>将确定性撮合算法状态机输出的交易记录作为给用户或数据库的响应</p></li><li><p>监控撮合引擎副本的状态或输出的差别</p></li></ul><h5 id="2-5-2实现方案"><a href="#2-5-2实现方案" class="headerlink" title="2.5.2实现方案"></a>2.5.2实现方案</h5><p>为实现基于内存状态机复制的撮合系统,本文主要通过以下方案实现状态机复制的关键技术点:</p><ul><li><p>采用原子多播解决撮合引擎订单的可靠多播与全局有序性</p></li><li><p>采用基于无锁订单队列的流水线撮合技术提供快速的订单撮合</p></li><li><p>采用异步一致性持久化技术实现与数据库的交互</p></li><li><p>采用失效备援技术对撮合引擎集群进行状态监控并保证系统的容错能;</p></li><li><p>采用进度追赶技术解决将故障撮合引擎的恢复或新撮合引擎的加入</p></li></ul><h4 id="2-6-系统架构"><a href="#2-6-系统架构" class="headerlink" title="2.6 系统架构"></a>2.6 系统架构</h4><h5 id="2-6-1系统硬件体系架构"><a href="#2-6-1系统硬件体系架构" class="headerlink" title="2.6.1系统硬件体系架构"></a>2.6.1系统硬件体系架构</h5><p>典型的高可靠高性能撮合模型硬件架构如图2.6所示,系统由n台客户端、N台网关、X个产品集群(每个集群由2至3台撮合引擎组成,负责响应产品订单的处理)、一个交易记录数据库和可选的监视系统组成。其中客户端连接到相应网关,网关负责接收客户端提交的订单,并根据订单相关的金融产品类别,转发到相对应的产品集群。产品集群中所有撮合引擎均接收网关发送的订单,根据撮合业务规则,将其撮合并回馈消息给网关和客户端,同时将撮合生成的交易记录持久化到交易记录数据库中。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://mmbiz.qpic.cn/mmbiz_png/8jNAbhjXPiaPSXURRrM6z0TmxnwYWDcjPGBaCyygk3QxLDxS31JA12tPUu52WouXgpI75hOJMzqElCBNDL1PdaA/0?wx_fmt=png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>通过对产品集群进行扩充,增加撮合引擎数量,可以增强产品集群的可靠性。将不同金融产品转发到不同的撮合产品集群中可以实现多产品高效并行撮合。</p><h5 id="2-6-2-系统软件体系架构"><a href="#2-6-2-系统软件体系架构" class="headerlink" title="2.6.2 系统软件体系架构"></a>2.6.2 系统软件体系架构</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://mmbiz.qpic.cn/mmbiz_png/8jNAbhjXPiaPSXURRrM6z0TmxnwYWDcjPB9aicOqu9cpuS1bPrLyO1BGljN70CMT08lLia3Kl4Eu4QWJfFbTa7Ypg/0?wx_fmt=png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>如图2.7所示,高可靠高性能撮合模型主要由表示层、转发层、业务层和数据层组成。其核心部分业务层主要由撮合引擎集群组成,每个撮合引擎采用原子多播将订单定序后进行撮合处理,并结合无锁订单队列实现高效流水线撮合,最后结果写入本地日志。整个业务流程由消息传递总线将消息反馈给转发层。转发层则根据产品转发规则将订单转发给相应撮合引擎集群;而撮合引擎将本地日志中的交易记录读取到异步持久化代理进程中,并进而与数据层的异步持久化写入进程通信,并最终持久化到数据库中。本地日志增强了撮合系统数据的可靠性,在出现故障后,数据仍就可以从本地日志中恢复;而界步的持久化机制则提高了数据的持久化吞吐率。</p><h5 id="2-6-3撮合引擎架构"><a href="#2-6-3撮合引擎架构" class="headerlink" title="2.6.3撮合引擎架构"></a>2.6.3撮合引擎架构</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://mmbiz.qpic.cn/mmbiz_png/8jNAbhjXPiaPSXURRrM6z0TmxnwYWDcjPa1EESIvmatQ9NQh6R07tg5shjTFzMNfsl0Sx9fCGpQ7q6SajBNRtLg/0?wx_fmt=png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>为了使系统可扩展易维护,撮合引擎由原子多播订单定序模块、撮合处理器模块、交易记录日志模块和内存数据组成,每个模块根据功能业务划分。其中各部分主要有以下功能:交易订单接收线程:负责从网关接收订单,并完成原子多播定序流程。交易订单发送线程:将定序完成的订单发送给相关撮合业务线程。交易信息发送线程:将订单交易状态反馈给网关。外围业务逻辑线程:进行撮合数据的准备处理,更新内存订单数据。撮合业务逻辑线程:根据确定性撮合算法撮合接收的订单。交易行情发布线程:处理内存行情信息并发布给网关。同步日志写线程:将订单撮合产生的交易记录同步持久化到本地日志文件。异步持久化代理进程:异步将日志文件中的数据读取并持久化到数据库。订单信息:存储订单的相关价格、数量、用户、限制、类型和状态等信息交易行情信息:撮合交易过程中的交易行情信息。</p><h5 id="2-6-4系统接口"><a href="#2-6-4系统接口" class="headerlink" title="2.6.4系统接口"></a>2.6.4系统接口</h5><p>撮合系统主要为使用者提供订单的下单和查询服务、交易行情的实时反馈功能以及系统状态的监控查看服务。因此系统需要实现预留的接口主要包括:下单接口、订单查询接口、行情查询接口、系统控制接口和运行状态查询接口等。</p><h4 id="2-7-小节"><a href="#2-7-小节" class="headerlink" title="2.7 小节"></a>2.7 小节</h4><p>从总体设计入手,将撮合业务处理从数据库迁移至内存中,同时釆用多机热备份技术解决内存撮合技术的易失性问题,最终提出内存状态机复制方案作为高可靠髙性能撮合系统的实现路线。撮合技术的具体实现将在下一章进行详细论述。</p><p>###FAQ</p><p>Q：热备的机制上。多个机器内存上的状态如何保证强一致性的？</p><p>A： 是热备机器都是无状态，普洱茶按照不同品种产生不同撮合序列，只要保证单品种有序，其他撮合机和本机没有关系。</p><p>Q: 如果新加入一台撮合引擎，怎么判断所有的撮合数据都同步到了这台新的引擎上？</p><p>A: 委托单先要写raid文件系统，新增撮合引擎，也可以拿到数据。</p><p>Q: 根据你的描述，一个集群中为了判断撮合引擎是否有故障，至少应该有3台撮合引擎吧?</p><p>A:  zk来管理，并且有风控进程监控撮合进度。</p><p>Q: 内存状态机的复制究竟是结果还是数据？</p><p>A: 数据，就是把处理到某个状态的数据复制出来。</p><p>Q: 如果只有两台撮合引擎，如果对一个买入订单，发现结果不一致，如何判断是哪一台的故障？</p><p>A: 撮合只有一台进行撮合，撮合结束才回写数据库产生行情和分发个个终端，用户就可以看到自己委托单是否成交。</p><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a><br><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a><br><a href="https://toutiao.io/posts/q5bov1/preview" target="_blank" rel="noopener">【3】撮合系统· 李伟山</a><br><a href="https://www.itcodemonkey.com/article/11017.html" target="_blank" rel="noopener">【4】撮合系统·技术方舟</a><br><a href="https://zhuanlan.zhihu.com/p/67311339" target="_blank" rel="noopener">【5】交易所视角下的套利指令撮合机制</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;摘要：撮合技术主要是从数据库撮合技术向内存撮合技术发展，这是因为数据库撮合技术越来越无法满足金融交易对于高可靠性、高性能、强安全性、可扩展性以及易维护性的需求。本文来自中生代技术群的34期分享，将和大家讨论基于内存的撮合的系统设计。李伟山，毕业于国
      
    
    </summary>
    
      <category term="业务场景" scheme="https://lywlefan.github.io/categories/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF/"/>
    
    
      <category term="交易所" scheme="https://lywlefan.github.io/tags/%E4%BA%A4%E6%98%93%E6%89%80/"/>
    
      <category term="撮合" scheme="https://lywlefan.github.io/tags/%E6%92%AE%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>2.disruptor应用</title>
    <link href="https://lywlefan.github.io/2019/06/26/%E9%AB%98%E5%B9%B6%E5%8F%91/disruptor%E5%AD%A6%E4%B9%A0/2.disruptor%E5%BA%94%E7%94%A8/"/>
    <id>https://lywlefan.github.io/2019/06/26/高并发/disruptor学习/2.disruptor应用/</id>
    <published>2019-06-25T16:00:00.000Z</published>
    <updated>2019-06-26T10:09:12.170Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>disruptor号称能够在一个线程里每秒处理6百万订单,业务逻辑处理器完全是运行在内存中，使用事件源驱动方式。</p></blockquote><h3 id="本节导航"><a href="#本节导航" class="headerlink" title="本节导航"></a>本节导航</h3><ul><li><p>Disruptor核心链路场景应用讲解</p></li><li><p>并行计算- 串行操作</p></li><li><p>并行计算- 并行操作</p></li><li><p>并行计算- 多遍形高端操作</p></li><li><p>并行计算- 多生产者消费模型</p></li><li><p>并行计算- 多消费者消费模型</p></li></ul><h3 id="Disruptor核心链路场景应用讲解"><a href="#Disruptor核心链路场景应用讲解" class="headerlink" title="Disruptor核心链路场景应用讲解"></a>Disruptor核心链路场景应用讲解</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><h5 id="啥是核心链路"><a href="#啥是核心链路" class="headerlink" title="啥是核心链路?"></a>啥是核心链路?</h5><p>就拿京东来说,下单支付就是核心链路,物流也是核心链路.</p><h5 id="核心链路特点"><a href="#核心链路特点" class="headerlink" title="核心链路特点"></a>核心链路特点</h5><ul><li><p>代码复杂</p></li><li><p>业务逻辑复杂</p></li></ul><h5 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h5><ul><li><p>传统完全解耦的方式</p></li><li><p>模板模式</p></li></ul><h5 id="使用框架"><a href="#使用框架" class="headerlink" title="使用框架"></a>使用框架</h5><ul><li><p>有限状态机框架：Spring-StateMachine</p></li><li><p>使用Disruptor</p></li></ul><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a></p></blockquote><blockquote><p><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><blockquote><p><a href="https://code.google.com/archive/p/disruptor/wikis/BlogsAndArticles.wiki" target="_blank" rel="noopener">【3】disruptor官网</a></p></blockquote><blockquote><p><a href="https://zl198751.iteye.com/blog/1848575" target="_blank" rel="noopener">【4】JAVA CAS原理深度分析</a></p></blockquote><blockquote><p><a href="http://ifeve.com/disruptor/" target="_blank" rel="noopener">【5】并发框架Disruptor译文</a></p></blockquote><blockquote><p><a href="https://blog.52itstyle.vip/archives/2911/" target="_blank" rel="noopener">【6】从构建分布式秒杀系统聊聊Disruptor高性能队列</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;disruptor号称能够在一个线程里每秒处理6百万订单,业务逻辑处理器完全是运行在内存中，使用事件源驱动方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;本节导航&quot;&gt;&lt;a href=&quot;#本节导航&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="高并发" scheme="https://lywlefan.github.io/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://lywlefan.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="disruptor" scheme="https://lywlefan.github.io/tags/disruptor/"/>
    
  </entry>
  
  <entry>
    <title>1.disruptor初识</title>
    <link href="https://lywlefan.github.io/2019/06/26/%E9%AB%98%E5%B9%B6%E5%8F%91/disruptor%E5%AD%A6%E4%B9%A0/1.disruptor%E5%88%9D%E8%AF%86/"/>
    <id>https://lywlefan.github.io/2019/06/26/高并发/disruptor学习/1.disruptor初识/</id>
    <published>2019-06-25T16:00:00.000Z</published>
    <updated>2019-06-26T08:12:38.159Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>disruptor号称能够在一个线程里每秒处理6百万订单,业务逻辑处理器完全是运行在内存中，使用事件源驱动方式。</p></blockquote><h3 id="要学的概念"><a href="#要学的概念" class="headerlink" title="要学的概念"></a>要学的概念</h3><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><h5 id="打个比方理解"><a href="#打个比方理解" class="headerlink" title="打个比方理解"></a>打个比方理解</h5><p>乐观锁就是到桥头再看有没有车来过此桥,没有的话快速过桥.</p><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><h5 id="打个比方理解-1"><a href="#打个比方理解-1" class="headerlink" title="打个比方理解"></a>打个比方理解</h5><p>悲观锁说白了就是先发制人,我的车要过桥,但是我担心桥上有其他车,所以我提前把桥口加一个锁,我到桥头了在开锁过桥,过去了再把锁子接触了.</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><h5 id="打个比方理解-2"><a href="#打个比方理解-2" class="headerlink" title="打个比方理解"></a>打个比方理解</h5><p>简单的比方,两俩车同时过一个桥,不能倒车,如果两辆车同时在桥上就会造成死锁,车就相当于我们的线程,桥就相当于资源.</p><h4 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h4><h5 id="CAS简介"><a href="#CAS简介" class="headerlink" title="CAS简介"></a>CAS简介</h5><p>谷歌翻译CAS是<strong>比较并转换</strong>,java.util.concurrent包中借助CAS实现了区别于synchronouse同步锁的一种乐观锁。</p><h5 id="CAS应用"><a href="#CAS应用" class="headerlink" title="CAS应用"></a>CAS应用</h5><p>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p><ul><li>非阻塞算法 （nonblocking algorithms）</li></ul><blockquote><p>一个线程的失败或者挂起不应该影响其他线程的失败或挂起的算法。</p></blockquote><h5 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h5><p>CAS通过调用JNI的代码实现的。JNI:Java Native Interface为JAVA本地调用，允许java调用其他语言而compareAndSwapInt就是借助C来调用CPU底层指令实现的。</p><h5 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h5><ul><li><p>ABA问题</p></li><li><p>循环时间长开销大</p></li><li><p>只能保证一个共享变量的原子操作</p></li></ul><h4 id="缓存行"><a href="#缓存行" class="headerlink" title="缓存行"></a>缓存行</h4><h3 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h3><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><ul><li><p>一个线程每秒处理6百万订单</p></li><li><p>内存中运行 ,使用事件源驱动方式</p></li><li><p>业务逻辑处理核心Disruptor</p></li></ul><h4 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h4><ul><li><p>建立一个event类,用于创建Event类实例对象</p></li><li><p>需要有一个监听事件类,用于处理数据(Event类)</p></li><li><p>实例化Disruptor实例,配置一系列参数,编写Disruptor核心组件</p></li><li><p>编写生产者组件,向Disruptor容器中去投递数据</p></li></ul><h4 id="核心讲解"><a href="#核心讲解" class="headerlink" title="核心讲解"></a>核心讲解</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog.52itstyle.vip/usr/uploads/2018/05/2761303158.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h5 id="RingBuffer"><a href="#RingBuffer" class="headerlink" title="RingBuffer"></a>RingBuffer</h5><p>基于数组的缓存实现,也是创建sequencer与定义WaitStrategy的入口</p><ul><li><p>RingBuffer拥有一个序号,这个需要指向数组中下一个可用的元素</p></li><li><p>收尾相接的环 (环状数组)</p></li><li><p>假如缓存区芝麻满了,芝麻扔到哪里?</p></li><li><p>假如缓存区没芝麻了,如何取芝麻?</p></li><li><p>2的n次方更利于计算</p></li></ul><h5 id="Disruptor"><a href="#Disruptor" class="headerlink" title="Disruptor"></a>Disruptor</h5><p>持有RingBuffer、消费者线程池Executor、消费者集合ConsumerRepository等引用.</p><h5 id="Sequence"><a href="#Sequence" class="headerlink" title="Sequence"></a>Sequence</h5><ul><li><p>通顺序递增的序号来编号,管理进行交换的数据(事件)</p></li><li><p>对数据(事件)的处理过程总是沿着序号逐个递增处理</p></li><li><p>一个Sequence用于跟踪标识某个特定的事件处理者(RingBuffer/Producer/Consumer)的处理进度</p></li><li><p>Sequence可以看成是一个AtomicLong用于标识进度</p></li><li><p>还有另外一个目的就是防止不同Sequence之间CPU缓存伪共享(Flase Sharing)的问题</p></li></ul><h5 id="Sequencer"><a href="#Sequencer" class="headerlink" title="Sequencer"></a>Sequencer</h5><ul><li><p>Sequencer是Disruptor的真正核心,包含Sequence</p></li><li><p>此接口有两个实现类</p><ul><li>SingleProducerSequencer</li><li>MultiProducerSequencer</li></ul></li><li><p>主要实现生产者和消费者之间快速、正确的传递数据并发算法</p></li></ul><h5 id="Sequence-Barrier"><a href="#Sequence-Barrier" class="headerlink" title="Sequence Barrier"></a>Sequence Barrier</h5><ul><li><p>用于保持RingBuffer的Main Published Sequence(Producer)和Consumer之间平衡关系;</p></li><li><p>决定Consumer是否还有可处理事件逻辑</p></li></ul><h5 id="WaitStrategy"><a href="#WaitStrategy" class="headerlink" title="WaitStrategy"></a>WaitStrategy</h5><ul><li><p>决定一个消费者将如何等待生产者将Event置入Disruptor</p></li><li><p>主要策略</p><ul><li><p>BlockWaitStrategy</p><ul><li><p>最低效策略</p></li><li><p>cpu消耗最小</p></li><li><p>在各种不同部署环境中提供更加一致性能表现</p></li></ul></li><li><p>SleepingWaitStrategy</p><ul><li>和上面性能差不多</li><li>cpu性能和上面差不多</li><li>对生产者线程影响最小,适合用于异步日志类似的场景</li></ul></li><li><p>YieldingWaitStrategy</p><ul><li><p>性能最好</p></li><li><p>适用低延迟系统</p></li><li><p>要求极高性能</p></li><li><p>要求极高性能且事件处理线数小于CPU逻辑核心数场景,列如:CPU开启超线程的特性</p></li></ul></li></ul></li></ul><h5 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h5><ul><li><p>从生产者到消费者过程中所处理的数据单元</p></li><li><p>Disruptor中没有代码表示Event,因为它完全是由用户定义的</p></li></ul><h5 id="EventProcessor"><a href="#EventProcessor" class="headerlink" title="EventProcessor"></a>EventProcessor</h5><ul><li><p>主要事件循环,处理Disruptor中的Event,拥有消费者Sequence</p></li><li><p>他是一个实现类是BatchEventProcessor,包含了event loop有效的实现,并且将回调一个EventHandler接口的实现对象.</p></li></ul><h5 id="EventHandler"><a href="#EventHandler" class="headerlink" title="EventHandler"></a>EventHandler</h5><ul><li>由用户并且代表了Disruptor中的一个消费者接口,也就是我们消费者逻辑都要写到这里.</li></ul><h5 id="WorkProcessor"><a href="#WorkProcessor" class="headerlink" title="WorkProcessor"></a>WorkProcessor</h5><ul><li>确保每个sequence只被一个processor消费,在同一个WorkPool中处理多个WorkProcessor不会消费同样的sequence</li></ul><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a></p></blockquote><blockquote><p><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><blockquote><p><a href="https://code.google.com/archive/p/disruptor/wikis/BlogsAndArticles.wiki" target="_blank" rel="noopener">【3】disruptor官网</a></p></blockquote><blockquote><p><a href="https://zl198751.iteye.com/blog/1848575" target="_blank" rel="noopener">【4】JAVA CAS原理深度分析</a></p></blockquote><blockquote><p><a href="http://ifeve.com/disruptor/" target="_blank" rel="noopener">【5】并发框架Disruptor译文</a></p></blockquote><blockquote><p><a href="https://blog.52itstyle.vip/archives/2911/" target="_blank" rel="noopener">【6】从构建分布式秒杀系统聊聊Disruptor高性能队列</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;disruptor号称能够在一个线程里每秒处理6百万订单,业务逻辑处理器完全是运行在内存中，使用事件源驱动方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;要学的概念&quot;&gt;&lt;a href=&quot;#要学的概念&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="高并发" scheme="https://lywlefan.github.io/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://lywlefan.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="disruptor" scheme="https://lywlefan.github.io/tags/disruptor/"/>
    
  </entry>
  
  <entry>
    <title>自定义线程池</title>
    <link href="https://lywlefan.github.io/2019/06/26/%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/java/%E7%BA%BF%E7%A8%8B/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://lywlefan.github.io/2019/06/26/基础巩固/java/线程/自定义线程池/</id>
    <published>2019-06-25T16:00:00.000Z</published>
    <updated>2019-06-26T06:44:34.676Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>万丈高楼平地起的前提是地基好.</p></blockquote><h3 id="为什么要定义线程池"><a href="#为什么要定义线程池" class="headerlink" title="为什么要定义线程池??"></a>为什么要定义线程池??</h3><p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？在Java中可以通过线程池来达到这样的效果。首先我们从最核心的ThreadPoolExecutor类中的方法讲起。</p><h3 id="进一步学习"><a href="#进一步学习" class="headerlink" title="进一步学习"></a>进一步学习</h3><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>java.uitl.concurrent.ThreadPoolExecutor类是线程池中最核心的一个类，因此如果要透彻地了解Java中的线程池，必须先了解这个类。下面我们来看一下ThreadPoolExecutor类的具体实现源码。</p><p>在ThreadPoolExecutor类中提供了四个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    .....</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue)</span></span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory)</span></span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler)</span></span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)</span></span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以得知，ThreadPoolExecutor继承了AbstractExecutorService类，并提供了四个构造器，事实上，通过观察每个构造器的源码具体实现，发现前面三个构造器都是调用的第四个构造器进行的初始化工作。</p><p>下面解释下一下构造器中各个参数的含义：</p><p>corePoolSize：核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；</p><p>maximumPoolSize：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；</p><p>keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；</p><p>unit：参数keepAliveTime的时间单位</p><p>workQueue：一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：</p><p>ArrayBlockingQueue;</p><p>LinkedBlockingQueue;</p><p>SynchronousQueue;</p><p>threadFactory：线程工厂，主要用来创建线程；</p><p>handler：表示当拒绝处理任务时的策略，默认有以下四种取值：</p><p>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</p><p>ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。</p><p>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</p><p>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</p><h4 id="线程池执行的流程"><a href="#线程池执行的流程" class="headerlink" title="线程池执行的流程"></a>线程池执行的流程</h4><p>当任务提交给ThreadPoolExecutor 线程池中，先检查核心线程数是否已经全部使用，如果没有交由核心线程去执行任务，如果核心线程数已经全部占用，则将任务添加到队列里面，如果队列已经占满，比较当前线程池的中线程的数量是不是与超过maximumPoolSize，如果没有查过则创建线程去执行，也就是说线程池最多可以接受多少任务呢？就是maximumPoolSize+队列的大小。当线程池中的线程的数量大于corePoolSize数量有空闲线程则执行回收，回收时间是keepAliveTime，单位是unit，都是初始化的时候设置的。</p><p>下面通过代码来说明：</p><p>定义一个实现了Runnable接口的类，当作任务类；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> taskId;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String taskName;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTaskId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> taskId;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTaskId</span><span class="params">(<span class="keyword">int</span> taskId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.taskId = taskId;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTaskName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> taskName;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTaskName</span><span class="params">(String taskName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.taskName = taskName;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> taskId, String taskName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.taskId = taskId;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.taskName = taskName;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"taskId:"</span> + taskId + <span class="string">",taskName:"</span> + taskName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a><br><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;万丈高楼平地起的前提是地基好.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;为什么要定义线程池&quot;&gt;&lt;a href=&quot;#为什么要定义线程池&quot; class=&quot;headerlink&quot; title=&quot;为什么要定义线程池??&quot;&gt;&lt;/a&gt;为什么要定义线
      
    
    </summary>
    
      <category term="基础巩固" scheme="https://lywlefan.github.io/categories/%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/"/>
    
    
      <category term="基础" scheme="https://lywlefan.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="线程" scheme="https://lywlefan.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程池" scheme="https://lywlefan.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>环形缓冲区</title>
    <link href="https://lywlefan.github.io/2019/06/25/%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%8E%AF%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA/"/>
    <id>https://lywlefan.github.io/2019/06/25/基础巩固/java/数据结构/环形缓冲区/</id>
    <published>2019-06-24T16:00:00.000Z</published>
    <updated>2019-06-25T09:27:37.320Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>万丈高楼平地起的前提是地基好.</p></blockquote><h2 id="环形缓冲区"><a href="#环形缓冲区" class="headerlink" title="环形缓冲区"></a>环形缓冲区</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>圆形缓冲区（circular buffer），也称作圆形队列（circular queue），循环缓冲区（cyclic buffer），环形缓冲区（ring buffer），是一种数据结构用于表示一个固定尺寸、头尾相连的缓冲区，适合缓存数据流。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://file.elecfans.com/web1/M00/50/35/o4YBAFrwa-6AegOaAAA4gY1qlrg104.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>圆形缓冲区的一个有用特性是：当一个数据元素被用掉后，其余数据元素不需要移动其存储位置。相反，一个非圆形缓冲区（例如一个普通的队列）在用掉一个数据元素后，其余数据元素需要向前搬移。换句话说，圆形缓冲区适合实现先进先出缓冲区，而非圆形缓冲区适合后进先出缓冲区。</p><p>圆形缓冲区适合于事先明确了缓冲区的最大容量的情形。扩展一个圆形缓冲区的容量，需要搬移其中的数据。因此一个缓冲区如果需要经常调整其容量，用链表实现更为合适。</p><p>写操作覆盖圆形缓冲区中未被处理的数据在某些情况下是允许的。特别是在多媒体处理时。例如，音频的生产者可以覆盖掉声卡尚未来得及处理的音频数据。</p><h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><p>一个圆形缓冲区最初为空并有预定的长度。例如，这是一个具有七个元素空间的圆形缓冲区，其中底部的单线与箭头表示“头尾相接”形成一个圆形地址空间：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://file.elecfans.com/web1/M00/50/41/pIYBAFrwbAqAACQYAAAD3oTpgUw459.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>假定1被写入缓冲区中部（对于圆形缓冲区来说，最初的写入位置在哪里是无关紧要的）：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://file.elecfans.com/web1/M00/50/41/pIYBAFrwbA2AKF6_AAADdB6vQFU279.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>再写入2个元素，分别是2 &amp; 3 — 被追加在1之后：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://file.elecfans.com/web1/M00/50/35/o4YBAFrwa_aAXRcsAAAEWhT6FVc909.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>如果两个元素被处理，那么是缓冲区中最老的两个元素被卸载。在本例中，1 &amp; 2被卸载，缓冲区中只剩下3:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://file.elecfans.com/web1/M00/50/41/pIYBAFrwbBCAQMANAAAD5C7jghM939.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>如果缓冲区中有7个元素，则是满的：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://file.elecfans.com/web1/M00/50/35/o4YBAFrwa_mAE8tFAAAFjCtPkIM681.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>如果缓冲区是满的，又要写入新的数据，一种策略是覆盖掉最老的数据。此例中，2个新数据— A &amp; B — 写入，覆盖了3 &amp; 4:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://file.elecfans.com/web1/M00/50/41/pIYBAFrwbBSAKyW6AAAF3Om3IyE233.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>也可以采取其他策略，禁止覆盖缓冲区的数据，采取返回一个错误码或者抛出异常。</p><p>最终，如果从缓冲区中卸载2个数据，不是3 &amp; 4 而是 5 &amp; 6 。因为 A &amp; B 已经覆盖了3 &amp; 4：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://file.elecfans.com/web1/M00/50/35/o4YBAFrwa_2AV4y2AAAFORhzqEE837.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="圆形缓冲区工作机制"><a href="#圆形缓冲区工作机制" class="headerlink" title="圆形缓冲区工作机制"></a>圆形缓冲区工作机制</h3><p>由于计算机内存是线性地址空间，因此圆形缓冲区需要特别的设计才可以从逻辑上实现。</p><h4 id="读指针与写指针"><a href="#读指针与写指针" class="headerlink" title="读指针与写指针"></a>读指针与写指针</h4><p>一般的，圆形缓冲区需要4个指针：</p><ul><li>在内存中实际开始位置；</li><li>在内存中实际结束位置，也可以用缓冲区长度代替；</li><li>存储在缓冲区中的有效数据的开始位置（读指针）；</li><li>存储在缓冲区中的有效数据的结尾位置（写指针）。</li></ul><p>读指针、写指针可以用整型值来表示。</p><p>下例为一个未满的缓冲区的读写指针：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://file.elecfans.com/web1/M00/50/35/o4YBAFrwbACARs89AAAGVd0aJDk224.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>下例为一个满的缓冲区的读写指针：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://file.elecfans.com/web1/M00/50/41/pIYBAFrwbBuAeOkFAAAHY4qLrwc154.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>区分缓冲区满或者空缓冲区是满、或是空，都有可能出现读指针与写指针指向同一位置：</p><p>250px有多种策略用于检测缓冲区是满、或是空.</p><h4 id="总是保持一个存储单元为空"><a href="#总是保持一个存储单元为空" class="headerlink" title="总是保持一个存储单元为空"></a>总是保持一个存储单元为空</h4><p>缓冲区中总是有一个存储单元保持未使用状态。缓冲区最多存入个数据。如果读写指针指向同一位置，则缓冲区为空。如果写指针位于读指针的相邻后一个位置，则缓冲区为满。这种策略的优点是简单、鲁棒；缺点是语义上实际可存数据量与缓冲区容量不一致，测试缓冲区是否满需要做取余数计算。</p><h4 id="使用数据计数"><a href="#使用数据计数" class="headerlink" title="使用数据计数"></a>使用数据计数</h4><p>这种策略不使用显式的写指针，而是保持着缓冲区内存储的数据的计数。因此测试缓冲区是空是满非常简单；对性能影响可以忽略。缺点是读写操作都需要修改这个存储数据计数，对于多线程访问缓冲区需要并发控制。</p><h4 id="镜像指示位"><a href="#镜像指示位" class="headerlink" title="镜像指示位"></a>镜像指示位</h4><p>缓冲区的长度如果是n，逻辑地址空间则为0至n-1；那么，规定n至2n-1为镜像逻辑地址空间。本策略规定读写指针的地址空间为0至2n-1，其 中低半部分对应于常规的逻辑地址空间，高半部分对应于镜像逻辑地址空间。当指针值大于等于2n时，使其折返（wrapped）到ptr-2n。使用一位表 示写指针或读指针是否进入了虚拟的镜像存储区：置位表示进入，不置位表示没进入还在基本存储区。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://file.elecfans.com/web1/M00/50/41/pIYBAFrwbCCAYYCNAAAuVAwq83g393.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在读写指针的值相同情况下，如果二者的指示位相同，说明缓冲区为空；如果二者的指示位不同，说明缓冲区为满。这种方法优点是测试缓冲区满/空很简 单；不需要做取余数操作；读写线程可以分别设计专用算法策略，能实现精致的并发控制。 缺点是读写指针各需要额外的一位作为指示位。</p><p>如果缓冲区长度是2的幂，则本方法可以省略镜像指示位。如果读写指针的值相等，则缓冲区为空；如果读写指针相差n，则缓冲区为满，这可以用条件表达式（写指针 == (读指针 异或 缓冲区长度)）来判断。</p><h4 id="读-写-计数"><a href="#读-写-计数" class="headerlink" title="读/写 计数"></a>读/写 计数</h4><p>用两个有符号整型变量分别保存写入、读出缓冲区的数据数量。其差值就是缓冲区中尚未被处理的有效数据的数量。这种方法的优点是读线程、写线程互不干扰；缺点是需要额外两个变量。</p><h4 id="记录最后的操作"><a href="#记录最后的操作" class="headerlink" title="记录最后的操作"></a>记录最后的操作</h4><p>使用一位记录最后一次操作是读还是写。读写指针值相等情况下，如果最后一次操作为写入，那么缓冲区是满的；如果最后一次操作为读出，那么缓冲区是空。 这种策略的缺点是读写操作共享一个标志位，多线程时需要并发控制。</p><h4 id="POSIX优化实现"><a href="#POSIX优化实现" class="headerlink" title="POSIX优化实现"></a>POSIX优化实现</h4><h4 id="Linux内核的kfifo"><a href="#Linux内核的kfifo" class="headerlink" title="Linux内核的kfifo"></a>Linux内核的kfifo</h4><p>在Linux内核文件kfifo.h和kfifo.c中，定义了一个先进先出圆形缓冲区实现。如果只有一个读线程、一个写线程，二者没有共享的被修改的控制变量，那么可以证明这种情况下不需要并发控制。kfifo就满足上述条件。kfifo要求缓冲区长度必须为2的幂。读、写指针分别是无符号整型变量。把读写指针变换为缓冲区内的索引值，仅需要“按位与”操作：（指针值 按位与 （缓冲区长度-1））。这避免了计算代价高昂的“求余”操作。且下述关系总是成立：</p><p>读指针 + 缓冲区存储的数据长度 == 写指针即使在写指针达到了无符号整型的上界，上溢出后写指针的值小于读指针的值，上述关系仍然保持成立（这是因为无符号整型加法的性质）。 kfifo的写操作，首先计算缓冲区中当前可写入存储空间的数据长度：len = min[待写入数据长度, 缓冲区长度 - （写指针 - 读指针）]然后，分两段写入数据。第一段是从写指针开始向缓冲区末尾方向；第二段是从缓冲区起始处写入余下的可写入数据，这部分可能数据长度为0即并无实际数据写入。</p><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a><br><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;万丈高楼平地起的前提是地基好.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;环形缓冲区&quot;&gt;&lt;a href=&quot;#环形缓冲区&quot; class=&quot;headerlink&quot; title=&quot;环形缓冲区&quot;&gt;&lt;/a&gt;环形缓冲区&lt;/h2&gt;&lt;h3 id=&quot;介绍&quot;
      
    
    </summary>
    
      <category term="基础巩固" scheme="https://lywlefan.github.io/categories/%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/"/>
    
    
      <category term="基础" scheme="https://lywlefan.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="数据结构" scheme="https://lywlefan.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="环形缓冲区" scheme="https://lywlefan.github.io/tags/%E7%8E%AF%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA/"/>
    
  </entry>
  
  <entry>
    <title>LMAX架构</title>
    <link href="https://lywlefan.github.io/2019/06/21/%E6%9E%B6%E6%9E%84/%E4%BB%8E100%E5%88%B01000%E4%B8%87%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF/"/>
    <id>https://lywlefan.github.io/2019/06/21/架构/从100到1000万高并发的架构演进之路/</id>
    <published>2019-06-20T16:00:00.000Z</published>
    <updated>2019-07-19T09:48:08.101Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>万丈高楼平地起的前提是地基好.</p></blockquote><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>在介绍架构之前，为了避免部分读者对架构设计中的一些概念不了解，下面对几个最基础的概念进行介绍。</p><h3 id="什么是分布式？"><a href="#什么是分布式？" class="headerlink" title="什么是分布式？"></a>什么是分布式？</h3><p>系统中的多个模块在不同服务器上部署，即可称为分布式系统，如Tomcat和数据库分别部署在不同的服务器上，或两个相同功能的Tomcat分别部署在不同服务器上。</p><h3 id="什么是高可用？"><a href="#什么是高可用？" class="headerlink" title="什么是高可用？"></a>什么是高可用？</h3><p>系统中部分节点失效时，其他节点能够接替它继续提供服务，则可认为系统具有高可用性。</p><h3 id="什么是集群？"><a href="#什么是集群？" class="headerlink" title="什么是集群？"></a>什么是集群？</h3><p>一个特定领域的软件部署在多台服务器上并作为一个整体提供一类服务，这个整体称为集群。</p><p>如Zookeeper中的Master和Slave分别部署在多台服务器上，共同组成一个整体提供集中配置服务。</p><p>在常见的集群中，客户端往往能够连接任意一个节点获得服务，并且当集群中一个节点掉线时，其他节点往往能够自动的接替它继续提供服务，这时候说明集群具有高可用性。</p><h3 id="什么是负载均衡？"><a href="#什么是负载均衡？" class="headerlink" title="什么是负载均衡？"></a>什么是负载均衡？</h3><p>请求发送到系统时，通过某些方式把请求均匀分发到多个节点上，使系统中每个节点能够均匀的处理请求负载，则可认为系统是负载均衡的。</p><h3 id="什么是正向代理和反向代理？"><a href="#什么是正向代理和反向代理？" class="headerlink" title="什么是正向代理和反向代理？"></a>什么是正向代理和反向代理？</h3><p>系统内部要访问外部网络时，统一通过一个代理服务器把请求转发出去，在外部网络看来就是代理服务器发起的访问，此时代理服务器实现的是正向代理；</p><p>当外部请求进入系统时，代理服务器把该请求转发到系统中的某台服务器上，对外部请求来说，与之交互的只有代理服务器，此时代理服务器实现的是反向代理。</p><p>简单来说，正向代理是代理服务器代替系统内部来访问外部网络的过程，反向代理是外部请求访问系统时通过代理服务器转发到内部服务器的过程。</p><h2 id="架构演讲"><a href="#架构演讲" class="headerlink" title="架构演讲"></a>架构演讲</h2><h3 id="纯真年代：单机架构"><a href="#纯真年代：单机架构" class="headerlink" title="纯真年代：单机架构"></a>纯真年代：单机架构</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://www.52im.net/data/attachment/forum/201907/17/143829v8qo3novpf3pn6fq.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>以淘宝作为例子：在网站最初时，应用数量与用户数都较少，可以把Tomcat和数据库部署在同一台服务器上。浏览器往<a href="http://www.taobao.com发起请求时，首先经过DNS服务器（域名系统）把域名转换为实际IP地址10.102.4.1，浏览器转而访问该IP对应的Tomcat。" target="_blank" rel="noopener">www.taobao.com发起请求时，首先经过DNS服务器（域名系统）把域名转换为实际IP地址10.102.4.1，浏览器转而访问该IP对应的Tomcat。</a></p><blockquote><p>架构瓶颈：随着用户数的增长，Tomcat和数据库之间竞争资源，单机性能不足以支撑业务。</p></blockquote><h3 id="第一次演进：Tomcat与数据库分开部署"><a href="#第一次演进：Tomcat与数据库分开部署" class="headerlink" title="第一次演进：Tomcat与数据库分开部署"></a>第一次演进：Tomcat与数据库分开部署</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://www.52im.net/data/attachment/forum/201907/17/143946s62j2x7qrj6wz0a2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>Tomcat和数据库分别独占服务器资源，显著提高两者各自性能。</p><blockquote><p>架构瓶颈：随着用户数的增长，并发读写数据库成为瓶颈。</p></blockquote><h3 id="第二次演进：引入本地缓存和分布式缓存"><a href="#第二次演进：引入本地缓存和分布式缓存" class="headerlink" title="第二次演进：引入本地缓存和分布式缓存"></a>第二次演进：引入本地缓存和分布式缓存</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://www.52im.net/data/attachment/forum/201907/17/144116dzry7zv2bu3bymzt.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在Tomcat同服务器上或同JVM中增加本地缓存，并在外部增加分布式缓存，缓存热门商品信息或热门商品的html页面等。通过缓存能把绝大多数请求在读写数据库前拦截掉，大大降低数据库压力。其中涉及的技术包括：使用memcached作为本地缓存，使用Redis作为分布式缓存，还会涉及缓存一致性、缓存穿透/击穿、缓存雪崩、热点数据集中失效等问题。</p><blockquote><p>架构瓶颈：缓存抗住了大部分的访问请求，随着用户数的增长，并发压力主要落在单机的Tomcat上，响应逐渐变慢。</p></blockquote><h3 id="第三次演进：引入反向代理实现负载均衡"><a href="#第三次演进：引入反向代理实现负载均衡" class="headerlink" title="第三次演进：引入反向代理实现负载均衡"></a>第三次演进：引入反向代理实现负载均衡</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://www.52im.net/data/attachment/forum/201907/17/144231evqjpawvzf954ol9.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在多台服务器上分别部署Tomcat，使用反向代理软件（Nginx）把请求均匀分发到每个Tomcat中。此处假设Tomcat最多支持100个并发，Nginx最多支持50000个并发，那么理论上Nginx把请求分发到500个Tomcat上，就能抗住50000个并发。</p><p>其中涉及的技术包括：Nginx、HAProxy，两者都是工作在网络第七层的反向代理软件，主要支持http协议，还会涉及session共享、文件上传下载的问题。</p><blockquote><p>架构瓶颈：反向代理使应用服务器可支持的并发量大大增加，但并发量的增长也意味着更多请求穿透到数据库，单机的数据库最终成为瓶颈。</p></blockquote><h3 id="第四次演进：数据库读写分离"><a href="#第四次演进：数据库读写分离" class="headerlink" title="第四次演进：数据库读写分离"></a>第四次演进：数据库读写分离</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://www.52im.net/data/attachment/forum/201907/17/144328j56n9j2bj92go02j.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>把数据库划分为读库和写库，读库可以有多个，通过同步机制把写库的数据同步到读库，对于需要查询最新写入数据场景，可通过在缓存中多写一份，通过缓存获得最新数据。其中涉及的技术包括：Mycat，它是数据库中间件，可通过它来组织数据库的分离读写和分库分表，客户端通过它来访问下层数据库，还会涉及数据同步，数据一致性的问题。</p><blockquote><p>架构瓶颈：业务逐渐变多，不同业务之间的访问量差距较大，不同业务直接竞争数据库，相互影响性能。</p></blockquote><h3 id="第五次演进：数据库按业务分库"><a href="#第五次演进：数据库按业务分库" class="headerlink" title="第五次演进：数据库按业务分库"></a>第五次演进：数据库按业务分库</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://www.52im.net/data/attachment/forum/201907/17/144526btw0otfcbitlc5td.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>把不同业务的数据保存到不同的数据库中，使业务之间的资源竞争降低，对于访问量大的业务，可以部署更多的服务器来支撑。这样同时导致跨业务的表无法直接做关联分析，需要通过其他途径来解决，但这不是本文讨论的重点，有兴趣的可以自行搜索解决方案。</p><blockquote><p>架构瓶颈：随着用户数的增长，单机的写库会逐渐会达到性能瓶颈。</p></blockquote><h3 id="第六次演进：把大表拆分为小表"><a href="#第六次演进：把大表拆分为小表" class="headerlink" title="第六次演进：把大表拆分为小表"></a>第六次演进：把大表拆分为小表</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://www.52im.net/data/attachment/forum/201907/17/161959t0705ar70a75xja5.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>比如针对评论数据，可按照商品ID进行hash，路由到对应的表中存储；针对支付记录，可按照小时创建表，每个小时表继续拆分为小表，使用用户ID或记录编号来路由数据。只要实时操作的表数据量足够小，请求能够足够均匀的分发到多台服务器上的小表，那数据库就能通过水平扩展的方式来提高性能。其中前面提到的Mycat也支持在大表拆分为小表情况下的访问控制。</p><p>这种做法显著的增加了数据库运维的难度，对DBA的要求较高。数据库设计到这种结构时，已经可以称为分布式数据库，但是这只是一个逻辑的数据库整体，数据库里不同的组成部分是由不同的组件单独来实现的，如分库分表的管理和请求分发，由Mycat实现，SQL的解析由单机的数据库实现，读写分离可能由网关和消息队列来实现，查询结果的汇总可能由数据库接口层来实现等等，这种架构其实是MPP（大规模并行处理）架构的一类实现。</p><p>目前开源和商用都已经有不少MPP数据库，开源中比较流行的有Greenplum、TiDB、Postgresql XC、HAWQ等，商用的如南大通用的GBase、睿帆科技的雪球DB、华为的LibrA等等，不同的MPP数据库的侧重点也不一样，如TiDB更侧重于分布式OLTP场景，Greenplum更侧重于分布式OLAP场景，这些MPP数据库基本都提供了类似Postgresql、Oracle、MySQL那样的SQL标准支持能力，能把一个查询解析为分布式的执行计划分发到每台机器上并行执行，最终由数据库本身汇总数据进行返回，也提供了诸如权限管理、分库分表、事务、数据副本等能力，并且大多能够支持100个节点以上的集群，大大降低了数据库运维的成本，并且使数据库也能够实现水平扩展。</p><blockquote><p>架构瓶颈：数据库和Tomcat都能够水平扩展，可支撑的并发大幅提高，随着用户数的增长，最终单机的Nginx会成为瓶颈。</p></blockquote><h3 id="第七次演进：使用LVS或F5来使多个Nginx负载均衡"><a href="#第七次演进：使用LVS或F5来使多个Nginx负载均衡" class="headerlink" title="第七次演进：使用LVS或F5来使多个Nginx负载均衡"></a>第七次演进：使用LVS或F5来使多个Nginx负载均衡</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://www.52im.net/data/attachment/forum/201907/17/163912behrvv5bmvwiewbp.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>由于瓶颈在Nginx，因此无法通过两层的Nginx来实现多个Nginx的负载均衡。图中的LVS和F5是工作在网络第四层的负载均衡解决方案，其中LVS是软件，运行在操作系统内核态，可对TCP请求或更高层级的网络协议进行转发，因此支持的协议更丰富，并且性能也远高于Nginx，可假设单机的LVS可支持几十万个并发的请求转发；F5是一种负载均衡硬件，与LVS提供的能力类似，性能比LVS更高，但价格昂贵。由于LVS是单机版的软件，若LVS所在服务器宕机则会导致整个后端系统都无法访问，因此需要有备用节点。可使用keepalived软件模拟出虚拟IP，然后把虚拟IP绑定到多台LVS服务器上，浏览器访问虚拟IP时，会被路由器重定向到真实的LVS服务器，当主LVS服务器宕机时，keepalived软件会自动更新路由器中的路由表，把虚拟IP重定向到另外一台正常的LVS服务器，从而达到LVS服务器高可用的效果。</p><p>此处需要注意的是，上图中从Nginx层到Tomcat层这样画并不代表全部Nginx都转发请求到全部的Tomcat，在实际使用时，可能会是几个Nginx下面接一部分的Tomcat，这些Nginx之间通过keepalived实现高可用，其他的Nginx接另外的Tomcat，这样可接入的Tomcat数量就能成倍的增加。</p><blockquote><p>架构瓶颈：由于LVS也是单机的，随着并发数增长到几十万时，LVS服务器最终会达到瓶颈，此时用户数达到千万甚至上亿级别，用户分布在不同的地区，与服务器机房距离不同，导致了访问的延迟会明显不同。</p></blockquote><h3 id="第八次演进：通过DNS轮询实现机房间的负载均衡"><a href="#第八次演进：通过DNS轮询实现机房间的负载均衡" class="headerlink" title="第八次演进：通过DNS轮询实现机房间的负载均衡"></a>第八次演进：通过DNS轮询实现机房间的负载均衡</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://www.52im.net/data/attachment/forum/201907/17/163917m8lfsvtpkvmv0mvt.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在DNS服务器中可配置一个域名对应多个IP地址，每个IP地址对应到不同的机房里的虚拟IP。当用户访问<a href="http://www.taobao.com时，DNS服务器会使用轮询策略或其他策略，来选择某个IP供用户访问。此方式能实现机房间的负载均衡，至此，系统可做到机房级别的水平扩展，千万级到亿级的并发量都可通过增加机房来解决，系统入口处的请求并发量不再是问题。" target="_blank" rel="noopener">www.taobao.com时，DNS服务器会使用轮询策略或其他策略，来选择某个IP供用户访问。此方式能实现机房间的负载均衡，至此，系统可做到机房级别的水平扩展，千万级到亿级的并发量都可通过增加机房来解决，系统入口处的请求并发量不再是问题。</a></p><blockquote><p>架构瓶颈：随着数据的丰富程度和业务的发展，检索、分析等需求越来越丰富，单单依靠数据库无法解决如此丰富的需求。</p></blockquote><h3 id="第九次演进：引入NoSQL数据库和搜索引擎等技术"><a href="#第九次演进：引入NoSQL数据库和搜索引擎等技术" class="headerlink" title="第九次演进：引入NoSQL数据库和搜索引擎等技术"></a>第九次演进：引入NoSQL数据库和搜索引擎等技术</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://www.52im.net/data/attachment/forum/201907/17/163922wszk1s1dd3rk3kbu.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>当数据库中的数据多到一定规模时，数据库就不适用于复杂的查询了，往往只能满足普通查询的场景。对于统计报表场景，在数据量大时不一定能跑出结果，而且在跑复杂查询时会导致其他查询变慢，对于全文检索、可变数据结构等场景，数据库天生不适用。因此需要针对特定的场景，引入合适的解决方案。如对于海量文件存储，可通过分布式文件系统HDFS解决，对于key value类型的数据，可通过HBase和Redis等方案解决，对于全文检索场景，可通过搜索引擎如ElasticSearch解决，对于多维分析场景，可通过Kylin或Druid等方案解决。</p><p>当然，引入更多组件同时会提高系统的复杂度，不同的组件保存的数据需要同步，需要考虑一致性的问题，需要有更多的运维手段来管理这些组件等。</p><blockquote><p>架构瓶颈：引入更多组件解决了丰富的需求，业务维度能够极大扩充，随之而来的是一个应用中包含了太多的业务代码，业务的升级迭代变得困难。</p></blockquote><h3 id="第十次演进：大应用拆分为小应用"><a href="#第十次演进：大应用拆分为小应用" class="headerlink" title="第十次演进：大应用拆分为小应用"></a>第十次演进：大应用拆分为小应用</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://www.52im.net/data/attachment/forum/201907/17/163929tttd63d8t1z8xzoo.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>按照业务板块来划分应用代码，使单个应用的职责更清晰，相互之间可以做到独立升级迭代。这时候应用之间可能会涉及到一些公共配置，可以通过分布式配置中心Zookeeper来解决。</p><blockquote><p>架构瓶颈：不同应用之间存在共用的模块，由应用单独管理会导致相同代码存在多份，导致公共功能升级时全部应用代码都要跟着升级。</p></blockquote><h3 id="第十一次演进：复用的功能抽离成微服务"><a href="#第十一次演进：复用的功能抽离成微服务" class="headerlink" title="第十一次演进：复用的功能抽离成微服务"></a>第十一次演进：复用的功能抽离成微服务</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://www.52im.net/data/attachment/forum/201907/17/163935luvsmt9k2ltemstl.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>如用户管理、订单、支付、鉴权等功能在多个应用中都存在，那么可以把这些功能的代码单独抽取出来形成一个单独的服务来管理，这样的服务就是所谓的微服务，应用和服务之间通过HTTP、TCP或RPC请求等多种方式来访问公共服务，每个单独的服务都可以由单独的团队来管理。此外，可以通过Dubbo、SpringCloud等框架实现服务治理、限流、熔断、降级等功能，提高服务的稳定性和可用性。</p><blockquote><p>架构瓶颈：不同服务的接口访问方式不同，应用代码需要适配多种访问方式才能使用服务，此外，应用访问服务，服务之间也可能相互访问，调用链将会变得非常复杂，逻辑变得混乱。</p></blockquote><h3 id="第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异"><a href="#第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异" class="headerlink" title="第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异"></a>第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://www.52im.net/data/attachment/forum/201907/17/163941xp68p88fpj85582a.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>通过ESB统一进行访问协议转换，应用统一通过ESB来访问后端服务，服务与服务之间也通过ESB来相互调用，以此降低系统的耦合程度。</p><p>这种单个应用拆分为多个应用，公共服务单独抽取出来来管理，并使用企业消息总线来解除服务之间耦合问题的架构，就是所谓的SOA（面向服务）架构，这种架构与微服务架构容易混淆，因为表现形式十分相似。</p><p>个人理解，微服务架构更多是指把系统里的公共服务抽取出来单独运维管理的思想，而SOA架构则是指一种拆分服务并使服务接口访问变得统一的架构思想，SOA架构中包含了微服务的思想。</p><blockquote><p>架构瓶颈：业务不断发展，应用和服务都会不断变多，应用和服务的部署变得复杂，同一台服务器上部署多个服务还要解决运行环境冲突的问题，此外，对于如大促这类需要动态扩缩容的场景，需要水平扩展服务的性能，就需要在新增的服务上准备运行环境，部署服务等，运维将变得十分困难。</p></blockquote><h3 id="第十三次演进：引入容器化技术实现运行环境隔离与动态服务管理"><a href="#第十三次演进：引入容器化技术实现运行环境隔离与动态服务管理" class="headerlink" title="第十三次演进：引入容器化技术实现运行环境隔离与动态服务管理"></a>第十三次演进：引入容器化技术实现运行环境隔离与动态服务管理</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://www.52im.net/data/attachment/forum/201907/17/163946nbqxiiiibbx7iba7.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>目前最流行的容器化技术是Docker，最流行的容器管理服务是Kubernetes(K8S)，应用/服务可以打包为Docker镜像，通过K8S来动态分发和部署镜像。Docker镜像可理解为一个能运行你的应用/服务的最小的操作系统，里面放着应用/服务的运行代码，运行环境根据实际的需要设置好。把整个“操作系统”打包为一个镜像后，就可以分发到需要部署相关服务的机器上，直接启动Docker镜像就可以把服务起起来，使服务的部署和运维变得简单。</p><p>在大促的之前，可以在现有的机器集群上划分出服务器来启动Docker镜像，增强服务的性能，大促过后就可以关闭镜像，对机器上的其他服务不造成影响（在第18节之前，服务运行在新增机器上需要修改系统配置来适配服务，这会导致机器上其他服务需要的运行环境被破坏）。</p><blockquote><p>架构瓶颈：使用容器化技术后服务动态扩缩容问题得以解决，但是机器还是需要公司自身来管理，在非大促的时候，还是需要闲置着大量的机器资源来应对大促，机器自身成本和运维成本都极高，资源利用率低。</p></blockquote><h3 id="第十四次演进：以云平台承载系统"><a href="#第十四次演进：以云平台承载系统" class="headerlink" title="第十四次演进：以云平台承载系统"></a>第十四次演进：以云平台承载系统</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://www.52im.net/data/attachment/forum/201907/17/163951mmlrsfhrgvh2usnn.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>系统可部署到公有云上，利用公有云的海量机器资源，解决动态硬件资源的问题，在大促的时间段里，在云平台中临时申请更多的资源，结合Docker和K8S来快速部署服务，在大促结束后释放资源，真正做到按需付费，资源利用率大大提高，同时大大降低了运维成本。</p><p>所谓的云平台，就是把海量机器资源，通过统一的资源管理，抽象为一个资源整体，在之上可按需动态申请硬件资源（如CPU、内存、网络等），并且之上提供通用的操作系统，提供常用的技术组件（如Hadoop技术栈，MPP数据库等）供用户使用，甚至提供开发好的应用，用户不需要关系应用内部使用了什么技术，就能够解决需求（如音视频转码服务、邮件服务、个人博客等）。</p><p>在云平台中会涉及如下几个概念：</p><ul><li>IaaS：基础设施即服务。对应于上面所说的机器资源统一为资源整体，可动态申请硬件资源的层面；</li><li>PaaS：平台即服务。对应于上面所说的提供常用的技术组件方便系统的开发和维护；</li><li>SaaS：软件即服务。对应于上面所说的提供开发好的应用或服务，按功能或性能要求付费。</li></ul><p>至此：以上所提到的从高并发访问问题，到服务的架构和系统实施的层面都有了各自的解决方案。但同时也应该意识到，在上面的介绍中，其实是有意忽略了诸如跨机房数据同步、分布式事务实现等等的实际问题，这些问题以后有机会再拿出来单独讨论。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="架构的调整是否必须按照上述演变路径进行？"><a href="#架构的调整是否必须按照上述演变路径进行？" class="headerlink" title="架构的调整是否必须按照上述演变路径进行？"></a>架构的调整是否必须按照上述演变路径进行？</h3><p>不是的，以上所说的架构演变顺序只是针对某个侧面进行单独的改进，在实际场景中，可能同一时间会有几个问题需要解决，或者可能先达到瓶颈的是另外的方面，这时候就应该按照实际问题实际解决。如在政府类的并发量可能不大，但业务可能很丰富的场景，高并发就不是重点解决的问题，此时优先需要的可能会是丰富需求的解决方案。</p><h3 id="对于将要实施的系统，架构应该设计到什么程度？"><a href="#对于将要实施的系统，架构应该设计到什么程度？" class="headerlink" title="对于将要实施的系统，架构应该设计到什么程度？"></a>对于将要实施的系统，架构应该设计到什么程度？</h3><p>对于单次实施并且性能指标明确的系统，架构设计到能够支持系统的性能指标要求就足够了，但要留有扩展架构的接口以便不备之需。对于不断发展的系统，如电商平台，应设计到能满足下一阶段用户量和性能指标要求的程度，并根据业务的增长不断的迭代升级架构，以支持更高的并发和更丰富的业务。</p><h3 id="服务端架构和大数据架构有什么区别？"><a href="#服务端架构和大数据架构有什么区别？" class="headerlink" title="服务端架构和大数据架构有什么区别？"></a>服务端架构和大数据架构有什么区别？</h3><p>所谓的“大数据”其实是海量数据采集清洗转换、数据存储、数据分析、数据服务等场景解决方案的一个统称，在每一个场景都包含了多种可选的技术，如数据采集有Flume、Sqoop、Kettle等，数据存储有分布式文件系统HDFS、FastDFS，NoSQL数据库HBase、MongoDB等，数据分析有Spark技术栈、机器学习算法等。总的来说大数据架构就是根据业务的需求，整合各种大数据组件组合而成的架构，一般会提供分布式存储、分布式计算、多维分析、数据仓库、机器学习算法等能力。而服务端架构更多指的是应用组织层面的架构，底层能力往往是由大数据架构来提供。</p><h3 id="有没有一些架构设计的原则？"><a href="#有没有一些架构设计的原则？" class="headerlink" title="有没有一些架构设计的原则？"></a>有没有一些架构设计的原则？</h3><ul><li>a. N+1设计：系统中的每个组件都应做到没有单点故障；</li><li>b. 回滚设计：确保系统可以向前兼容，在系统升级时应能有办法回滚版本；</li><li>c. 禁用设计：应该提供控制具体功能是否可用的配置，在系统出现故障时能够快速下线功能；</li><li>d. 监控设计：在设计阶段就要考虑监控的手段；</li><li>e. 多活数据中心设计：若系统需要极高的高可用，应考虑在多地实施数据中心进行多活，至少在一个机房断电的情况下系统依然可用；</li><li>f. 采用成熟的技术：刚开发的或开源的技术往往存在很多隐藏的bug，出了问题没有商业支持可能会是一个灾难；</li><li>g. 资源隔离设计：应避免单一业务占用全部资源；</li><li>h. 架构应能水平扩展：系统只有做到能水平扩展，才能有效避免瓶颈问题；</li><li>i. 非核心则购买：非核心功能若需要占用大量的研发资源才能解决，则考虑购买成熟的产品；</li><li>j. 使用商用硬件：商用硬件能有效降低硬件故障的机率；</li><li>k. 快速迭代：系统应该快速开发小功能模块，尽快上线进行验证，早日发现问题大大降低系统交付的风险；</li><li>l. 无状态设计：服务接口应该做成无状态的，当前接口的访问不依赖于接口上次访问的状态。</li></ul><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a></p></blockquote><blockquote><p><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><blockquote><p>《<a href="http://www.52im.net/thread-2007-1-1.html" target="_blank" rel="noopener">新手入门：零基础理解大型分布式架构的演进历史、技术原理、最佳实践</a>》</p></blockquote><blockquote><p>《<a href="http://www.52im.net/thread-1811-1-1.html" target="_blank" rel="noopener">腾讯资深架构师干货总结：一文读懂大型分布式系统设计的方方面面</a>》</p></blockquote><blockquote><p>《<a href="http://www.52im.net/thread-2494-1-1.html" target="_blank" rel="noopener">一篇读懂分布式架构下的负载均衡技术：分类、原理、算法、常见方案等</a>》</p></blockquote><blockquote><p>《<a href="http://www.52im.net/thread-1950-1-1.html" target="_blank" rel="noopener">快速理解高性能HTTP服务端的负载均衡技术原理</a>》</p></blockquote><blockquote><p>《<a href="http://www.52im.net/thread-1968-1-1.html" target="_blank" rel="noopener">知乎技术分享：从单机到2000万QPS并发的Redis高性能缓存实践之路</a>》</p></blockquote><blockquote><p>《<a href="http://www.52im.net/thread-2141-1-1.html" target="_blank" rel="noopener">达达O2O后台架构演进实践：从0到4000高并发请求背后的努力</a>》</p></blockquote><blockquote><p>《<a href="http://www.52im.net/thread-2323-1-1.html" target="_blank" rel="noopener">小米技术分享：解密小米抢购系统千万高并发架构的演进和实践</a>》</p></blockquote><blockquote><p>《<a href="http://www.52im.net/thread-2510-1-1.html" target="_blank" rel="noopener">通俗易懂：如何设计能支撑百万并发的数据库架构？</a>》</p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;万丈高楼平地起的前提是地基好.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;在介绍架构之前，为了避免
      
    
    </summary>
    
      <category term="架构" scheme="https://lywlefan.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构发展" scheme="https://lywlefan.github.io/tags/%E6%9E%B6%E6%9E%84%E5%8F%91%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>LMAX架构</title>
    <link href="https://lywlefan.github.io/2019/06/21/%E6%9E%B6%E6%9E%84/LMAX%E6%9E%B6%E6%9E%84/LMAX%E6%9E%B6%E6%9E%84/"/>
    <id>https://lywlefan.github.io/2019/06/21/架构/LMAX架构/LMAX架构/</id>
    <published>2019-06-20T16:00:00.000Z</published>
    <updated>2019-07-19T09:24:24.515Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>万丈高楼平地起的前提是地基好.</p></blockquote><h2 id="LMAX架构简介"><a href="#LMAX架构简介" class="headerlink" title="LMAX架构简介"></a>LMAX架构简介</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic002.cnblogs.com/images/2012/13665/2012021214023190.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic002.cnblogs.com/images/2012/13665/2012021214025031.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic002.cnblogs.com/images/2012/13665/2012021214031164.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>该架构主要基于：Disruptor + In Memory DDD + Event Sourcing</p><ul><li><p>通过高并发框架（Disruptor）实现用户事件的输入和Domain Event的输出；</p></li><li><p>一个常驻内存的Business Logic Processor（DDD领域模型），它负责在纯内存中处理业务逻辑；关键点：首先确保用户输入事件被持久化到数据库，并定时创建快照，然后在内存中响应事件更改业务对象的状态；因为一切都是在内存中处理，所以没有IO，也不需要数据库事务，非常快；</p></li><li><p>机器down了怎么办？因为我们首先确保了业务对象的任何状态改变之前先持久化用户输入事件，所以在down机的时候通过事件回溯重新得到最新的业务对象。因为有了快照的保存，所以重建对象也非常快；</p></li></ul><p>该架构的主要观点：</p><ul><li><p>肯定了In-Memory内存模式 + 异步输入与输出事件（Disruptor） + Event Sourcing 架构，LMAX实践也验证了这个架构。这个架构降低复杂性。</p></li><li><p>LMAX的核心是新型并发框架Disruptor，其核心是根据现代CPU硬件缓存特点发明不同于通用LinkedList或Queue的新型数据结构RingBuffer。</p></li><li><p>号称并发未来的Actor模型被LMAX团队验证是有瓶颈的。</p></li><li><p>提出新的并发模型，每个CPU一个线程，多个CPU多个线程并发模式，摒弃了锁模式。</p></li><li><p>ORM等Hibernate没有完全解决OO的目标，关系数据库的事务也不是最后救命的稻草。LMAX用自己的事件记录的方式实现事务，这也不同于所谓内存事务STM。</p></li><li><p>架构师要分离关注，一是通过DDD降低业务的复杂性；二是通过技术探索创新，降低技术平台的复杂性，让程序员更多精力投入业务问题解决上。</p></li></ul><blockquote><p><strong>参考文档</strong></p></blockquote><blockquote><p><a href="https://www.jianshu.com/u/354cc1548a33" target="_blank" rel="noopener">【1】简书主页·share猿</a></p></blockquote><blockquote><p><a href="https://juejin.im/user/5a8e759851882524d842d174" target="_blank" rel="noopener">【2】掘金主页·share猿</a></p></blockquote><blockquote><p><a href="https://www.cnblogs.com/netfocus/archive/2012/02/12/2347919.html" target="_blank" rel="noopener">【3】LMAX架构简介·汤雪华</a></p></blockquote><hr><p><strong>扫描以下公众号关注小猿↓↓↓↓↓↓↓↓</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3084894-e6e9a10cf3e08bba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>更多资讯请在<strong>简书、微博、今日头条、掘金、CSDN</strong>都可以通过搜索<strong>“Share猿”</strong>找到小猿哦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;万丈高楼平地起的前提是地基好.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;LMAX架构简介&quot;&gt;&lt;a href=&quot;#LMAX架构简介&quot; class=&quot;headerlink&quot; title=&quot;LMAX架构简介&quot;&gt;&lt;/a&gt;LMAX架构简介&lt;/h2
      
    
    </summary>
    
      <category term="架构" scheme="https://lywlefan.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="并发" scheme="https://lywlefan.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="LMAX" scheme="https://lywlefan.github.io/tags/LMAX/"/>
    
  </entry>
  
</feed>
